ocs/testing-guide.md</path>
<content lines="1-176">
# Guia Prático de Testes - Project Wiz

## 1. Configuração Inicial

### Ambiente de Teste
```typescript
// vitest.config.mts
import { defineConfig } from 'vitest/config';
import path from 'path';

export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
    setupFiles: ['./tests/setup.ts'],
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      include: ['src/**/*.mts', 'vite.*.mts'],
    },
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
});
```

### Banco de Dados em Memória (Drizzle)
```typescript
// tests/setup/drizzle.ts
import { Database } from "better-sqlite3";
import { drizzle } from "drizzle-orm/better-sqlite3";
import { migrate } from "drizzle-orm/better-sqlite3/migrator";

export async function setupTestDB() {
  const sqlite = new Database(":memory:");
  const db = drizzle(sqlite);
  await migrate(db, { migrationsFolder: "./migrations" });
  return db;
}
```

## 2. Tipos de Testes

### 2.1 Testes Unitários

**Exemplo baseado em job.entity.test.ts:**
```typescript
import { describe, it, expect } from "vitest";
import { Job } from "@/core/domain/entities/jobs/job.entity";

describe("Job Entity", () => {
  it("should validate priority correctly", () => {
    const job = new Job("test-id", new JobStatus("WAITING"));
    
    // Testa valores válidos
    expect(job.setPriority(5).success).toBe(true);
    
    // Testa valores inválidos
    expect(job.setPriority(-1).success).toBe(false);
    expect(job.setPriority(11).success).toBe(false);
  });
});
```

**Boas práticas:**
- Teste uma única unidade de código por vez
- Foque em comportamentos, não implementações
- Use nomes descritivos para testes
- Teste caminhos felizes e casos de erro

### 2.2 Testes de Integração

**Exemplo baseado em queue.repository.test.ts:**
```typescript
import { describe, it, expect, beforeAll } from "vitest";
import { getTestDB } from "@/tests/setup/drizzle";
import { DrizzleQueueRepository } from "@/infrastructure/repositories/drizzle/queue.repository";

describe("DrizzleQueueRepository - Integration Tests", () => {
  let repository: DrizzleQueueRepository;

  beforeAll(async () => {
    const db = await getTestDB();
    repository = new DrizzleQueueRepository(db);
  });

  it("should reject null queue on save", async () => {
    await expect(repository.save(null)).rejects.toThrow(
      "Queue parameter cannot be null"
    );
  });
});
```

**Boas práticas:**
- Configure o ambiente antes dos testes (beforeAll)
- Teste interações entre componentes
- Verifique comportamentos com dependências reais (banco de dados)
- Limpe o estado após cada teste

### 2.3 Testes de Stress

**Exemplo baseado em queue.stress.test.ts:**
```typescript
describe("Queue Stress Tests", () => {
  it("should handle 1000+ jobs simultaneously", async () => {
    // Configuração
    const jobsCount = 1000;
    
    // Execução
    const startTime = performance.now();
    // ... lógica para adicionar e processar jobs
    const totalTime = performance.now() - startTime;
    
    // Verificação
    console.log(`Processed ${jobsCount} jobs in ${totalTime}ms`);
    expect(processedCount).toBe(jobsCount);
  });
});
```

**Boas práticas:**
- Teste com volumes altos de dados
- Meça tempos de execução
- Verifique estabilidade do sistema sob carga
- Documente resultados de performance

## 3. Testes com Transações

### 3.1 Visão Geral
O sistema utiliza o padrão `runInTransaction` ([ADR-002: Transaction Pattern](../../reference/adrs/ADR-XXX-transaction-pattern.md) (Nota: Link para ADR específico a ser confirmado/localizado)) para garantir atomicidade nas operações críticas. Esta seção cobre testes específicos para transações.

### 3.2 Testando o Wrapper de Transações
**Exemplo baseado em transaction-wrapper.spec.ts:**
```typescript
import { describe, it, expect, vi } from "vitest";
import { TransactionWrapper } from "@/infrastructure/services/drizzle/transaction-wrapper";

describe("TransactionWrapper", () => {
  it("should commit successful transaction", async () => {
    const mockDb = { transaction: vi.fn() };
    const wrapper = new TransactionWrapper(mockDb);
    
    const result = await wrapper.runInTransaction(async () => "success");
    
    expect(result).toBe("success");
    expect(mockDb.transaction).toHaveBeenCalled();
  });

  it("should rollback on operation failure", async () => {
    const mockDb = { transaction: vi.fn() };
    const wrapper = new TransactionWrapper(mockDb);
    
    await expect(
      wrapper.runInTransaction(async () => {
        throw new Error("Operation failed");
      })
    ).rejects.toThrow("Operation failed");
  });
});
```

### 3.3 Testes de Rollback Automático
```typescript
it("should rollback all changes when error occurs", async () => {
  const db = await getTestDB();
  const wrapper = new TransactionWrapper(db);
  
  try {
    await wrapper.runInTransaction(async (tx) => {
      await tx.insert(jobsTable).values({ id: "job-1", status: "PENDING" });
      throw new Error("Simulated failure");
    });
  } catch (error) {
    // Verifica se o rollback ocorreu
    const result = await db.select().from(jobsTable);
    expect(result).toHaveLength(0);
  }
});
```

### 3.4 Testes de Concorrência
```typescript
it("should handle concurrent transactions correctly", async () => {
  const db = await getTestDB();
  const wrapper = new TransactionWrapper(db);
  
  const promises = Array(10).fill(0).map(async (_, i) => {
    return wrapper.runInTransaction(async (tx) => {
      await tx.insert(jobsTable).values({ id: `job-${i}`, status: "PENDING" });
    });
  });
  
  await Promise.all(promises);
  
  const result = await db.select().from(jobsTable);
  expect(result).toHaveLength(10); // Todas as transações foram commitadas
});
```

### 3.5 Testes de Timeout
```typescript
it("should timeout long-running transactions", async () => {
  const db = await getTestDB();
  const wrapper = new TransactionWrapper(db, { timeout: 100 });
  
  await expect(
    wrapper.runInTransaction(async () => {
      await new Promise(resolve => setTimeout(resolve, 200));
    })
  ).rejects.toThrow("Transaction timeout");
});
```

## 4. Fluxo de Trabalho Recomendado

1. **Escreva testes primeiro** (TDD quando possível)
2. **Execute testes localmente** antes de commitar
   ```bash
   npm test
   ```
3. **Verifique cobertura** de testes
   ```bash
   npm run test:coverage
   ```
4. **Execute migrações** antes de testes com banco
   ```bash
   npm run drizzle:migrate
   ```
5. **Integração contínua** - Garanta que todos os testes passem no CI

## 5. Solução de Problemas Comuns

### Problema: Testes lentos com banco de dados
**Solução:**
- Use banco em memória
- Limpe dados entre testes
- Evite migrações desnecessárias

### Problema: Testes flaky (intermitentes)
**Solução:**
- Isole testes com estado compartilhado
- Use dados determinísticos
- Evite dependência de ordem de execução

### Problema: Mock complexo
**Solução:**
- Prefira implementações reais em testes de integração
- Use fakes ao invés de mocks quando possível
- Mantenham mocks simples e focados

## 6. Referências aos Padrões Consolidados

Este guia complementa os padrões de teste e boas práticas gerais descritas em outros documentos, como o [Guia de Padrões de Código](./02-coding-standards.md) e o [Guia de Boas Práticas Detalhadas](../../reference/02-best-practices.md).

## 7. Recursos Adicionais

- [Documentação do Vitest](https://vitest.dev/)
- [Guia de Testes com Drizzle ORM](https://orm.drizzle.team/docs/tests)
- [Boas práticas de testes em TypeScript](https://github.com/goldbergyoni/javascript-testing-best-practices)