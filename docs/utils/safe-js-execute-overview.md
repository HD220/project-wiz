# Overview: `safeJSExecute` Utility for Sandboxed JavaScript Execution

## 1. Introduction

The `safeJSExecute` utility is designed to provide a controlled and sandboxed environment for executing JavaScript code snippets, particularly those that might be generated by LLMs or come from untrusted sources. Its primary purpose is to run pure, self-contained JavaScript logic that does not require Node.js module system (`require`/`import`) or direct access to sensitive OS-level operations.

This utility is intended to be wrapped as an `IAgentTool` (e.g., `javascript.executeSandboxedCode`) for use by AI agents like the "Fullstack Developer Agent".

## 2. Core Concept & Code Structure Overview

The `safeJSExecute` function leverages Node.js's built-in `node:vm` module to create an isolated JavaScript execution context.

**Key Components of `safeJSExecute` (Conceptual Overview):**

*   **`SafeJSExecuteOptions`**: Allows configuration of:
    *   `allowedGlobals`: Explicitly whitelisted global objects/functions (e.g., `String`, `JSON`, `Math`, `Promise`).
    *   `timeLimit`: Execution timeout for the script.
    *   `memoryLimit`: Heap memory usage limit for the script.
    *   `maxCallDepth`: Maximum call stack depth.
    *   `maxCodeLength`: Maximum length of the input code string.
    *   `sanitizationOptions`: Options for input code sanitization.

*   **`SafeJSExecuteError`**: Custom error class for specific sandbox violations.

*   **Global Control**:
    *   **Whitelist (`AllowedGlobals` enum):** Defines a base set of standard JavaScript globals that are safe to expose.
    *   **Blacklist (`BLACKLIST` Set, `FORBIDDEN_KEYWORDS` Array):** Explicitly blocks access to sensitive globals (`process`, `require`, `eval`, `Function`, etc.) and keywords that could be used to escape the sandbox or perform unsafe operations.
    *   **Proxied Global (`proxiedGlobal`):** The `vm` context is provided with a proxy object for globals. This proxy intercepts property access, allowing only whitelisted and explicitly allowed globals, and throwing an error for unauthorized access.

*   **Resource Limiting**:
    *   **Timeout:** `vm.Script.runInNewContext` uses a `timeout` option.
    *   **Memory Limit:** A `setInterval` check monitors `process.memoryUsage().heapUsed` against a limit.
    *   **Call Depth:** A `depthControl` wrapper is injected into the context to track and limit recursive calls.
    *   **Code Length:** Input code string length is checked.

*   **Input Sanitization (`sanitizeInput`, `checkForbiddenKeywords` functions)**:
    *   Attempts to remove comments, escape sequences, and control characters from the input code string.
    *   Checks for the presence of forbidden keywords.

*   **Execution Flow**:
    1.  Options are processed (defaults applied).
    2.  `safeGlobal` object is constructed based on `AllowedGlobals` and `options.allowedGlobals`.
    3.  This `safeGlobal` is proxied to create `proxiedGlobal`.
    4.  The input `code` string is checked for length, sanitized, and checked for forbidden keywords.
    5.  A `vm.Context` is created with `proxiedGlobal`.
    6.  A `vm.Script` is compiled from the (wrapped) code.
    7.  Memory monitoring is started.
    8.  `script.runInNewContext()` executes the code with the specified timeout and other VM options.
    9.  The result of the script execution is returned.
    10. Error handling catches exceptions from script errors, timeouts, memory limits, etc.
    11. Resources (memory check interval, context properties) are cleaned up in a `finally` block.

**Simplified Code Snippet (Illustrative of Core VM Usage):**
```javascript
// import vm from "node:vm";
// // ... (setup of safeGlobals, options) ...

// return async (code: string): Promise<unknown> => {
//   // ... (input validation, sanitization) ...
//   const context = vm.createContext(safeGlobalsWithProxy);
//   const script = new vm.Script(\`(function() { 'use strict'; \${code} })();\`);
//
//   // ... (setup memory monitoring, call depth control) ...
//
//   try {
//     const result = await script.runInNewContext(context, {
//       timeout: options.timeLimit,
//       // ... other vm options
//     });
//     return result;
//   } catch (error) {
//     // ... handle/rethrow error ...
//   } finally {
//     // ... cleanup ...
//   }
// };
```

## 3. Key Features

*   **Sandboxed Execution:** Uses `node:vm` to run code in an isolated context.
*   **Controlled Global Access:** Only explicitly whitelisted globals are available to the executed code.
*   **Resource Constraints:** Imposes limits on execution time, memory usage, and call stack depth.
*   **Input Sanitization:** Basic attempts to clean potentially harmful input code.
*   **Blacklisting:** Prevents usage of dangerous keywords and properties.

## 4. Limitations

*   **No `require()` or `import`:** The most significant limitation. Scripts cannot import Node.js built-in modules (e.g., `fs`, `path`, `http`) or external npm packages. This restricts the tool to pure JavaScript logic that relies only on the provided globals.
*   **Sandbox Imperfection:** While `vm` provides isolation, determined attackers can sometimes find ways to escape Node.js VM sandboxes, especially if any exposed global or function has unforeseen vulnerabilities or provides access back to the main Node.js context. The security relies heavily on the correctness of the whitelist/blacklist and the robustness of the `vm` module itself against such escapes.
*   **Performance Overhead:** The proxying, sanitization, and monitoring add overhead compared to direct execution.

## 5. Intended Use Case

The `safeJSExecute` utility, when wrapped as an `IAgentTool` like `javascript.executeSandboxedCode`, is intended for scenarios where an AI agent needs to:
*   Evaluate simple mathematical expressions or logical conditions.
*   Perform data transformations or manipulations on JavaScript objects/arrays.
*   Execute small, self-contained utility functions generated by an LLM.
*   Run code where direct access to the file system, network, or other Node.js modules is explicitly **not** required or desired for security reasons.

It is **not** a replacement for running full Node.js applications or scripts that require module system access. For those, the `FileSystemTool` (to write the script) and `TerminalTool` (to execute `node your_script.js`) remain the appropriate tools.
