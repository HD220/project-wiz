[{"filePath":"/app/src_refactored/core/application/common/errors.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/common/executable.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/common/ports/use-case.interface.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"An interface declaring no members is equivalent to its supertype.","line":18,"column":18,"nodeType":"Identifier","messageId":"noEmptyInterfaceWithSuper","endLine":18,"endColumn":26,"suggestions":[{"messageId":"replaceEmptyInterfaceWithSuper","fix":{"range":[743,1129],"text":"type IUseCase<\n  TRequest,\n  TResponse,\n  TError extends Error = DomainError | ApplicationError,\n> = Executable<TRequest, TResponse, TError>"},"desc":"Replace empty interface with a type alias."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/ports/events/i-job-event-emitter.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/ports/job-repository.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/ports/services/i-agent-executor.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/ports/services/i-chat.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/ports/services/i-embedding.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/ports/services/i-tool-registry.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/queue/abstract-queue.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/queue/events/job-event.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/services/agent-interaction.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/services/agent-state.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/services/agent-tool.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/services/chat.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/services/generic-agent-executor.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/services/tool-validation.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/agent-internal-state/load-agent-internal-state.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/agent-internal-state/load-agent-internal-state.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/agent-internal-state/save-agent-internal-state.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/agent-internal-state/save-agent-internal-state.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/agent-persona-template/create-persona-template.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/agent-persona-template/create-persona-template.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/agent/create-agent.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/agent/create-agent.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/annotation/list-annotations.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/annotation/list-annotations.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/annotation/remove-annotation.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/annotation/remove-annotation.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/annotation/save-annotation.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/annotation/save-annotation.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/llm-provider-config/create-llm-provider-config.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/llm-provider-config/create-llm-provider-config.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/memory/remove-memory-item.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/memory/remove-memory-item.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/memory/save-memory-item.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/memory/save-memory-item.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/memory/search-memory-items.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/memory/search-memory-items.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/memory/search-similar-memory-items.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/memory/search-similar-memory-items.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/project/create-project.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/project/create-project.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/project/get-project-details.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/project/get-project-details.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/project/list-projects.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/project/list-projects.use-case.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'input' is defined but never used. Allowed unused args must match /^_/u.","line":32,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":32,"endColumn":10,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/user/create-user.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/user/create-user.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/user/get-user.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/user/get-user.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/worker/__tests__/worker.service.close.spec.ts","messages":[{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'boundaries/element-types').","line":9,"column":1,"severity":1,"nodeType":null,"fix":{"range":[573,676],"text":" "}},{"ruleId":"import/no-unresolved","severity":2,"message":"Unable to resolve path to module '../../../../infrastructure/queue/drizzle/queue.service'.","line":10,"column":30,"nodeType":"Literal","endLine":10,"endColumn":86}],"suppressedMessages":[{"ruleId":"boundaries/element-types","severity":2,"message":"APPLICATION: Proibido importar de infrastructure (permitido: domain, shared).","line":6,"column":38,"nodeType":"Literal","endLine":6,"endColumn":113,"suppressions":[{"kind":"directive","justification":"Integration test needs access to infrastructure"}]},{"ruleId":"boundaries/element-types","severity":2,"message":"APPLICATION: Proibido importar de infrastructure (permitido: domain, shared).","line":8,"column":59,"nodeType":"Literal","endLine":8,"endColumn":126,"suppressions":[{"kind":"directive","justification":"Integration test needs access to infrastructure"}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { randomUUID } from 'node:crypto';\n\nimport { vi, describe, it, expect, beforeEach, afterEach, Mock } from 'vitest';\n\n// eslint-disable-next-line boundaries/element-types -- Integration test needs access to infrastructure\nimport { DrizzleJobRepository } from '../../../../infrastructure/persistence/drizzle/job/drizzle-job.repository';\n// eslint-disable-next-line boundaries/element-types -- Integration test needs access to infrastructure\nimport { TestDb, createTestDbClient, runMigrations } from '../../../../infrastructure/queue/drizzle/__tests__/test-db.helper';\n// eslint-disable-next-line boundaries/element-types -- Integration test needs access to infrastructure\nimport { QueueService } from '../../../../infrastructure/queue/drizzle/queue.service';\nimport { JobEntity, JobStatus } from '../../../domain/job/job.entity';\nimport { IJobOptions } from '../../../domain/job/value-objects/job-options.vo';\nimport { WorkerService } from '../worker.service';\n\nimport {\n  TestPayload, TestResult, QUEUE_NAME,\n  defaultWorkerOptions, defaultJobOptions\n} from './worker.service.spec.helper';\n\ndescribe('WorkerService - Close', () => {\n  let db: TestDb;\n  let jobRepository: DrizzleJobRepository;\n  let queueService: QueueService<TestPayload, TestResult>;\n  let workerService: WorkerService<TestPayload, TestResult>;\n  let mockProcessor: Mock<[JobEntity<TestPayload, TestResult>], Promise<TestResult>>;\n\n  const addJobToQueue = async (name: string, payload: TestPayload, opts?: Partial<IJobOptions>) => {\n    const jobOptionsWithId = { ...defaultJobOptions, ...opts };\n    if (payload.id && !jobOptionsWithId.jobId) jobOptionsWithId.jobId = payload.id;\n    return queueService.add(name, payload, jobOptionsWithId);\n  };\n\n  beforeEach(async () => {\n    vi.useFakeTimers();\n    db = createTestDbClient({ memory: true });\n    await runMigrations(db);\n    jobRepository = new DrizzleJobRepository(db);\n    queueService = new QueueService<TestPayload, TestResult>(QUEUE_NAME, jobRepository, defaultJobOptions);\n    mockProcessor = vi.fn();\n    workerService = new WorkerService(queueService, mockProcessor, defaultWorkerOptions);\n    vi.spyOn(workerService, 'emit');\n  });\n\n  afterEach(async () => {\n    if (!workerService.isClosed) await workerService.close();\n    if (queueService) await queueService.close();\n    vi.clearAllMocks(); vi.restoreAllMocks(); vi.useRealTimers();\n    if (db && typeof db.close === 'function') db.close();\n  });\n\n  it('should stop polling, wait for active jobs, and shutdown gracefully', async () => {\n    const jobPayload = { data: 'closing job 1', id: randomUUID() };\n    const addedJob = await addJobToQueue('close-graceful-job', jobPayload);\n    let jobPromiseResolve: (value: TestResult) => void;\n    const jobProcessingPromise = new Promise<TestResult>(resolve => { jobPromiseResolve = resolve; });\n    mockProcessor.mockImplementationOnce(() => jobProcessingPromise);\n    workerService.run();\n    await vi.advanceTimersByTimeAsync(defaultWorkerOptions.pollingIntervalMs! + 50);\n    const closePromise = workerService.close();\n    jobPromiseResolve!({ status: `closed_${addedJob.payload.id}`, id: addedJob.payload.id });\n    await closePromise;\n    expect((await jobRepository.findById(addedJob.id))!.status).toBe(JobStatus.COMPLETED);\n    expect(workerService.isClosed).toBe(true);\n  });\n\n  it('should close immediately if no active jobs', async () => {\n    workerService.run();\n    await vi.advanceTimersByTimeAsync(defaultWorkerOptions.pollingIntervalMs! + 50);\n    await workerService.close();\n    expect(workerService.isClosed).toBe(true);\n  }, 7000);\n});\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/worker/__tests__/worker.service.error-handling.spec.ts","messages":[{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'boundaries/element-types').","line":9,"column":1,"severity":1,"nodeType":null,"fix":{"range":[573,676],"text":" "}},{"ruleId":"import/no-unresolved","severity":2,"message":"Unable to resolve path to module '../../../../infrastructure/queue/drizzle/queue.service'.","line":10,"column":30,"nodeType":"Literal","endLine":10,"endColumn":86}],"suppressedMessages":[{"ruleId":"boundaries/element-types","severity":2,"message":"APPLICATION: Proibido importar de infrastructure (permitido: domain, shared).","line":6,"column":38,"nodeType":"Literal","endLine":6,"endColumn":113,"suppressions":[{"kind":"directive","justification":"Integration test needs access to infrastructure"}]},{"ruleId":"boundaries/element-types","severity":2,"message":"APPLICATION: Proibido importar de infrastructure (permitido: domain, shared).","line":8,"column":59,"nodeType":"Literal","endLine":8,"endColumn":126,"suppressions":[{"kind":"directive","justification":"Integration test needs access to infrastructure"}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { randomUUID } from 'node:crypto';\n\nimport { vi, describe, it, expect, beforeEach, afterEach, Mock } from 'vitest';\n\n// eslint-disable-next-line boundaries/element-types -- Integration test needs access to infrastructure\nimport { DrizzleJobRepository } from '../../../../infrastructure/persistence/drizzle/job/drizzle-job.repository';\n// eslint-disable-next-line boundaries/element-types -- Integration test needs access to infrastructure\nimport { TestDb, createTestDbClient, runMigrations } from '../../../../infrastructure/queue/drizzle/__tests__/test-db.helper';\n// eslint-disable-next-line boundaries/element-types -- Integration test needs access to infrastructure\nimport { QueueService } from '../../../../infrastructure/queue/drizzle/queue.service';\nimport { JobEntity, JobStatus } from '../../../domain/job/job.entity';\nimport { IJobOptions } from '../../../domain/job/value-objects/job-options.vo';\nimport { WorkerService } from '../worker.service';\n\nimport {\n  TestPayload, TestResult, QUEUE_NAME,\n  defaultWorkerOptions, defaultJobOptions\n} from './worker.service.spec.helper';\n\ndescribe('WorkerService - Error Handling and Edge Cases', () => {\n  let db: TestDb;\n  let jobRepository: DrizzleJobRepository;\n  let queueService: QueueService<TestPayload, TestResult>;\n  let workerService: WorkerService<TestPayload, TestResult>;\n  let mockProcessor: Mock<[JobEntity<TestPayload, TestResult>], Promise<TestResult>>;\n\n  const addJobToQueue = async (name: string, payload: TestPayload, opts?: Partial<IJobOptions>) => {\n    const jobOptionsWithId = { ...defaultJobOptions, ...opts };\n    if (payload.id && !jobOptionsWithId.jobId) jobOptionsWithId.jobId = payload.id;\n    return queueService.add(name, payload, jobOptionsWithId);\n  };\n\n  beforeEach(async () => {\n    vi.useFakeTimers();\n    db = createTestDbClient({ memory: true });\n    await runMigrations(db);\n    jobRepository = new DrizzleJobRepository(db);\n    queueService = new QueueService<TestPayload, TestResult>(QUEUE_NAME, jobRepository, defaultJobOptions);\n    mockProcessor = vi.fn();\n    workerService = new WorkerService(queueService, mockProcessor, defaultWorkerOptions);\n    vi.spyOn(workerService, 'emit');\n    vi.spyOn(queueService, 'fetchNextJobAndLock');\n  });\n\n  afterEach(async () => {\n    if (!workerService.isClosed) await workerService.close();\n    if (queueService) await queueService.close();\n    vi.clearAllMocks(); vi.restoreAllMocks(); vi.useRealTimers();\n    if (db && typeof db.close === 'function') db.close();\n  });\n\n  it('should emit worker.error if queue.fetchNextJobAndLock throws', async () => {\n    const fetchError = new Error('DB connection lost');\n    (queueService.fetchNextJobAndLock as Mock).mockRejectedValueOnce(fetchError);\n    workerService.run();\n    await vi.advanceTimersByTimeAsync(defaultWorkerOptions.pollingIntervalMs! + 50);\n    expect(workerService.emit).toHaveBeenCalledWith('worker.error', fetchError);\n  });\n\n  it('should emit worker.job.interrupted if closed during processing', async () => {\n    const jobPayload = { data: 'interrupt me', id: randomUUID() };\n    const addedJob = await addJobToQueue('interrupt-job', jobPayload);\n    const processorPromise = new Promise<TestResult>(() => {});\n    mockProcessor.mockImplementationOnce(() => processorPromise);\n    workerService.run();\n    await vi.advanceTimersByTimeAsync(defaultWorkerOptions.pollingIntervalMs! + 50);\n    await workerService.close();\n    expect(workerService.emit).toHaveBeenCalledWith('worker.job.interrupted', expect.objectContaining({ id: addedJob.id }));\n    const jobFromDb = await jobRepository.findById(addedJob.id);\n    expect(jobFromDb!.status).toBe(JobStatus.ACTIVE);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/worker/__tests__/worker.service.initialization.spec.ts","messages":[{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'boundaries/element-types').","line":7,"column":1,"severity":1,"nodeType":null,"fix":{"range":[530,633],"text":" "}},{"ruleId":"import/no-unresolved","severity":2,"message":"Unable to resolve path to module '../../../../infrastructure/queue/drizzle/queue.service'.","line":8,"column":30,"nodeType":"Literal","endLine":8,"endColumn":86}],"suppressedMessages":[{"ruleId":"boundaries/element-types","severity":2,"message":"APPLICATION: Proibido importar de infrastructure (permitido: domain, shared).","line":4,"column":38,"nodeType":"Literal","endLine":4,"endColumn":113,"suppressions":[{"kind":"directive","justification":"Integration test needs access to infrastructure"}]},{"ruleId":"boundaries/element-types","severity":2,"message":"APPLICATION: Proibido importar de infrastructure (permitido: domain, shared).","line":6,"column":59,"nodeType":"Literal","endLine":6,"endColumn":126,"suppressions":[{"kind":"directive","justification":"Integration test needs access to infrastructure"}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { vi, describe, it, expect, beforeEach, afterEach, Mock } from 'vitest';\n\n// eslint-disable-next-line boundaries/element-types -- Integration test needs access to infrastructure\nimport { DrizzleJobRepository } from '../../../../infrastructure/persistence/drizzle/job/drizzle-job.repository';\n// eslint-disable-next-line boundaries/element-types -- Integration test needs access to infrastructure\nimport { TestDb, createTestDbClient, runMigrations } from '../../../../infrastructure/queue/drizzle/__tests__/test-db.helper';\n// eslint-disable-next-line boundaries/element-types -- Integration test needs access to infrastructure\nimport { QueueService } from '../../../../infrastructure/queue/drizzle/queue.service';\nimport { JobEntity } from '../../../domain/job/job.entity';\nimport { WorkerService } from '../worker.service';\n\nimport {\n  TestPayload, TestResult, QUEUE_NAME,\n  defaultWorkerOptions, defaultJobOptions\n} from './worker.service.spec.helper';\n\ndescribe('WorkerService - Initialization', () => {\n  let db: TestDb;\n  let jobRepository: DrizzleJobRepository;\n  let queueService: QueueService<TestPayload, TestResult>;\n  let workerService: WorkerService<TestPayload, TestResult>;\n  let mockProcessor: Mock<[JobEntity<TestPayload, TestResult>], Promise<TestResult>>;\n\n  beforeEach(async () => {\n    vi.useFakeTimers();\n    db = createTestDbClient({ memory: true });\n    await runMigrations(db);\n    jobRepository = new DrizzleJobRepository(db);\n    queueService = new QueueService<TestPayload, TestResult>(QUEUE_NAME, jobRepository, defaultJobOptions);\n    mockProcessor = vi.fn();\n    workerService = new WorkerService(queueService, mockProcessor, defaultWorkerOptions);\n    vi.spyOn(workerService, 'emit');\n  });\n\n  afterEach(async () => {\n    if (!workerService.isClosed) await workerService.close();\n    if (queueService) await queueService.close();\n    vi.clearAllMocks(); vi.restoreAllMocks(); vi.useRealTimers();\n    if (db && typeof db.close === 'function') db.close();\n  });\n\n  it('should create a worker instance', () => {\n    expect(workerService).toBeInstanceOf(WorkerService);\n    expect(workerService.isClosed).toBe(false);\n    expect(workerService.isRunning).toBe(false);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/worker/__tests__/worker.service.job-processing.spec.ts","messages":[{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'boundaries/element-types').","line":9,"column":1,"severity":1,"nodeType":null,"fix":{"range":[573,676],"text":" "}},{"ruleId":"import/no-unresolved","severity":2,"message":"Unable to resolve path to module '../../../../infrastructure/queue/drizzle/queue.service'.","line":10,"column":30,"nodeType":"Literal","endLine":10,"endColumn":86}],"suppressedMessages":[{"ruleId":"boundaries/element-types","severity":2,"message":"APPLICATION: Proibido importar de infrastructure (permitido: domain, shared).","line":6,"column":38,"nodeType":"Literal","endLine":6,"endColumn":113,"suppressions":[{"kind":"directive","justification":"Integration test needs access to infrastructure"}]},{"ruleId":"boundaries/element-types","severity":2,"message":"APPLICATION: Proibido importar de infrastructure (permitido: domain, shared).","line":8,"column":59,"nodeType":"Literal","endLine":8,"endColumn":126,"suppressions":[{"kind":"directive","justification":"Integration test needs access to infrastructure"}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { randomUUID } from 'node:crypto';\n\nimport { vi, describe, it, expect, beforeEach, afterEach, Mock } from 'vitest';\n\n// eslint-disable-next-line boundaries/element-types -- Integration test needs access to infrastructure\nimport { DrizzleJobRepository } from '../../../../infrastructure/persistence/drizzle/job/drizzle-job.repository';\n// eslint-disable-next-line boundaries/element-types -- Integration test needs access to infrastructure\nimport { TestDb, createTestDbClient, runMigrations } from '../../../../infrastructure/queue/drizzle/__tests__/test-db.helper';\n// eslint-disable-next-line boundaries/element-types -- Integration test needs access to infrastructure\nimport { QueueService } from '../../../../infrastructure/queue/drizzle/queue.service';\nimport { JobEntity, JobStatus } from '../../../domain/job/job.entity';\nimport { IJobOptions } from '../../../domain/job/value-objects/job-options.vo';\nimport { WorkerService } from '../worker.service';\n\nimport {\n  TestPayload, TestResult, QUEUE_NAME,\n  defaultWorkerOptions, defaultJobOptions\n} from './worker.service.spec.helper';\n\ndescribe('WorkerService - Run and Job Processing', () => {\n  let db: TestDb;\n  let jobRepository: DrizzleJobRepository;\n  let queueService: QueueService<TestPayload, TestResult>;\n  let workerService: WorkerService<TestPayload, TestResult>;\n  let mockProcessor: Mock<[JobEntity<TestPayload, TestResult>], Promise<TestResult>>;\n\n  const addJobToQueue = async (name: string, payload: TestPayload, opts?: Partial<IJobOptions>) => {\n    const jobOptionsWithId = { ...defaultJobOptions, ...opts };\n    if (payload.id && !jobOptionsWithId.jobId) jobOptionsWithId.jobId = payload.id;\n    return queueService.add(name, payload, jobOptionsWithId);\n  };\n\n  beforeEach(async () => {\n    vi.useFakeTimers();\n    db = createTestDbClient({ memory: true });\n    await runMigrations(db);\n    jobRepository = new DrizzleJobRepository(db);\n    queueService = new QueueService<TestPayload, TestResult>(QUEUE_NAME, jobRepository, defaultJobOptions);\n    mockProcessor = vi.fn();\n    workerService = new WorkerService(queueService, mockProcessor, defaultWorkerOptions);\n    vi.spyOn(workerService, 'emit');\n    vi.spyOn(queueService, 'emit');\n  });\n\n  afterEach(async () => {\n    if (!workerService.isClosed) await workerService.close();\n    if (queueService) await queueService.close();\n    vi.clearAllMocks(); vi.restoreAllMocks(); vi.useRealTimers();\n    if (db && typeof db.close === 'function') db.close();\n  });\n\n  it('should fetch and process a job successfully', async () => {\n    const jobPayload = { data: 'process me', id: randomUUID() };\n    const addedJob = await addJobToQueue('success-job', jobPayload);\n    const expectedResult = { status: 'processed', id: jobPayload.id };\n    mockProcessor.mockResolvedValueOnce(expectedResult);\n    workerService.run();\n    await vi.advanceTimersByTimeAsync(defaultWorkerOptions.pollingIntervalMs! + 50);\n    expect(mockProcessor).toHaveBeenCalledTimes(1);\n    const jobFromDb = await jobRepository.findById(addedJob.id);\n    expect(jobFromDb!.status).toBe(JobStatus.COMPLETED);\n    expect(workerService.emit).toHaveBeenCalledWith('worker.job.processed', expect.anything(), expectedResult);\n  });\n\n  it('should handle job processing failure', async () => {\n    const jobPayload = { data: 'fail me', id: randomUUID() };\n    const addedJob = await addJobToQueue('fail-job', jobPayload, { attempts: 1 });\n    const error = new Error('Processing failed');\n    mockProcessor.mockRejectedValueOnce(error);\n    workerService.run();\n    await vi.advanceTimersByTimeAsync(defaultWorkerOptions.pollingIntervalMs! + 50);\n    const jobFromDb = await jobRepository.findById(addedJob.id);\n    expect(jobFromDb!.status).toBe(JobStatus.FAILED);\n    expect(workerService.emit).toHaveBeenCalledWith('worker.job.errored', expect.anything(), error);\n  });\n\n  it('should process jobs sequentially', async () => {\n    const job1Payload = { data: 'seq_data1', id: randomUUID() };\n    const job2Payload = { data: 'seq_data2', id: randomUUID() };\n    await addJobToQueue('seq-job1', job1Payload);\n    await addJobToQueue('seq-job2', job2Payload);\n    let job1ProcessorEndsAt: number | null = null;\n    let job2ProcessorStartsAt: number | null = null;\n\n    mockProcessor.mockImplementation(async (job) => {\n      const now = Date.now();\n      if (job.payload.id === job2Payload.id) job2ProcessorStartsAt = now;\n      await new Promise(resolve => setTimeout(resolve, 100));\n      if (job.payload.id === job1Payload.id) job1ProcessorEndsAt = Date.now();\n      return { status: `done_${job.payload.id}`, id: job.payload.id };\n    });\n    workerService.run();\n    await vi.advanceTimersByTimeAsync(defaultWorkerOptions.pollingIntervalMs! + 100 + 50);\n    await vi.advanceTimersByTimeAsync(defaultWorkerOptions.pollingIntervalMs! + 100 + 50);\n    expect(job1ProcessorEndsAt).not.toBeNull();\n    expect(job2ProcessorStartsAt).not.toBeNull();\n    expect(job2ProcessorStartsAt!).toBeGreaterThanOrEqual(job1ProcessorEndsAt!);\n    expect(mockProcessor).toHaveBeenCalledTimes(2);\n  });\n\n  it('should handle job.updateProgress and job.addLog', async () => {\n    const jobPayload = { data: 'progress data', id: randomUUID() };\n    const addedJob = await addJobToQueue('progress-log-job', jobPayload);\n    mockProcessor.mockImplementationOnce(async (jobCtx) => {\n      await jobCtx.updateProgress(50);\n      await jobCtx.addLog('Processor log 1', 'INFO');\n      return { status: 'progress_done', id: jobCtx.payload.id };\n    });\n    workerService.run();\n    await vi.advanceTimersByTimeAsync(defaultWorkerOptions.pollingIntervalMs! + 50);\n    const jobFromDb = await jobRepository.findById(addedJob.id);\n    expect(jobFromDb!.progress).toBe(50);\n    expect(jobFromDb!.logs[0].message).toBe('Processor log 1');\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/worker/__tests__/worker.service.lock-renewal.spec.ts","messages":[{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'boundaries/element-types').","line":9,"column":1,"severity":1,"nodeType":null,"fix":{"range":[573,676],"text":" "}},{"ruleId":"import/no-unresolved","severity":2,"message":"Unable to resolve path to module '../../../../infrastructure/queue/drizzle/queue.service'.","line":10,"column":30,"nodeType":"Literal","endLine":10,"endColumn":86}],"suppressedMessages":[{"ruleId":"boundaries/element-types","severity":2,"message":"APPLICATION: Proibido importar de infrastructure (permitido: domain, shared).","line":6,"column":38,"nodeType":"Literal","endLine":6,"endColumn":113,"suppressions":[{"kind":"directive","justification":"Integration test needs access to infrastructure"}]},{"ruleId":"boundaries/element-types","severity":2,"message":"APPLICATION: Proibido importar de infrastructure (permitido: domain, shared).","line":8,"column":59,"nodeType":"Literal","endLine":8,"endColumn":126,"suppressions":[{"kind":"directive","justification":"Integration test needs access to infrastructure"}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { randomUUID } from 'node:crypto';\n\nimport { vi, describe, it, expect, beforeEach, afterEach, Mock } from 'vitest';\n\n// eslint-disable-next-line boundaries/element-types -- Integration test needs access to infrastructure\nimport { DrizzleJobRepository } from '../../../../infrastructure/persistence/drizzle/job/drizzle-job.repository';\n// eslint-disable-next-line boundaries/element-types -- Integration test needs access to infrastructure\nimport { TestDb, createTestDbClient, runMigrations } from '../../../../infrastructure/queue/drizzle/__tests__/test-db.helper';\n// eslint-disable-next-line boundaries/element-types -- Integration test needs access to infrastructure\nimport { QueueService } from '../../../../infrastructure/queue/drizzle/queue.service';\nimport { JobEntity } from '../../../domain/job/job.entity';\nimport { IJobOptions } from '../../../domain/job/value-objects/job-options.vo';\nimport { WorkerService } from '../worker.service';\n\nimport {\n  TestPayload, TestResult, QUEUE_NAME,\n  defaultWorkerOptions, defaultJobOptions\n} from './worker.service.spec.helper';\n\ndescribe('WorkerService - Lock Renewal', () => {\n  let db: TestDb;\n  let jobRepository: DrizzleJobRepository;\n  let queueService: QueueService<TestPayload, TestResult>;\n  let workerService: WorkerService<TestPayload, TestResult>;\n  let mockProcessor: Mock<[JobEntity<TestPayload, TestResult>], Promise<TestResult>>;\n\n  const addJobToQueue = async (name: string, payload: TestPayload, opts?: Partial<IJobOptions>) => {\n    const jobOptionsWithId = { ...defaultJobOptions, ...opts };\n    if (payload.id && !jobOptionsWithId.jobId) jobOptionsWithId.jobId = payload.id;\n    return queueService.add(name, payload, jobOptionsWithId);\n  };\n\n  beforeEach(async () => {\n    vi.useFakeTimers();\n    db = createTestDbClient({ memory: true });\n    await runMigrations(db);\n    jobRepository = new DrizzleJobRepository(db);\n    queueService = new QueueService<TestPayload, TestResult>(QUEUE_NAME, jobRepository, defaultJobOptions);\n    mockProcessor = vi.fn();\n    workerService = new WorkerService(queueService, mockProcessor, defaultWorkerOptions);\n  });\n\n  afterEach(async () => {\n    if (!workerService.isClosed) await workerService.close();\n    if (queueService) await queueService.close();\n    vi.clearAllMocks(); vi.restoreAllMocks(); vi.useRealTimers();\n    if (db && typeof db.close === 'function') db.close();\n  });\n\n  it('should renew lock periodically for an active job', async () => {\n    const jobPayload = { data: 'renew me', id: randomUUID() };\n    const addedJob = await addJobToQueue('lockrenew-job', jobPayload);\n    let jobProcessorPromiseResolve: (value: TestResult) => void;\n    const jobProcessingPromise = new Promise<TestResult>(resolve => { jobProcessorPromiseResolve = resolve; });\n    mockProcessor.mockImplementationOnce(() => jobProcessingPromise);\n    workerService.run();\n    await vi.advanceTimersByTimeAsync(defaultWorkerOptions.pollingIntervalMs! + 50);\n    const initialLockUntil = (await jobRepository.findById(addedJob.id))!.lockUntil;\n    await vi.advanceTimersByTimeAsync(defaultWorkerOptions.lockDuration! - defaultWorkerOptions.lockRenewTimeBuffer! + 100);\n    expect((await jobRepository.findById(addedJob.id))!.lockUntil!.getTime()).toBeGreaterThan(initialLockUntil!.getTime());\n    jobProcessorPromiseResolve!({ status: 'renewed_done', id: addedJob.payload.id });\n    await vi.advanceTimersByTimeAsync(defaultWorkerOptions.pollingIntervalMs! + 50);\n  });\n\n  it('should stop renewing lock if job finishes', async () => {\n    const jobPayload = { data: 'stop renew', id: randomUUID() };\n    const addedJob = await addJobToQueue('lockstop-job', jobPayload);\n    mockProcessor.mockResolvedValueOnce({ status: 'stopped_done', id: jobPayload.id });\n    workerService.run();\n    await vi.advanceTimersByTimeAsync(defaultWorkerOptions.pollingIntervalMs! + 50);\n    const lockUntilAtCompletion = (await jobRepository.findById(addedJob.id))!.lockUntil;\n    await vi.advanceTimersByTimeAsync(defaultWorkerOptions.lockDuration!);\n    const jobLater = await jobRepository.findById(addedJob.id);\n    if (lockUntilAtCompletion) expect(jobLater!.lockUntil!.getTime()).toEqual(lockUntilAtCompletion.getTime());\n    else expect(jobLater!.lockUntil).toBeNull();\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/worker/__tests__/worker.service.spec.helper.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/worker/worker.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/worker/worker.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/common/base.entity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/common/ports/repository.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/common/services/i-logger.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/common/value-objects/base.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/common/value-objects/identity.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/agent/agent-internal-state.entity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/agent/agent-persona-template.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/agent/agent.entity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/agent/ports/agent-internal-state-repository.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/agent/ports/agent-persona-template-repository.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/agent/ports/agent-repository.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/agent/value-objects/agent-id.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/agent/value-objects/agent-max-iterations.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/agent/value-objects/agent-temperature.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/agent/value-objects/internal-state/current-goal.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/agent/value-objects/internal-state/current-project-id.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/agent/value-objects/internal-state/general-notes.collection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/agent/value-objects/persona/persona-backstory.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/agent/value-objects/persona/persona-goal.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/agent/value-objects/persona/persona-id.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/agent/value-objects/persona/persona-name.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/agent/value-objects/persona/persona-role.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/agent/value-objects/persona/tool-names.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/agent/value-objects/target-agent-role.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/annotation/annotation.entity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/annotation/ports/annotation-repository.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/annotation/ports/annotation-repository.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/annotation/value-objects/annotation-id.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/annotation/value-objects/annotation-text.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/common/errors.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":14,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":14,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[464,467],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[464,467],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":16,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":16,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[590,593],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[590,593],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/job/__tests__/job-options.vo.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/job/__tests__/job.entity.serialization.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/job/__tests__/job.entity.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/job/__tests__/job.entity.state-transitions.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/job/job-persistence.mapper.ts","messages":[{"ruleId":"no-inline-comments","severity":2,"message":"Unexpected comment inline with code.","line":2,"column":47,"nodeType":"Line","messageId":"unexpectedInlineComment","endLine":2,"endColumn":117},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'JobStatus' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":30,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":39},{"ruleId":"no-inline-comments","severity":2,"message":"Unexpected comment inline with code.","line":3,"column":62,"nodeType":"Line","messageId":"unexpectedInlineComment","endLine":3,"endColumn":120},{"ruleId":"no-undef","severity":2,"message":"'JobEntity' is not defined.","line":15,"column":6,"nodeType":"Identifier","messageId":"undef","endLine":15,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'JobEntity' is not defined.","line":55,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":55,"endColumn":30},{"ruleId":"no-inline-comments","severity":2,"message":"Unexpected comment inline with code.","line":77,"column":47,"nodeType":"Line","messageId":"unexpectedInlineComment","endLine":77,"endColumn":61},{"ruleId":"no-inline-comments","severity":2,"message":"Unexpected comment inline with code.","line":78,"column":41,"nodeType":"Line","messageId":"unexpectedInlineComment","endLine":78,"endColumn":68},{"ruleId":"no-inline-comments","severity":2,"message":"Unexpected comment inline with code.","line":86,"column":45,"nodeType":"Line","messageId":"unexpectedInlineComment","endLine":86,"endColumn":66},{"ruleId":"no-inline-comments","severity":2,"message":"Unexpected comment inline with code.","line":87,"column":45,"nodeType":"Line","messageId":"unexpectedInlineComment","endLine":87,"endColumn":66}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src_refactored/core/domain/job/job-persistence.mapper.ts\nimport { JobEntityProps } from './job.types'; // JobEntity no longer needed directly, JobPersistenceData from .types\nimport { JobPersistenceData, JobStatus } from './job.types'; // Added JobStatus if needed, JobPersistenceData from here\nimport { ActivityHistoryVO } from './value-objects/activity-history.vo';\nimport { JobIdVO } from './value-objects/job-id.vo';\nimport { JobOptionsVO } from './value-objects/job-options.vo';\n// Assuming JobStateMutator is not directly used by the mapper, but by JobEntity internally\n// If JobStateMutator was needed here, its import would be:\n// import { JobStateMutator } from './job-state.mutator';\n\n\nexport class JobPersistenceMapper {\n  public static fromPersistence<P, R>(\n    data: JobPersistenceData<P, R>\n  ): JobEntity<P, R> {\n    const entityProps: JobEntityProps<P, R> = {\n      id: JobIdVO.create(data.id),\n      queueName: data.queueName,\n      name: data.name,\n      payload: data.payload,\n      options: JobOptionsVO.create(data.options),\n      status: data.status,\n      attemptsMade: data.attemptsMade,\n      progress: data.progress,\n      logs: (data.logs || []).map(log => ({\n        ...log,\n        timestamp: new Date(log.timestamp),\n      })),\n      createdAt: new Date(data.createdAt),\n      updatedAt: new Date(data.updatedAt),\n      processedOn: data.processedOn ? new Date(data.processedOn) : undefined,\n      finishedOn: data.finishedOn ? new Date(data.finishedOn) : undefined,\n      delayUntil: data.delayUntil ? new Date(data.delayUntil) : undefined,\n      lockUntil: data.lockUntil ? new Date(data.lockUntil) : undefined,\n      workerId: data.workerId ?? undefined,\n      returnValue: data.returnValue ?? undefined,\n      failedReason: data.failedReason ?? undefined,\n      stacktrace: data.stacktrace ?? undefined,\n    };\n\n    // This is the problematic part due to JobEntity's private constructor.\n    // A proper solution requires JobEntity to have a public static factory for reconstitution.\n    // For example: static reconstitute(props: JobEntityProps<P,R>, history: ActivityHistoryVO, execHistory: ExecutionHistoryEntry[])\n    // Then, this mapper would call:\n    // return JobEntity.reconstitute(entityProps, ActivityHistoryVO.create(), []);\n    //\n    // To satisfy ESLint for now, and acknowledging this is a structural issue\n    // that can't be fully resolved by only changing this mapper file without\n    // changing JobEntity's API (which is out of scope for a pure lint fix):\n    // We will use @ts-expect-error to acknowledge the type error for the private constructor.\n    // The 'any' casts for internal properties are still problematic but harder to avoid\n    // without a proper reconstitution method on JobEntity.\n\n    // @ts-expect-error Private constructor access is intentional here for the mapper.\n    const job = new JobEntity(entityProps, ActivityHistoryVO.create(), []);\n\n    // The following lines that manually set private members are highly discouraged\n    // and are a sign that the JobEntity needs a better way to be reconstituted.\n    // However, to remove the 'any' lint errors specifically on these lines *if* we were forced\n    // to keep this hacky approach, we'd need to cast `job` to `any` before accessing them.\n    // But the primary issue is the private constructor.\n    // (job as any)._conversationHistory = ActivityHistoryVO.create(); // Example of what NOT to do\n    // (job as any)._executionHistory = [];\n    // (job as any)._stateMutator = new JobStateMutator(entityProps);\n\n    return job;\n  }\n\n  public static toPersistence<P, R>(\n    props: JobEntityProps<P, R>\n  ): JobPersistenceData<P, R> {\n    return {\n      id: props.id.value,\n      queueName: props.queueName,\n      name: props.name,\n      payload: props.payload,\n      options: props.options.toPersistence(), // IJobOptions\n      priority: props.options.priority, // Added top-level priority\n      status: props.status,\n      attemptsMade: props.attemptsMade,\n      progress: props.progress,\n      logs: props.logs.map((logEntry) => ({\n        ...logEntry,\n        timestamp: logEntry.timestamp.getTime(),\n      })),\n      createdAt: props.createdAt.getTime(), // map Date to number\n      updatedAt: props.updatedAt.getTime(), // map Date to number\n      // priority is part of options, so props.options.priority is correct if toPersistence() on JobOptionsVO includes it.\n      // JobPersistenceData from job.entity.ts does not list priority, but DrizzleJobRepository uses it.\n      // This suggests JobPersistenceData might need an update or there's an intermediate type.\n      // For now, matching JobEntity's original toPersistence structure which returned it directly.\n      // However, JobPersistenceData as imported from job.entity.ts does *not* include priority.\n      // Let's assume options.toPersistence() handles priority correctly if it's part of IJobOptions.\n      // The original JobEntity.toPersistence() explicitly added `priority: this.props.options.priority`.\n      // This implies that `JobPersistenceData` type itself might be incomplete or used inconsistently.\n      // The `DrizzleJobRepository` uses `job.toPersistence()` which includes this priority.\n      // Let's stick to what JobEntity was doing for the direct return object structure for now.\n      // This part of the type definition might need revisiting across files.\n\n      processedOn: props.processedOn ? props.processedOn.getTime() : undefined,\n      finishedOn: props.finishedOn ? props.finishedOn.getTime() : undefined,\n      delayUntil: props.delayUntil ? props.delayUntil.getTime() : undefined,\n      lockUntil: props.lockUntil ? props.lockUntil.getTime() : undefined,\n      workerId: props.workerId ?? undefined,\n      returnValue: props.returnValue ?? undefined,\n      failedReason: props.failedReason ?? undefined,\n      stacktrace: props.stacktrace ?? undefined,\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/job/job-processing.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/job/job-state.mutator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/job/job.entity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/job/job.types.ts","messages":[{"ruleId":"no-inline-comments","severity":2,"message":"Unexpected comment inline with code.","line":46,"column":25,"nodeType":"Line","messageId":"unexpectedInlineComment","endLine":46,"endColumn":50},{"ruleId":"no-inline-comments","severity":2,"message":"Unexpected comment inline with code.","line":47,"column":21,"nodeType":"Line","messageId":"unexpectedInlineComment","endLine":47,"endColumn":100}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { JobIdVO } from \"./value-objects/job-id.vo\";\nimport { IJobOptions, JobOptionsVO } from \"./value-objects/job-options.vo\";\n\nexport enum JobStatus {\n  WAITING = \"waiting\",\n  ACTIVE = \"active\",\n  COMPLETED = \"completed\",\n  FAILED = \"failed\",\n  DELAYED = \"delayed\",\n  PAUSED = \"paused\",\n}\n\nexport interface JobLogEntry {\n  message: string;\n  level: string;\n  timestamp: Date;\n}\n\nexport interface JobEntityProps<P = unknown, R = unknown> {\n  id: JobIdVO;\n  queueName: string;\n  name: string;\n  payload: P;\n  options: JobOptionsVO;\n  status: JobStatus;\n  attemptsMade: number;\n  progress: number | object;\n  logs: JobLogEntry[];\n  createdAt: Date;\n  updatedAt: Date;\n  processedOn?: Date;\n  finishedOn?: Date;\n  delayUntil?: Date;\n  lockUntil?: Date;\n  workerId?: string;\n  returnValue?: R;\n  failedReason?: string;\n  stacktrace?: string[];\n}\n\nexport type JobPersistenceData<P = unknown, R = unknown> = {\n  id: string;\n  queueName: string;\n  name: string;\n  payload: P;\n  options: IJobOptions; // This includes priority\n  priority: number; // Explicitly adding for top-level access in persistence if needed by consumers\n  status: JobStatus;\n  attemptsMade: number;\n  progress: number | object;\n  logs: Array<{ message: string; level: string; timestamp: number }>;\n  createdAt: number;\n  updatedAt: number;\n  processedOn?: number | null;\n  finishedOn?: number | null;\n  delayUntil?: number | null;\n  lockUntil?: number | null;\n  workerId?: string | null;\n  returnValue?: R | null;\n  failedReason?: string | null;\n  stacktrace?: string[] | null;\n};\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/job/utils/calculate-backoff.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/job/value-objects/__tests__/job-id.vo.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/job/value-objects/__tests__/job-options.vo.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/job/value-objects/activity-history-entry.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/job/value-objects/activity-history.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/job/value-objects/job-id.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/job/value-objects/job-options.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/llm-provider-config/llm-provider-config.entity.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'id' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":45,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":45,"endColumn":15,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/llm-provider-config/ports/llm-provider-config-repository.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/llm-provider-config/value-objects/llm-api-key.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/llm-provider-config/value-objects/llm-provider-config-id.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/llm-provider-config/value-objects/llm-provider-config-name.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/llm-provider-config/value-objects/llm-provider-id.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/memory/memory-item.entity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/memory/ports/memory-repository.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/memory/ports/memory-repository.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/memory/value-objects/memory-item-content.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/memory/value-objects/memory-item-embedding.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/memory/value-objects/memory-item-id.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/memory/value-objects/memory-item-source.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/memory/value-objects/memory-item-tags.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/project/ports/project-repository.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/project/project.entity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/project/value-objects/project-description.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/project/value-objects/project-id.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/project/value-objects/project-name.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/source-code/ports/source-code-repository.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/source-code/source-code.entity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/source-code/value-objects/repository-docs-path.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/source-code/value-objects/repository-id.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/source-code/value-objects/repository-path.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/user/ports/user-repository.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/user/user.entity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/user/value-objects/user-avatar.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/user/value-objects/user-email.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/user/value-objects/user-id.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/user/value-objects/user-nickname.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/user/value-objects/user-username.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/ports/adapters/file-system.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/ports/adapters/job-queue.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/ports/adapters/llm-adapter.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/ports/adapters/llm-adapter.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/ports/adapters/version-control-system.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/tools/tool.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/examples/queue-usage-example.final.ts","messages":[{"ruleId":"import/no-unresolved","severity":2,"message":"Unable to resolve path to module '@/infrastructure/queue/drizzle/queue.service'.","line":7,"column":30,"nodeType":"Literal","endLine":7,"endColumn":76}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src_refactored/examples/queue-usage-example.final.ts\nimport { WorkerService } from \"@/core/application/worker/worker.service\";\nimport { JobEntity } from \"@/core/domain/job/job.entity\";\n\nimport { db } from \"@/infrastructure/persistence/drizzle/drizzle.client\";\nimport { DrizzleJobRepository } from \"@/infrastructure/persistence/drizzle/job/drizzle-job.repository\";\nimport { QueueService } from \"@/infrastructure/queue/drizzle/queue.service\";\n\ntype EmailJobPayload = { email: string };\ntype EmailJobResult = { status: string };\n\nfunction setupProcessor(): (\n  job: JobEntity<EmailJobPayload, EmailJobResult>\n) => Promise<EmailJobResult> {\n  return async (\n    job: JobEntity<EmailJobPayload, EmailJobResult>\n  ): Promise<EmailJobResult> => {\n    const props = job.getProps();\n    process.stdout.write(\n      `[Worker] Processing job ${props.id.value} (attempt ${props.attemptsMade}) for email: ${props.payload.email}\\n`\n    );\n\n    for (let progressValue = 0; progressValue <= 100; progressValue += 25) {\n      await new Promise((resolve) => setTimeout(resolve, 500));\n      job.updateProgress(progressValue);\n      job.addLog(`Progress updated to ${progressValue}%`);\n      process.stdout.write(\n        `[Worker] Job ${props.id.value} progress: ${progressValue}%\\n`\n      );\n    }\n\n    if (props.attemptsMade < 3 && props.payload.email === \"retry@example.com\") {\n      job.addLog(\"Simulating transient failure for retry job.\", \"ERROR\");\n      process.stdout.write(\n        `[Worker] Job ${props.id.value} (retry job) failed. Attempts made: ${props.attemptsMade}\\n`\n      );\n      throw new Error(\"Simulated transient error\");\n    }\n\n    if (props.payload.email === \"fail@example.com\") {\n      job.addLog(\"Simulating permanent failure.\", \"ERROR\");\n      process.stdout.write(\n        `[Worker] Job ${props.id.value} (fail job) failed permanently.\\n`\n      );\n      throw new Error(\"Simulated permanent error\");\n    }\n\n    job.addLog(\"Job completed successfully.\", \"INFO\");\n    process.stdout.write(\n      `[Worker] Job ${props.id.value} completed successfully.\\n`\n    );\n    return { status: \"Email sent\" };\n  };\n}\n\nfunction setupEventListeners(\n  queue: QueueService<EmailJobPayload, EmailJobResult>,\n  worker: WorkerService<EmailJobPayload, EmailJobResult>\n): void {\n  queue.on(\"job.added\", (job) =>\n    process.stdout.write(\n      `[Queue] Job added: ${job.getProps().id.value} (Name: ${job.getProps().name}, Status: ${job.getProps().status})\\n`\n    )\n  );\n  queue.on(\"job.completed\", (job) =>\n    process.stdout.write(\n      `[Queue] Job completed: ${job.getProps().id.value} (Result: ${JSON.stringify(job.getProps().returnValue)})\\n`\n    )\n  );\n  queue.on(\"job.failed\", (job) =>\n    process.stdout.write(\n      `[Queue] Job failed: ${job.getProps().id.value} (Reason: ${job.getProps().failedReason}, Attempts: ${job.getProps().attemptsMade})\\n`\n    )\n  );\n  // Condensing this handler to help with max-lines-per-function\n  queue.on(\"job.active\", (job) => process.stdout.write(`[Queue] Job ${job.getProps().id.value} is now active.\\n`));\n  queue.on(\"job.stalled\", (job) =>\n    process.stdout.write(`[Queue] Job ${job.getProps().id.value} stalled and re-queued.\\n`)\n  );\n  queue.on(\"job.progress\", (job) =>\n    process.stdout.write(\n      `[Queue] Job ${job.getProps().id.value} progress updated to ${job.getProps().progress}\\n`\n    )\n  );\n  queue.on(\"job.log\", (job) => {\n    const logs = job.getProps().logs;\n    process.stdout.write(\n      `[Queue] Job ${job.getProps().id.value} log: ${logs.length > 0 ? logs[logs.length - 1].message : \"N/A\"}\\n`\n    )\n  });\n\n  worker.on(\"worker.job.active\", (job) =>\n    process.stdout.write(\n      `[Worker] Worker started processing job: ${job.getProps().id.value}\\n`\n    )\n  );\n  worker.on(\"worker.job.processed\", (job) =>\n    process.stdout.write(\n      `[Worker] Worker finished processing job: ${job.getProps().id.value}\\n`\n    )\n  );\n  worker.on(\"worker.job.errored\", (job, error) =>\n    process.stdout.write(\n      `[Worker] Worker encountered error for job ${job.getProps().id.value}: ${error.message}\\n`\n    )\n  );\n}\n\nasync function addJobsAndRun(\n  queue: QueueService<EmailJobPayload, EmailJobResult>,\n  worker: WorkerService<EmailJobPayload, EmailJobResult>\n): Promise<void> {\n  await queue.add(\"send-email\", { email: \"success@example.com\" });\n  await queue.add(\n    \"send-email\",\n    { email: \"delayed@example.com\" },\n    { delay: 7000 }\n  );\n  await queue.add(\n    \"send-email\",\n    { email: \"retry@example.com\" },\n    { attempts: 3, backoff: { type: \"exponential\", delay: 1000 } }\n  );\n  await queue.add(\"send-email\", { email: \"fail@example.com\" }, { attempts: 1 });\n\n  worker.run();\n  queue.startMaintenance();\n\n  process.stdout.write(\n    \"Queue and Worker started. Waiting for jobs to complete...\\n\"\n  );\n\n  setTimeout(async () => {\n    process.stdout.write(\"Shutting down worker and queue...\\n\");\n    await worker.close();\n    await queue.close();\n    process.stdout.write(\"Worker and queue closed. Exiting.\\n\");\n    process.exit(0);\n    // Keep alive for 60 seconds\n  }, 60000);\n}\n\nasync function main() {\n  const jobRepository = new DrizzleJobRepository(db);\n  const queue = new QueueService<EmailJobPayload, EmailJobResult>(\n    \"default\",\n    jobRepository\n  );\n  const processor = setupProcessor();\n  const worker = new WorkerService(queue, processor, {\n    concurrency: 2,\n    lockDuration: 15000,\n    lockRenewTimeBuffer: 5000,\n  });\n\n  setupEventListeners(queue, worker);\n  await addJobsAndRun(queue, worker);\n}\n\nprocess.on(\"unhandledRejection\", (reason, promise) => {\n  console.error(\"Unhandled Rejection at:\", promise, \"reason:\", reason);\n  // Application specific logging, throwing an error, or other logic here\n});\n\nprocess.on(\"uncaughtException\", (error) => {\n  console.error(\"Uncaught Exception:\", error);\n  // Application specific logging, throwing an error, or other logic here\n  process.exit(1);\n});\n\nmain().catch((err) => {\n  console.error(\"Error in main execution:\", err);\n  process.exit(1);\n});\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/adapters/llm/mock-llm.adapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/ioc/inversify.config.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@/infrastructure/queue/drizzle/job-processing.service` import should occur before import of `@/infrastructure/queue/drizzle/queue-service-core`","line":18,"column":1,"nodeType":"ImportDeclaration","endLine":18,"endColumn":94,"fix":{"range":[502,682],"text":"import { JobProcessingService } from \"@/infrastructure/queue/drizzle/job-processing.service\";\nimport { QueueServiceCore } from \"@/infrastructure/queue/drizzle/queue-service-core\";\n"}},{"ruleId":"import/order","severity":1,"message":"`@/infrastructure/queue/drizzle/queue-maintenance.service` import should occur before import of `@/infrastructure/queue/drizzle/queue-service-core`","line":19,"column":1,"nodeType":"ImportDeclaration","endLine":19,"endColumn":100,"fix":{"range":[502,782],"text":"import { QueueMaintenanceService } from \"@/infrastructure/queue/drizzle/queue-maintenance.service\";\nimport { QueueServiceCore } from \"@/infrastructure/queue/drizzle/queue-service-core\";\nimport { JobProcessingService } from \"@/infrastructure/queue/drizzle/job-processing.service\";\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":20,"column":1,"nodeType":"ImportDeclaration","endLine":20,"endColumn":90,"fix":{"range":[871,871],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@/infrastructure/queue/drizzle/drizzle-queue.facade` import should occur before import of `@/infrastructure/queue/drizzle/queue-service-core`","line":20,"column":1,"nodeType":"ImportDeclaration","endLine":20,"endColumn":90,"fix":{"range":[502,872],"text":"import { DrizzleQueueFacade } from \"@/infrastructure/queue/drizzle/drizzle-queue.facade\";\nimport { QueueServiceCore } from \"@/infrastructure/queue/drizzle/queue-service-core\";\nimport { JobProcessingService } from \"@/infrastructure/queue/drizzle/job-processing.service\";\nimport { QueueMaintenanceService } from \"@/infrastructure/queue/drizzle/queue-maintenance.service\";\n"}},{"ruleId":"import/order","severity":1,"message":"`node:events` import should occur before import of `inversify`","line":21,"column":1,"nodeType":"ImportDeclaration","endLine":21,"endColumn":40,"fix":{"range":[28,939],"text":"import EventEmitter from 'node:events'; // Needed for new services\nimport { Container } from \"inversify\";\n\nimport {\n  IJobRepository,\n  JOB_REPOSITORY_TOKEN,\n} from \"@/core/application/ports/job-repository.interface\";\nimport {\n  AbstractQueue,\n  getQueueServiceToken,\n} from \"@/core/application/queue/abstract-queue\";\n\nimport { db } from \"@/infrastructure/persistence/drizzle/drizzle.client\";\nimport { DrizzleJobRepository } from \"@/infrastructure/persistence/drizzle/job/drizzle-job.repository\";\n// Old QueueService replaced by new classes\nimport { QueueServiceCore } from \"@/infrastructure/queue/drizzle/queue-service-core\";\nimport { JobProcessingService } from \"@/infrastructure/queue/drizzle/job-processing.service\";\nimport { QueueMaintenanceService } from \"@/infrastructure/queue/drizzle/queue-maintenance.service\";\nimport { DrizzleQueueFacade } from \"@/infrastructure/queue/drizzle/drizzle-queue.facade\";\n"}},{"ruleId":"no-inline-comments","severity":2,"message":"Unexpected comment inline with code.","line":21,"column":41,"nodeType":"Line","messageId":"unexpectedInlineComment","endLine":21,"endColumn":67},{"ruleId":"no-inline-comments","severity":2,"message":"Unexpected comment inline with code.","line":33,"column":34,"nodeType":"Line","messageId":"unexpectedInlineComment","endLine":33,"endColumn":82},{"ruleId":"no-inline-comments","severity":2,"message":"Unexpected comment inline with code.","line":84,"column":27,"nodeType":"Line","messageId":"unexpectedInlineComment","endLine":84,"endColumn":80},{"ruleId":"no-inline-comments","severity":2,"message":"Unexpected comment inline with code.","line":90,"column":27,"nodeType":"Line","messageId":"unexpectedInlineComment","endLine":90,"endColumn":80},{"ruleId":"no-inline-comments","severity":2,"message":"Unexpected comment inline with code.","line":103,"column":18,"nodeType":"Line","messageId":"unexpectedInlineComment","endLine":103,"endColumn":38}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":5,"source":"import \"reflect-metadata\";\n\nimport { Container } from \"inversify\";\n\nimport {\n  IJobRepository,\n  JOB_REPOSITORY_TOKEN,\n} from \"@/core/application/ports/job-repository.interface\";\nimport {\n  AbstractQueue,\n  getQueueServiceToken,\n} from \"@/core/application/queue/abstract-queue\";\n\nimport { db } from \"@/infrastructure/persistence/drizzle/drizzle.client\";\nimport { DrizzleJobRepository } from \"@/infrastructure/persistence/drizzle/job/drizzle-job.repository\";\n// Old QueueService replaced by new classes\nimport { QueueServiceCore } from \"@/infrastructure/queue/drizzle/queue-service-core\";\nimport { JobProcessingService } from \"@/infrastructure/queue/drizzle/job-processing.service\";\nimport { QueueMaintenanceService } from \"@/infrastructure/queue/drizzle/queue-maintenance.service\";\nimport { DrizzleQueueFacade } from \"@/infrastructure/queue/drizzle/drizzle-queue.facade\";\nimport EventEmitter from 'node:events'; // Needed for new services\n\nexport const appContainer = new Container();\n\n// Job Repository and Queue Service bindings\nappContainer\n  .bind<IJobRepository>(JOB_REPOSITORY_TOKEN)\n  .toConstantValue(new DrizzleJobRepository(db));\nappContainer\n  .bind<AbstractQueue<unknown, unknown>>(getQueueServiceToken(\"default\"))\n  .toDynamicValue((context) => {\n    const jobRepository = context.container.get<IJobRepository>(JOB_REPOSITORY_TOKEN);\n    const queueName = \"default\"; // Or derive from token if more queues are added\n\n    // Create a shared EventEmitter instance for this queue setup\n    // Or, if AbstractQueue (and thus Facade) is the primary emitter, pass `facade` itself if services need to emit through it.\n    // For now, let's assume services take a raw emitter they use, and the facade also uses one (its own, from AbstractQueue).\n    // This might need refinement based on how events are intended to propagate.\n    // If services emit their own events, and facade emits its own, they are separate.\n    // If facade is the *sole* emitter for AbstractQueue events, then services need a way to trigger those on the facade.\n\n    // Let's assume for now that the Facade itself (as an EventEmitter via AbstractQueue)\n    // is the one that should be used for emitting AbstractQueue defined events.\n    // The individual services might need to be passed a reference to the facade's emit method,\n    // or the facade calls their methods and then emits events.\n    // The current service implementations take an EventEmitter.\n    // We can create one here and pass to all three + Facade (if Facade didn't extend EventEmitter).\n    // Since Facade extends AbstractQueue which extends EventEmitter, it IS an emitter.\n\n    // Option: Instantiate services, then facade, then pass facade's emit to services.\n    // This creates a circular dependency if services need emit in constructor.\n    // Simpler: Services take a new emitter, facade also has its own. Events are distinct.\n    // Better: Facade is the event source. Services get jobRepo & queueName. Facade orchestrates & emits.\n\n    const coreService = new QueueServiceCore(\n      queueName,\n      jobRepository\n      // defaultJobOptions can be undefined or fetched from config\n    );\n\n    // The eventEmitter for JobProcessingService and QueueMaintenanceService:\n    // For now, these services were designed to take a generic EventEmitter.\n    // The DrizzleQueueFacade itself is an EventEmitter (via AbstractQueue).\n    // The most straightforward way is to pass the Facade's `this` (as an emitter)\n    // to the services if they need to emit events that AbstractQueue would define.\n    // However, their current constructors take a raw EventEmitter.\n    // Let's create a single emitter for them for now.\n    // A more advanced setup might involve the facade passing its own `emit` method bound.\n\n    // The facade will extend AbstractQueue, which extends EventEmitter.\n    // So, the facade itself is an EventEmitter.\n    // The sub-services (core, processing, maintenance) also need to emit events.\n    // Option 1: They all share the Facade's emitter (this).\n    // Option 2: They have their own, and the Facade subscribes or is not involved in their internal events.\n    // Option 3: The Facade calls their methods, and then the Facade emits the events as per AbstractQueue contract. (Chosen for now)\n\n    // Therefore, sub-services don't necessarily need an emitter in their constructor for *AbstractQueue* events.\n    // They were written to take one for their own internal/specific events.\n    // Let's assume they manage their own specific events or don't emit AbstractQueue events directly.\n    // The Facade will be responsible for emitting events defined by AbstractQueue.\n\n    const processingService = new JobProcessingService(\n      jobRepository,\n      new EventEmitter(), // Placeholder, facade will emit AbstractQueue events\n      queueName\n    );\n\n    const maintenanceService = new QueueMaintenanceService(\n      jobRepository,\n      new EventEmitter(), // Placeholder, facade will emit AbstractQueue events\n      queueName\n    );\n\n    // The QueueServiceCore needs to be told about the maintenance service for its close() method.\n    // This was part of its original design.\n    // However, the Facade's close() will now coordinate this.\n    // So QueueServiceCore's constructor was simplified.\n    // The Facade's constructor now takes all three.\n\n    const facade = new DrizzleQueueFacade(\n      queueName,\n      jobRepository,\n      undefined, // defaultJobOptions\n      coreService,\n      processingService,\n      maintenanceService\n    );\n\n    // If QueueServiceCore needs to call stopMaintenance, it needs a reference.\n    // The current QueueServiceCore has `setMaintenanceService`. The Facade could call this.\n    // (coreService as any).setMaintenanceService(maintenanceService); // Hacky, better if Facade handles it.\n    // The Facade's close() now calls maintenanceService.stopMaintenance(), so coreService doesn't need it.\n\n    return facade;\n  })\n  .inSingletonScope();\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/ioc/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/persistence/drizzle/drizzle.client.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/persistence/drizzle/job/__tests__/drizzle-job.repository.clean.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/persistence/drizzle/job/__tests__/drizzle-job.repository.countByStatus.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/persistence/drizzle/job/__tests__/drizzle-job.repository.findNextJobs.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/persistence/drizzle/job/__tests__/drizzle-job.repository.getByStatus.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/persistence/drizzle/job/__tests__/drizzle-job.repository.locking.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/persistence/drizzle/job/__tests__/drizzle-job.repository.remove.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/persistence/drizzle/job/__tests__/drizzle-job.repository.save-findById.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/persistence/drizzle/job/__tests__/drizzle-job.repository.stalled.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/persistence/drizzle/job/__tests__/drizzle-job.repository.update.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/persistence/drizzle/job/drizzle-job.mapper.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/persistence/drizzle/job/drizzle-job.repository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/persistence/drizzle/repositories/project.repository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/persistence/drizzle/schema/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/persistence/drizzle/schema/jobs.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/persistence/drizzle/test-db.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/persistence/in-memory/repositories/agent-internal-state.repository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/persistence/in-memory/repositories/agent-persona-template.repository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/persistence/in-memory/repositories/agent.repository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/persistence/in-memory/repositories/annotation.repository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/persistence/in-memory/repositories/llm-provider-config.repository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/persistence/in-memory/repositories/memory.repository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/persistence/in-memory/repositories/project.repository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/persistence/in-memory/repositories/source-code.repository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/persistence/in-memory/repositories/user.repository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/queue/drizzle/__tests__/queue.service-add.spec.ts","messages":[{"ruleId":"import/no-unresolved","severity":2,"message":"Unable to resolve path to module '../queue.service'.","line":18,"column":30,"nodeType":"Literal","endLine":18,"endColumn":48}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src_refactored/infrastructure/queue/drizzle/__tests__/queue.service-add.spec.ts\nimport { randomUUID } from \"node:crypto\";\n\nimport {\n  vi,\n  describe,\n  it,\n  expect,\n  beforeEach,\n  beforeAll,\n  afterEach,\n} from \"vitest\";\n\n// Newline for import group separation\nimport { JobEntity, JobStatus } from \"../../../../core/domain/job/job.entity\";\nimport { IJobOptions } from \"../../../../core/domain/job/value-objects/job-options.vo\"; // Corrected: Use as value\nimport { DrizzleJobRepository } from \"../../../persistence/drizzle/job/drizzle-job.repository\";\nimport { QueueService } from \"../queue.service\";\n// import { JobIdVO } from \"../../../../core/domain/job/value-objects/job-id.vo\"; // Not directly used in this snippet, but likely needed\n\n// Newline for import group separation\nimport {\n  TestDb,\n  createTestDbClient,\n  runMigrations,\n  clearDatabaseTables,\n} from \"./test-db.helper\";\n\n// Top-level variables for test context\nlet db: TestDb;\nlet jobRepository: DrizzleJobRepository;\nlet queueService: QueueService<{ email: string }, { status: string }>;\nconst queueName = \"test-email-queue\";\nconst defaultJobOpts: IJobOptions = {\n  attempts: 1,\n  delay: 0,\n  priority: 0,\n  removeOnComplete: false,\n  removeOnFail: false,\n  maxStalledCount: 3,\n};\n\nbeforeAll(async () => {\n  db = createTestDbClient({ memory: true });\n  await runMigrations(db);\n});\n\nbeforeEach(async () => {\n  vi.clearAllMocks();\n  await clearDatabaseTables(db);\n\n  jobRepository = new DrizzleJobRepository(db);\n  queueService = new QueueService(queueName, jobRepository, defaultJobOpts);\n  vi.spyOn(queueService, \"emit\");\n});\n\nafterEach(async () => {\n  if (queueService) {\n    await queueService.close();\n  }\n  vi.restoreAllMocks();\n});\n\ndescribe(\"QueueService - add\", () => {\n  it(\"should create a job, save it to DB, and emit job.added event\", async () => {\n    const jobData = { email: \"test@example.com\" };\n    const jobName = \"send-welcome-email\";\n\n    const createdJob = await queueService.add(jobName, jobData);\n    const createdJobProps = createdJob.getProps();\n\n    expect(createdJob).toBeInstanceOf(JobEntity);\n    expect(createdJobProps.name).toBe(jobName);\n    expect(createdJobProps.payload).toEqual(jobData);\n    expect(createdJobProps.queueName).toBe(queueName);\n    expect(createdJobProps.options.attempts).toBe(defaultJobOpts.attempts);\n    expect(queueService.emit).toHaveBeenCalledWith(\"job.added\", createdJob);\n\n    // Verify job is in the database\n    const jobFromDb = await jobRepository.findById(createdJobProps.id);\n    expect(jobFromDb).not.toBeNull();\n    const jobFromDbProps = jobFromDb!.getProps();\n    expect(jobFromDbProps.id.value).toBe(createdJobProps.id.value);\n    expect(jobFromDbProps.name).toBe(jobName);\n    expect(jobFromDbProps.payload).toEqual(jobData);\n  });\n\n  it(\"should apply custom options when adding a job, and save to DB\", async () => {\n    const jobData = { email: \"custom@example.com\" };\n    const jobName = \"custom-options-job\";\n    const validCustomJobId = randomUUID();\n    const customOpts: IJobOptions = {\n      attempts: 5,\n      delay: 5000,\n      priority: 1,\n      jobId: validCustomJobId,\n    };\n\n    const createdJob = await queueService.add(jobName, jobData, customOpts);\n    const createdJobProps = createdJob.getProps();\n\n    expect(createdJobProps.id.value).toBe(validCustomJobId);\n    expect(createdJobProps.options.attempts).toBe(5);\n    expect(createdJobProps.options.delay).toBe(5000);\n    expect(createdJobProps.options.priority).toBe(1);\n    expect(createdJobProps.status).toBe(JobStatus.DELAYED);\n\n    const jobFromDb = await jobRepository.findById(createdJobProps.id);\n    expect(jobFromDb).not.toBeNull();\n    const jobFromDbProps = jobFromDb!.getProps();\n    expect(jobFromDbProps.id.value).toBe(validCustomJobId);\n    expect(jobFromDbProps.options.priority).toBe(1);\n  });\n});\n\ndescribe(\"QueueService - addBulk\", () => {\n  it(\"should add multiple jobs to DB, and emit events\", async () => {\n    const jobsToAdd = [\n      { name: \"bulk1\", data: { email: \"b1@example.com\" } },\n      {\n        name: \"bulk2\",\n        data: { email: \"b2@example.com\" },\n        opts: { priority: 1 },\n      },\n    ];\n\n    const addedJobs = await queueService.addBulk(jobsToAdd);\n\n    expect(addedJobs.length).toBe(2);\n    expect(queueService.emit).toHaveBeenCalledTimes(2);\n\n    const job1FromDb = await jobRepository.findById(addedJobs[0].getProps().id);\n    expect(job1FromDb).not.toBeNull();\n    const job1FromDbProps = job1FromDb!.getProps();\n    expect(job1FromDbProps.name).toBe(\"bulk1\");\n    expect(job1FromDbProps.payload).toEqual({ email: \"b1@example.com\" });\n    expect(queueService.emit).toHaveBeenCalledWith(\"job.added\", addedJobs[0]);\n\n    const job2FromDb = await jobRepository.findById(addedJobs[1].getProps().id);\n    expect(job2FromDb).not.toBeNull();\n    const job2FromDbProps = job2FromDb!.getProps();\n    expect(job2FromDbProps.name).toBe(\"bulk2\");\n    expect(job2FromDbProps.options.priority).toBe(1);\n    expect(queueService.emit).toHaveBeenCalledWith(\"job.added\", addedJobs[1]);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/queue/drizzle/__tests__/queue.service-admin.spec.ts","messages":[{"ruleId":"import/no-unresolved","severity":2,"message":"Unable to resolve path to module '../queue.service'.","line":16,"column":30,"nodeType":"Literal","endLine":16,"endColumn":48}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src_refactored/infrastructure/queue/drizzle/__tests__/queue.service-admin.spec.ts\nimport {\n  vi,\n  describe,\n  it,\n  expect,\n  beforeEach,\n  beforeAll,\n  afterEach,\n} from \"vitest\";\n\nimport { JobStatus } from \"../../../../core/domain/job/job.entity\"; // JobEntity itself might not be needed directly\nimport { JobIdVO } from \"../../../../core/domain/job/value-objects/job-id.vo\"; // Needed for creating jobs for getJobsByStatus\nimport { IJobOptions } from \"../../../../core/domain/job/value-objects/job-options.vo\";\nimport { DrizzleJobRepository } from \"../../../persistence/drizzle/job/drizzle-job.repository\";\nimport { QueueService } from \"../queue.service\";\n\nimport {\n  TestDb,\n  createTestDbClient,\n  runMigrations,\n  clearDatabaseTables,\n} from \"./test-db.helper\";\n\n// Top-level variables for test context\nlet db: TestDb;\nlet jobRepository: DrizzleJobRepository;\nlet queueService: QueueService<{ email: string }, { status: string }>;\nconst queueName = \"test-email-queue\";\nconst defaultJobOpts: IJobOptions = {\n  attempts: 1,\n  delay: 0,\n  priority: 0,\n  removeOnComplete: false,\n  removeOnFail: false,\n  maxStalledCount: 3,\n};\n\nbeforeAll(async () => {\n  db = createTestDbClient({ memory: true });\n  await runMigrations(db);\n});\n\nbeforeEach(async () => {\n  vi.clearAllMocks();\n  await clearDatabaseTables(db);\n\n  jobRepository = new DrizzleJobRepository(db);\n  queueService = new QueueService(queueName, jobRepository, defaultJobOpts);\n  vi.spyOn(queueService, \"emit\");\n});\n\nafterEach(async () => {\n  if (queueService) {\n    await queueService.close();\n  }\n  vi.restoreAllMocks();\n});\n\ndescribe(\"QueueService - pause\", () => {\n  it(\"should emit queue.paused event\", async () => {\n    await queueService.pause();\n    expect(queueService.emit).toHaveBeenCalledWith(\"queue.paused\");\n  });\n});\n\ndescribe(\"QueueService - resume\", () => {\n  it(\"should emit queue.resumed event\", async () => {\n    await queueService.resume();\n    expect(queueService.emit).toHaveBeenCalledWith(\"queue.resumed\");\n  });\n});\n\ndescribe(\"QueueService - countJobsByStatus\", () => {\n  it(\"should call jobRepository.countJobsByStatus and return the counts\", async () => {\n    await queueService.add(\"w1\", { email: \"w1@w.c\" });\n    await queueService.add(\"w2\", { email: \"w2@w.c\" });\n    const _jf = await queueService.add(\n      \"f1\",\n      { email: \"f1@f.c\" },\n      { attempts: 1 }\n    );\n    const activeJf = await queueService.fetchNextJobAndLock(\"w\", 1); // Lock the job to make it active potentially\n    if (activeJf) { // Ensure job was fetched before trying to fail it\n        await queueService.markJobAsFailed(activeJf.id, \"w\", new Error(\"fail\"));\n    }\n\n\n    const statuses = [JobStatus.WAITING, JobStatus.FAILED];\n    const counts = await queueService.countJobsByStatus(statuses);\n\n    expect(counts[JobStatus.WAITING]).toBe(2);\n    // If activeJf was successfully fetched and failed\n    if (activeJf) {\n        expect(counts[JobStatus.FAILED]).toBe(1);\n    } else {\n        // If activeJf was null (e.g. another test run interfered or timing)\n        // This part of the assertion might be flaky if activeJf is not guaranteed.\n        // Consider what the count should be if the job wasn't processed.\n        expect(counts[JobStatus.FAILED]).toBeUndefined(); // Or 0, depending on desired behavior if no failed jobs\n    }\n  });\n});\n\ndescribe(\"QueueService - getJobsByStatus\", () => {\n  it(\"should call jobRepository.getJobsByStatus and return mapped jobs\", async () => {\n    const jc1 = await queueService.add(\"jc1\", { email: \"jc1@c.c\" }, {jobId: JobIdVO.create().value});\n    const activeJc1 = await queueService.fetchNextJobAndLock(\"w\", 1);\n    if (activeJc1) {\n        await queueService.markJobAsCompleted(activeJc1.id, \"w\", {\n            status: \"ok\",\n        });\n    }\n\n\n    const jc2 = await queueService.add(\"jc2\", { email: \"jc2@c.c\" }, {jobId: JobIdVO.create().value});\n    const activeJc2 = await queueService.fetchNextJobAndLock(\"w\", 1);\n    if (activeJc2) {\n        await queueService.markJobAsCompleted(activeJc2.id, \"w\", {\n            status: \"ok\",\n        });\n    }\n\n\n    const statuses = [JobStatus.COMPLETED];\n    const result = await queueService.getJobsByStatus(statuses, 0, 10, true);\n\n    // Depending on whether jobs were successfully completed\n    const expectedCompletedCount = (activeJc1 ? 1 : 0) + (activeJc2 ? 1 : 0);\n    expect(result.length).toBe(expectedCompletedCount);\n\n    if (activeJc1 && result.some(job => job.id.equals(jc1.id))) {\n      expect(result.find(job => job.id.equals(jc1.id))!.status).toBe(JobStatus.COMPLETED);\n    }\n    if (activeJc2 && result.some(job => job.id.equals(jc2.id))) {\n      expect(result.find(job => job.id.equals(jc2.id))!.status).toBe(JobStatus.COMPLETED);\n    }\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/queue/drizzle/__tests__/queue.service-get.spec.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'JobEntity' is defined but never used. Allowed unused vars must match /^_/u.","line":12,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":19},{"ruleId":"import/no-unresolved","severity":2,"message":"Unable to resolve path to module '../queue.service'.","line":15,"column":30,"nodeType":"Literal","endLine":15,"endColumn":48}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src_refactored/infrastructure/queue/drizzle/__tests__/queue.service-get.spec.ts\nimport {\n  vi,\n  describe,\n  it,\n  expect,\n  beforeEach,\n  beforeAll,\n  afterEach,\n} from \"vitest\";\n\nimport { JobEntity } from \"../../../../core/domain/job/job.entity\";\nimport { type IJobOptions } from \"../../../../core/domain/job/value-objects/job-options.vo\";\nimport { DrizzleJobRepository } from \"../../../persistence/drizzle/job/drizzle-job.repository\";\nimport { QueueService } from \"../queue.service\";\n// import { JobIdVO } from \"../../../../core/domain/job/value-objects/job-id.vo\"; // Not directly used here but JobEntity uses it\n\nimport {\n  TestDb,\n  createTestDbClient,\n  runMigrations,\n  clearDatabaseTables,\n} from \"./test-db.helper\";\n\n// Top-level variables for test context\nlet db: TestDb;\nlet jobRepository: DrizzleJobRepository;\nlet queueService: QueueService<{ email: string }, { status: string }>;\nconst queueName = \"test-email-queue\";\nconst defaultJobOpts: IJobOptions = {\n  attempts: 1,\n  delay: 0,\n  priority: 0,\n  removeOnComplete: false,\n  removeOnFail: false,\n  maxStalledCount: 3,\n};\n\nbeforeAll(async () => {\n  db = createTestDbClient({ memory: true });\n  await runMigrations(db);\n});\n\nbeforeEach(async () => {\n  vi.clearAllMocks();\n  await clearDatabaseTables(db);\n\n  jobRepository = new DrizzleJobRepository(db);\n  queueService = new QueueService(queueName, jobRepository, defaultJobOpts);\n  vi.spyOn(queueService, \"emit\");\n});\n\nafterEach(async () => {\n  if (queueService) {\n    await queueService.close();\n  }\n  vi.restoreAllMocks();\n});\n\ndescribe(\"QueueService - getJob\", () => {\n  it(\"should retrieve a job from DB by JobIdVO\", async () => {\n    const jobData = { email: \"find@me.com\" };\n    const jobName = \"find-me\";\n    // Need to add a job first to get it\n    const addedJob = await queueService.add(jobName, jobData);\n    const foundJob = await queueService.getJob(addedJob.getProps().id);\n\n    expect(foundJob).not.toBeNull();\n    expect(foundJob!.getProps().id.value).toBe(addedJob.getProps().id.value);\n    expect(foundJob!.getProps().name).toBe(jobName);\n  });\n\n  it(\"should retrieve a job from DB by string ID\", async () => {\n    const jobData = { email: \"find@me-str.com\" };\n    const jobName = \"find-me-str\";\n    // Need to add a job first to get it\n    const addedJob = await queueService.add(jobName, jobData);\n    const foundJob = await queueService.getJob(addedJob.getProps().id.value);\n\n    expect(foundJob).not.toBeNull();\n    expect(foundJob!.getProps().id.value).toBe(addedJob.getProps().id.value);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/queue/drizzle/__tests__/queue.service-maintenance.spec.ts","messages":[{"ruleId":"import/no-unresolved","severity":2,"message":"Unable to resolve path to module '../queue.service'.","line":16,"column":30,"nodeType":"Literal","endLine":16,"endColumn":48}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src_refactored/infrastructure/queue/drizzle/__tests__/queue.service-maintenance.spec.ts\nimport {\n  vi,\n  describe,\n  it,\n  expect,\n  beforeEach,\n  beforeAll,\n  afterEach,\n} from \"vitest\";\n\nimport { JobEntity, JobStatus } from \"../../../../core/domain/job/job.entity\";\nimport { JobIdVO } from \"../../../../core/domain/job/value-objects/job-id.vo\";\nimport { IJobOptions } from \"../../../../core/domain/job/value-objects/job-options.vo\";\nimport { DrizzleJobRepository } from \"../../../persistence/drizzle/job/drizzle-job.repository\";\nimport { QueueService } from \"../queue.service\";\n\nimport {\n  TestDb,\n  createTestDbClient,\n  runMigrations,\n  clearDatabaseTables,\n} from \"./test-db.helper\";\n\n// Top-level variables for test context\nlet db: TestDb;\nlet jobRepository: DrizzleJobRepository;\nlet queueService: QueueService<{ email: string }, { status: string }>;\nconst queueName = \"test-email-queue\";\nconst defaultJobOpts: IJobOptions = {\n  attempts: 1,\n  delay: 0,\n  priority: 0,\n  removeOnComplete: false,\n  removeOnFail: false,\n  maxStalledCount: 3,\n};\n\nbeforeAll(async () => {\n  db = createTestDbClient({ memory: true });\n  await runMigrations(db);\n});\n\nbeforeEach(async () => {\n  vi.clearAllMocks();\n  await clearDatabaseTables(db);\n\n  jobRepository = new DrizzleJobRepository(db);\n  queueService = new QueueService(queueName, jobRepository, defaultJobOpts);\n  vi.spyOn(queueService, \"emit\");\n});\n\nafterEach(async () => {\n  if (queueService) {\n    await queueService.close();\n  }\n  vi.restoreAllMocks();\n});\n\ndescribe(\"QueueService - startMaintenance (Stalled Jobs)\", () => {\n  beforeEach(() => {\n    vi.useFakeTimers();\n  });\n  afterEach(async () => {\n    // Ensure maintenance is stopped and timers are cleared for other test files\n    if (queueService && queueService[\"maintenanceTimer\"]) {\n      await queueService.stopMaintenance();\n    }\n    await vi.runAllTimersAsync(); // Process any remaining timers\n    vi.useRealTimers();\n  });\n\n  it(\"should periodically check for stalled jobs in DB and handle them\", async () => {\n    const stalledJob1Id = JobIdVO.create();\n    let job1 = JobEntity.create({\n      queueName,\n      name: \"stalled1\",\n      payload: { email: \"s1@ex.com\" },\n      options: { attempts: 1, jobId: stalledJob1Id.value },\n    });\n    // Manually set job as active and stalled\n    job1.props.status = JobStatus.ACTIVE;\n    job1.props.workerId = \"stalled-worker\";\n    job1.props.lockUntil = new Date(Date.now() - 100000); // Lock expired\n    job1.props.processedOn = new Date(Date.now() - 100001);\n    job1.props.attemptsMade = 1; // Already attempted once\n    await jobRepository.save(job1);\n\n    const stalledJob2Id = JobIdVO.create();\n    let job2 = JobEntity.create({\n      queueName,\n      name: \"stalled2\",\n      payload: { email: \"s2@ex.com\" },\n      options: { attempts: 2, jobId: stalledJob2Id.value }, // Allows for one retry\n    });\n    job2.props.status = JobStatus.ACTIVE;\n    job2.props.workerId = \"stalled-worker-2\";\n    job2.props.lockUntil = new Date(Date.now() - 100000); // Lock expired\n    job2.props.processedOn = new Date(Date.now() - 100001);\n    job2.props.attemptsMade = 1; // First attempt processed, now stalled\n    await jobRepository.save(job2);\n\n    queueService.startMaintenance();\n\n    // Allow the first maintenance run\n    await vi.advanceTimersByTimeAsync(1); // Ensure current tasks complete\n    await vi.advanceTimersByTimeAsync(queueService[\"maintenanceIntervalMs\"]);\n\n    const job1AfterStall = await jobRepository.findById(stalledJob1Id);\n    expect(job1AfterStall!.status).toBe(JobStatus.FAILED); // No more attempts\n    expect(job1AfterStall!.failedReason).toContain(\"Stalled\");\n\n    const job2AfterStall = await jobRepository.findById(stalledJob2Id);\n    expect(job2AfterStall!.status).toBe(JobStatus.WAITING); // Should be re-queued\n    expect(job2AfterStall!.stalledCount).toBe(1);\n    expect(job2AfterStall!.workerId).toBeNull(); // Lock should be cleared\n\n    const findStalledJobsSpy = vi.spyOn(jobRepository, \"findStalledJobs\");\n    // Advance to next interval\n    await vi.advanceTimersByTimeAsync(queueService[\"maintenanceIntervalMs\"] + 1);\n    expect(findStalledJobsSpy).toHaveBeenCalledTimes(1); // Should have run again\n\n    // Cleanup for this specific test block\n    await queueService.stopMaintenance();\n    await vi.runAllTimersAsync();\n    findStalledJobsSpy.mockRestore();\n  });\n});\n\ndescribe(\"QueueService - clean\", () => {\n  it(\"should call jobRepository.clean and return the count\", async () => {\n    const gracePeriodMs = 60000;\n    const limit = 10;\n    const status = JobStatus.COMPLETED;\n\n    // Add a job that will be completed and become old\n    const jobToCleanId = JobIdVO.create();\n    await queueService.add(\"job-to-clean\", { email: \"clean@example.com\" }, { jobId: jobToCleanId.value });\n    const fetchedJob = await queueService.fetchNextJobAndLock(\"worker-clean\", 1000);\n    expect(fetchedJob).not.toBeNull();\n    expect(fetchedJob!.id.value).toBe(jobToCleanId.value);\n\n    // Mark as completed\n    await queueService.markJobAsCompleted(fetchedJob!.id, \"worker-clean\", { status: \"done\" });\n\n    // Manually update its finishedOn to be in the past, beyond grace period\n    const jobEntity = await jobRepository.findById(fetchedJob!.id);\n    expect(jobEntity).not.toBeNull();\n    jobEntity!.props.finishedOn = new Date(Date.now() - gracePeriodMs * 2);\n    await jobRepository.update(jobEntity!); // Use repository's update which handles date conversion\n\n    const cleanedCount = await queueService.clean(gracePeriodMs, limit, status);\n    expect(cleanedCount).toBe(1);\n\n    const jobAfterClean = await jobRepository.findById(fetchedJob!.id);\n    expect(jobAfterClean).toBeNull();\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/queue/drizzle/__tests__/queue.service-updates.spec.ts","messages":[{"ruleId":"import/no-unresolved","severity":2,"message":"Unable to resolve path to module '../queue.service'.","line":15,"column":30,"nodeType":"Literal","endLine":15,"endColumn":48}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src_refactored/infrastructure/queue/drizzle/__tests__/queue.service-updates.spec.ts\nimport {\n  vi,\n  describe,\n  it,\n  expect,\n  beforeEach,\n  beforeAll,\n  afterEach,\n} from \"vitest\";\n\nimport { JobIdVO } from \"../../../../core/domain/job/value-objects/job-id.vo\";\nimport { IJobOptions } from \"../../../../core/domain/job/value-objects/job-options.vo\";\nimport { DrizzleJobRepository } from \"../../../persistence/drizzle/job/drizzle-job.repository\";\nimport { QueueService } from \"../queue.service\";\n// import { JobEntity } from \"../../../../core/domain/job/job.entity\"; // Might be needed for some expect.objectContaining\n\nimport {\n  TestDb,\n  createTestDbClient,\n  runMigrations,\n  clearDatabaseTables,\n} from \"./test-db.helper\";\n\n// Top-level variables for test context\nlet db: TestDb;\nlet jobRepository: DrizzleJobRepository;\nlet queueService: QueueService<{ email: string }, { status: string }>;\nconst queueName = \"test-email-queue\";\nconst defaultJobOpts: IJobOptions = {\n  attempts: 1,\n  delay: 0,\n  priority: 0,\n  removeOnComplete: false,\n  removeOnFail: false,\n  maxStalledCount: 3,\n};\n\nbeforeAll(async () => {\n  db = createTestDbClient({ memory: true });\n  await runMigrations(db);\n});\n\nbeforeEach(async () => {\n  vi.clearAllMocks();\n  await clearDatabaseTables(db);\n\n  jobRepository = new DrizzleJobRepository(db);\n  queueService = new QueueService(queueName, jobRepository, defaultJobOpts);\n  vi.spyOn(queueService, \"emit\");\n});\n\nafterEach(async () => {\n  if (queueService) {\n    await queueService.close();\n  }\n  vi.restoreAllMocks();\n});\n\ndescribe(\"QueueService - updateJobProgress\", () => {\n  let jobId: JobIdVO;\n  const workerId = \"worker-progress\";\n\n  beforeEach(async () => {\n    jobId = JobIdVO.create();\n    await queueService.add(\n      \"progress-me\",\n      { email: \"progress@example.com\" },\n      { jobId: jobId.value }\n    );\n    const activeJob = await queueService.fetchNextJobAndLock(workerId, 10000);\n    if (!activeJob || activeJob.id.value !== jobId.value)\n      throw new Error(\"Setup failed for updateJobProgress\");\n  });\n\n  it(\"should update progress in DB, and emit event\", async () => {\n    await queueService.updateJobProgress(jobId, workerId, 50);\n    let jobFromDb = await jobRepository.findById(jobId);\n    expect(jobFromDb!.progress).toBe(50);\n    expect(queueService.emit).toHaveBeenCalledWith(\n      \"job.progress\",\n      expect.objectContaining({ id: jobId, progress: 50 })\n    );\n\n    await queueService.updateJobProgress(jobId, workerId, {\n      stage: \"processing\",\n    });\n    jobFromDb = await jobRepository.findById(jobId);\n    expect(jobFromDb!.progress).toEqual({ stage: \"processing\" });\n    expect(queueService.emit).toHaveBeenCalledWith(\n      \"job.progress\",\n      expect.objectContaining({\n        id: jobId,\n        progress: { stage: \"processing\" },\n      })\n    );\n  });\n\n  it(\"should not update progress if job not found or worker mismatch\", async () => {\n    const nonExistentJobId = JobIdVO.create();\n    await queueService.updateJobProgress(nonExistentJobId, workerId, 75);\n    // Check that no emit happened for nonExistentJobId for progress\n    expect(queueService.emit).not.toHaveBeenCalledWith(\n      \"job.progress\",\n      expect.objectContaining({ id: nonExistentJobId })\n    );\n\n\n    await queueService.updateJobProgress(jobId, \"other-worker\", 75);\n    const jobFromDb = await jobRepository.findById(jobId);\n    expect(jobFromDb!.progress).not.toBe(75); // Progress should remain as it was\n  });\n});\n\ndescribe(\"QueueService - addJobLog\", () => {\n  let jobId: JobIdVO;\n  const workerId = \"worker-log\";\n\n  beforeEach(async () => {\n    jobId = JobIdVO.create();\n    await queueService.add(\n      \"log-me\",\n      { email: \"log@example.com\" },\n      { jobId: jobId.value }\n    );\n    const activeJob = await queueService.fetchNextJobAndLock(workerId, 10000);\n    if (!activeJob || activeJob.id.value !== jobId.value)\n      throw new Error(\"Setup failed for addJobLog\");\n  });\n\n  it(\"should add log to DB, and emit event\", async () => {\n    const message = \"Test log message\";\n    const level = \"DEBUG\";\n    await queueService.addJobLog(jobId, workerId, message, level);\n\n    const jobFromDb = await jobRepository.findById(jobId);\n    expect(jobFromDb!.logs.length).toBe(1);\n    expect(jobFromDb!.logs[0].message).toBe(message);\n    expect(jobFromDb!.logs[0].level).toBe(level);\n    expect(jobFromDb!.logs[0].timestamp).toBeInstanceOf(Date);\n    expect(queueService.emit).toHaveBeenCalledWith(\n      \"job.log\",\n      expect.objectContaining({ id: jobId })\n    );\n  });\n\n  it(\"should not add log if job not found or worker mismatch\", async () => {\n    const nonExistentJobId = JobIdVO.create();\n    await queueService.addJobLog(nonExistentJobId, workerId, \"test\", \"INFO\");\n    expect(queueService.emit).not.toHaveBeenCalledWith(\n      \"job.log\",\n      expect.objectContaining({ id: nonExistentJobId })\n    );\n\n    await queueService.addJobLog(jobId, \"other-worker\", \"test\", \"INFO\");\n    const jobFromDb = await jobRepository.findById(jobId);\n    expect(jobFromDb!.logs.length).toBe(0);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/queue/drizzle/__tests__/queue.service.extendJobLock.spec.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'JobEntity' is defined but never used. Allowed unused vars must match /^_/u.","line":12,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":19},{"ruleId":"import/no-unresolved","severity":2,"message":"Unable to resolve path to module '../queue.service'.","line":16,"column":30,"nodeType":"Literal","endLine":16,"endColumn":48}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src_refactored/infrastructure/queue/drizzle/__tests__/queue.service.extendJobLock.spec.ts\nimport {\n  vi,\n  describe,\n  it,\n  expect,\n  beforeEach,\n  beforeAll,\n  afterEach,\n} from \"vitest\";\n\nimport { JobEntity } from \"../../../../core/domain/job/job.entity\"; // JobStatus removed\nimport { JobIdVO } from \"../../../../core/domain/job/value-objects/job-id.vo\";\nimport { type IJobOptions } from \"../../../../core/domain/job/value-objects/job-options.vo\";\nimport { DrizzleJobRepository } from \"../../../persistence/drizzle/job/drizzle-job.repository\";\nimport { QueueService } from \"../queue.service\";\n\nimport {\n  TestDb,\n  createTestDbClient,\n  runMigrations,\n  clearDatabaseTables,\n} from \"./test-db.helper\";\n\n// Top-level variables for test context\nlet db: TestDb;\nlet jobRepository: DrizzleJobRepository;\nlet queueService: QueueService<{ email: string }, { status: string }>;\nconst queueName = \"test-email-queue\";\nconst defaultJobOpts: IJobOptions = {\n  attempts: 1,\n  delay: 0,\n  priority: 0,\n  removeOnComplete: false,\n  removeOnFail: false,\n  maxStalledCount: 3,\n};\n\nbeforeAll(async () => {\n  db = createTestDbClient({ memory: true });\n  await runMigrations(db);\n});\n\nbeforeEach(async () => {\n  vi.clearAllMocks();\n  await clearDatabaseTables(db);\n\n  jobRepository = new DrizzleJobRepository(db);\n  queueService = new QueueService(queueName, jobRepository, defaultJobOpts);\n  vi.spyOn(queueService, \"emit\");\n});\n\nafterEach(async () => {\n  if (queueService) {\n    await queueService.close();\n  }\n  vi.restoreAllMocks();\n});\n\ndescribe(\"QueueService - extendJobLock\", () => {\n  let jobId: JobIdVO;\n  const workerId = \"worker-extend\";\n  const lockDurationMs = 15000;\n\n  beforeEach(async () => { // This beforeEach is specific to this describe block\n    jobId = JobIdVO.create();\n    const jobOptions: IJobOptions = { jobId: jobId.value };\n    await queueService.add(\n      \"extend-me\",\n      { email: \"extend@example.com\" },\n      jobOptions\n    );\n    const activeJob = await queueService.fetchNextJobAndLock(workerId, 10000);\n    expect(activeJob).not.toBeNull();\n    expect(activeJob!.getProps().id.value).toBe(jobId.value);\n  });\n\n  it(\"should extend lock for an active job owned by the worker\", async () => {\n    const jobBeforeExtend = await jobRepository.findById(jobId);\n    expect(jobBeforeExtend).not.toBeNull();\n    const originalLockUntil = jobBeforeExtend!.getProps().lockUntil;\n\n    await queueService.extendJobLock(jobId, workerId, lockDurationMs);\n\n    const jobAfterExtend = await jobRepository.findById(jobId);\n    expect(jobAfterExtend).not.toBeNull();\n    const jobAfterExtendProps = jobAfterExtend!.getProps();\n    expect(jobAfterExtendProps.lockUntil!.getTime()).toBeGreaterThan(\n      originalLockUntil!.getTime()\n    );\n    expect(jobAfterExtendProps.lockUntil!.getTime()).toBeGreaterThanOrEqual(\n      Date.now() + lockDurationMs - 2000\n    );\n    expect(queueService.emit).toHaveBeenCalledWith(\n      \"job.lock.extended\",\n      expect.objectContaining({ id: jobId })\n    );\n  });\n\n  it(\"should accept string job ID for extendJobLock\", async () => {\n    await queueService.extendJobLock(jobId.value, workerId, lockDurationMs);\n    const jobAfterExtend = await jobRepository.findById(jobId);\n    expect(jobAfterExtend).not.toBeNull();\n    expect(jobAfterExtend!.getProps().lockUntil!.getTime()).toBeGreaterThanOrEqual(\n      Date.now() + lockDurationMs - 2000\n    );\n  });\n\n  it(\"should not extend lock if job not found\", async () => {\n    const nonExistentJobId = JobIdVO.create();\n    await queueService.extendJobLock(\n      nonExistentJobId,\n      workerId,\n      lockDurationMs\n    );\n    expect(queueService.emit).not.toHaveBeenCalledWith(\n      \"job.lock.extended\",\n      expect.anything()\n    );\n  });\n\n  it(\"should not extend lock if workerId does not match\", async () => {\n    const jobBeforeExtend = await jobRepository.findById(jobId);\n    expect(jobBeforeExtend).not.toBeNull();\n    const originalLockTime = jobBeforeExtend!.getProps().lockUntil!.getTime();\n\n    await queueService.extendJobLock(jobId, \"other-worker\", lockDurationMs);\n    const jobAfterExtend = await jobRepository.findById(jobId);\n    expect(jobAfterExtend!.getProps().lockUntil!.getTime()).toEqual(originalLockTime);\n  });\n\n  it(\"should not extend lock if job is not active\", async () => {\n    await queueService.markJobAsCompleted(jobId, workerId, {\n      status: \"done\",\n    });\n    const jobCompleted = await jobRepository.findById(jobId);\n    expect(jobCompleted).not.toBeNull();\n    const lockTimeBefore = jobCompleted!.getProps().lockUntil;\n\n    await queueService.extendJobLock(jobId, workerId, lockDurationMs);\n    const jobAfterAttemptedExtend = await jobRepository.findById(jobId);\n    expect(jobAfterAttemptedExtend).not.toBeNull();\n    if (lockTimeBefore) {\n      expect(jobAfterAttemptedExtend!.getProps().lockUntil!.getTime()).toEqual(\n        lockTimeBefore.getTime()\n      );\n    } else {\n      expect(jobAfterAttemptedExtend!.getProps().lockUntil).toBeNull();\n    }\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/queue/drizzle/__tests__/queue.service.fetchNextJobAndLock.spec.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'JobEntity' is defined but never used. Allowed unused vars must match /^_/u.","line":14,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":19},{"ruleId":"import/no-unresolved","severity":2,"message":"Unable to resolve path to module '../queue.service'.","line":18,"column":30,"nodeType":"Literal","endLine":18,"endColumn":48}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src_refactored/infrastructure/queue/drizzle/__tests__/queue.service.fetchNextJobAndLock.spec.ts\n// import { randomUUID } from \"node:crypto\"; // Not needed in this specific file\n\nimport {\n  vi,\n  describe,\n  it,\n  expect,\n  beforeEach,\n  beforeAll,\n  // afterAll, // Removed as unused\n} from \"vitest\";\n\nimport { JobEntity, JobStatus } from \"../../../../core/domain/job/job.entity\";\n// import { JobIdVO } from \"../../../../core/domain/job/value-objects/job-id.vo\"; // Removed as unused\nimport { type IJobOptions } from \"../../../../core/domain/job/value-objects/job-options.vo\";\nimport { DrizzleJobRepository } from \"../../../persistence/drizzle/job/drizzle-job.repository\";\nimport { QueueService } from \"../queue.service\";\n\n// Newline for import group separation\nimport {\n  TestDb,\n  createTestDbClient,\n  runMigrations,\n  clearDatabaseTables,\n} from \"./test-db.helper\";\n\n// Top-level variables for test context\nlet db: TestDb;\nlet jobRepository: DrizzleJobRepository;\nlet queueService: QueueService<{ email: string }, { status: string }>;\nconst queueName = \"test-email-queue\";\nconst defaultJobOpts: IJobOptions = {\n  attempts: 1,\n  delay: 0,\n  priority: 0,\n  removeOnComplete: false,\n  removeOnFail: false,\n  maxStalledCount: 3,\n};\n\nbeforeAll(async () => {\n  db = createTestDbClient({ memory: true });\n  await runMigrations(db);\n});\n\nbeforeEach(async () => {\n  vi.clearAllMocks();\n  await clearDatabaseTables(db);\n\n  jobRepository = new DrizzleJobRepository(db);\n  queueService = new QueueService(queueName, jobRepository, defaultJobOpts);\n  vi.spyOn(queueService, \"emit\");\n});\n\nafterEach(async () => {\n  if (queueService) {\n    await queueService.close();\n  }\n  vi.restoreAllMocks();\n});\n\ndescribe(\"QueueService - fetchNextJobAndLock\", () => {\n  const workerId = \"worker-007\";\n  const lockDurationMs = 30000;\n\n  it(\"should return null if no jobs are available in DB\", async () => {\n    const job = await queueService.fetchNextJobAndLock(\n      workerId,\n      lockDurationMs\n    );\n    expect(job).toBeNull();\n  });\n\n  it(\"should return null if lock cannot be acquired (e.g. another worker got it)\", async () => {\n    await queueService.add(\"job1\", {\n      email: \"e1@example.com\",\n    });\n\n    const fetchedAndLockedJob = await queueService.fetchNextJobAndLock(\n      workerId,\n      lockDurationMs\n    );\n    expect(fetchedAndLockedJob).not.toBeNull();\n\n    const anotherAttempt = await queueService.fetchNextJobAndLock(\n      \"worker-008\",\n      lockDurationMs\n    );\n    expect(anotherAttempt).toBeNull();\n  });\n\n  it(\"should fetch, lock, update job to active in DB, and emit event\", async () => {\n    const addedJob = await queueService.add(\"job2\", {\n      email: \"e2@example.com\",\n    });\n\n    const fetchedJob = await queueService.fetchNextJobAndLock(\n      workerId,\n      lockDurationMs\n    );\n\n    expect(fetchedJob).not.toBeNull();\n    const fetchedJobProps = fetchedJob!.getProps();\n    const addedJobProps = addedJob.getProps();\n    expect(fetchedJobProps.id.value).toBe(addedJobProps.id.value);\n    expect(fetchedJobProps.status).toBe(JobStatus.ACTIVE);\n    expect(fetchedJobProps.workerId).toBe(workerId);\n    expect(fetchedJobProps.lockUntil).toBeInstanceOf(Date);\n    expect(fetchedJobProps.lockUntil!.getTime()).toBeGreaterThan(Date.now());\n    expect(fetchedJobProps.processedOn).toBeInstanceOf(Date);\n    expect(fetchedJobProps.attemptsMade).toBe(1);\n    expect(queueService.emit).toHaveBeenCalledWith(\"job.active\", fetchedJob);\n\n    const jobFromDb = await jobRepository.findById(addedJobProps.id);\n    expect(jobFromDb).not.toBeNull();\n    const jobFromDbProps = jobFromDb!.getProps();\n    expect(jobFromDbProps.status).toBe(JobStatus.ACTIVE);\n    expect(jobFromDbProps.workerId).toBe(workerId);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/queue/drizzle/__tests__/queue.service.markJobAsCompleted.spec.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'JobEntity' is defined but never used. Allowed unused vars must match /^_/u.","line":12,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":19},{"ruleId":"import/no-unresolved","severity":2,"message":"Unable to resolve path to module '../queue.service'.","line":16,"column":30,"nodeType":"Literal","endLine":16,"endColumn":48}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src_refactored/infrastructure/queue/drizzle/__tests__/queue.service.markJobAsCompleted.spec.ts\nimport {\n  vi,\n  describe,\n  it,\n  expect,\n  beforeEach,\n  beforeAll,\n  afterEach,\n} from \"vitest\";\n\nimport { JobEntity, JobStatus } from \"../../../../core/domain/job/job.entity\";\nimport { JobIdVO } from \"../../../../core/domain/job/value-objects/job-id.vo\";\nimport { type IJobOptions } from \"../../../../core/domain/job/value-objects/job-options.vo\";\nimport { DrizzleJobRepository } from \"../../../persistence/drizzle/job/drizzle-job.repository\";\nimport { QueueService } from \"../queue.service\";\n\nimport {\n  TestDb,\n  createTestDbClient,\n  runMigrations,\n  clearDatabaseTables,\n} from \"./test-db.helper\";\n\n// Top-level variables for test context\nlet db: TestDb;\nlet jobRepository: DrizzleJobRepository;\nlet queueService: QueueService<{ email: string }, { status: string }>; // Payload type for add\nconst queueName = \"test-email-queue\";\nconst defaultJobOpts: IJobOptions = {\n  attempts: 1,\n  delay: 0,\n  priority: 0,\n  removeOnComplete: false,\n  removeOnFail: false,\n  maxStalledCount: 3,\n};\n\nbeforeAll(async () => {\n  db = createTestDbClient({ memory: true });\n  await runMigrations(db);\n});\n\nbeforeEach(async () => {\n  vi.clearAllMocks();\n  await clearDatabaseTables(db);\n\n  jobRepository = new DrizzleJobRepository(db);\n  // Provide payload type for QueueService instantiation\n  queueService = new QueueService<{ email: string }, { status: string }>(\n    queueName,\n    jobRepository,\n    defaultJobOpts\n  );\n  vi.spyOn(queueService, \"emit\");\n});\n\nafterEach(async () => {\n  if (queueService) {\n    await queueService.close();\n  }\n  vi.restoreAllMocks();\n});\n\ndescribe(\"QueueService - markJobAsCompleted\", () => {\n  let jobIdForCompleteTest: JobIdVO;\n  const workerIdForCompleteTest = \"worker-complete\";\n  const resultForCompleteTest = { status: \"Email Sent!\" };\n\n  beforeEach(async () => { // This beforeEach is specific to this describe block\n    jobIdForCompleteTest = JobIdVO.create();\n    await queueService.add(\n      \"complete-me\",\n      { email: \"c@ex.com\" }, // Payload matches QueueService type\n      { jobId: jobIdForCompleteTest.value }\n    );\n    const activeJob = await queueService.fetchNextJobAndLock(\n      workerIdForCompleteTest,\n      10000\n    );\n    if (!activeJob || activeJob.getProps().id.value !== jobIdForCompleteTest.value)\n      throw new Error(\"Setup failed for markJobAsCompleted\");\n  });\n\n  it(\"should mark job as completed, update DB, and emit event\", async () => {\n    const jobInstanceFromWorker =\n      await jobRepository.findById(jobIdForCompleteTest);\n    expect(jobInstanceFromWorker).not.toBeNull();\n    jobInstanceFromWorker!.addLog(\n      \"Log from worker before completion\",\n      \"INFO\"\n    );\n\n    await queueService.markJobAsCompleted(\n      jobIdForCompleteTest,\n      workerIdForCompleteTest,\n      resultForCompleteTest,\n      jobInstanceFromWorker!\n    );\n\n    const jobFromDb = await jobRepository.findById(jobIdForCompleteTest);\n    expect(jobFromDb).not.toBeNull();\n    const jobFromDbProps = jobFromDb!.getProps();\n    expect(jobFromDbProps.status).toBe(JobStatus.COMPLETED);\n    expect(jobFromDbProps.returnValue).toEqual(resultForCompleteTest);\n    expect(jobFromDbProps.finishedOn).toBeInstanceOf(Date);\n    expect(\n      jobFromDbProps.logs.some(\n        (log) => log.message === \"Log from worker before completion\"\n      )\n    ).toBe(false);\n\n    expect(queueService.emit).toHaveBeenCalledWith(\n      \"job.completed\",\n      expect.objectContaining({\n        id: jobIdForCompleteTest,\n        status: JobStatus.COMPLETED,\n      })\n    );\n  });\n\n  it(\"should accept string job ID for markJobAsCompleted\", async () => {\n    await queueService.markJobAsCompleted(\n      jobIdForCompleteTest.value,\n      workerIdForCompleteTest,\n      resultForCompleteTest\n    );\n    const jobFromDb = await jobRepository.findById(jobIdForCompleteTest);\n    expect(jobFromDb).not.toBeNull();\n    expect(jobFromDb!.getProps().status).toBe(JobStatus.COMPLETED);\n  });\n\n  it(\"should not complete if job not found in DB\", async () => {\n    const nonExistentJobId = JobIdVO.create();\n    await queueService.markJobAsCompleted(\n      nonExistentJobId,\n      workerIdForCompleteTest,\n      resultForCompleteTest\n    );\n    expect(queueService.emit).not.toHaveBeenCalledWith(\n      \"job.completed\",\n      expect.objectContaining({ id: nonExistentJobId })\n    );\n  });\n\n  it(\"should not complete if workerId does not match job in DB\", async () => {\n    await queueService.markJobAsCompleted(\n      jobIdForCompleteTest,\n      \"another-worker\",\n      resultForCompleteTest\n    );\n    const jobFromDb = await jobRepository.findById(jobIdForCompleteTest);\n    expect(jobFromDb).not.toBeNull();\n    expect(jobFromDb!.getProps().status).toBe(JobStatus.ACTIVE);\n    expect(queueService.emit).not.toHaveBeenCalledWith(\n      \"job.completed\",\n      expect.anything()\n    );\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/queue/drizzle/__tests__/queue.service.markJobAsFailed.spec.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'JobEntity' is defined but never used. Allowed unused vars must match /^_/u.","line":12,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":19},{"ruleId":"import/no-unresolved","severity":2,"message":"Unable to resolve path to module '../queue.service'.","line":16,"column":30,"nodeType":"Literal","endLine":16,"endColumn":48}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src_refactored/infrastructure/queue/drizzle/__tests__/queue.service.markJobAsFailed.spec.ts\nimport {\n  vi,\n  describe,\n  it,\n  expect,\n  beforeEach,\n  beforeAll,\n  afterEach,\n} from \"vitest\";\n\nimport { JobEntity, JobStatus } from \"../../../../core/domain/job/job.entity\";\nimport { JobIdVO } from \"../../../../core/domain/job/value-objects/job-id.vo\";\nimport { type IJobOptions } from \"../../../../core/domain/job/value-objects/job-options.vo\";\nimport { DrizzleJobRepository } from \"../../../persistence/drizzle/job/drizzle-job.repository\";\nimport { QueueService } from \"../queue.service\";\n\nimport {\n  TestDb,\n  createTestDbClient,\n  runMigrations,\n  clearDatabaseTables,\n} from \"./test-db.helper\";\n\n// Top-level variables for test context\nlet db: TestDb;\nlet jobRepository: DrizzleJobRepository;\nlet queueService: QueueService<{ email: string }, { status: string }>; // Payload type for add\nconst queueName = \"test-email-queue\";\nconst defaultJobOpts: IJobOptions = {\n  attempts: 1,\n  delay: 0,\n  priority: 0,\n  removeOnComplete: false,\n  removeOnFail: false,\n  maxStalledCount: 3,\n};\n\nbeforeAll(async () => {\n  db = createTestDbClient({ memory: true });\n  await runMigrations(db);\n});\n\nbeforeEach(async () => {\n  vi.clearAllMocks();\n  await clearDatabaseTables(db);\n\n  jobRepository = new DrizzleJobRepository(db);\n  queueService = new QueueService<{ email: string }, { status: string }>(\n    queueName,\n    jobRepository,\n    defaultJobOpts\n  );\n  vi.spyOn(queueService, \"emit\");\n});\n\nafterEach(async () => {\n  if (queueService) {\n    await queueService.close();\n  }\n  vi.restoreAllMocks();\n});\n\ndescribe(\"QueueService - markJobAsFailed\", () => {\n  let jobToFailPermanentlyId: JobIdVO;\n  let jobToRetryId: JobIdVO;\n  const workerIdForFailTest = \"worker-fail\";\n  const errorForFailTest = new Error(\"Test Job Failed\");\n\n  beforeEach(async () => { // This beforeEach is specific to this describe block\n    jobToFailPermanentlyId = JobIdVO.create();\n    await queueService.add(\n      \"fail-me-permanently\",\n      { email: \"f-perm@ex.com\" },\n      { jobId: jobToFailPermanentlyId.value, attempts: 1 }\n    );\n    const activeJobPerm = await queueService.fetchNextJobAndLock(\n      workerIdForFailTest,\n      10000\n    );\n    if (\n      !activeJobPerm ||\n      activeJobPerm.getProps().id.value !== jobToFailPermanentlyId.value\n    )\n      throw new Error(\"Setup failed for jobToFailPermanently\");\n\n    jobToRetryId = JobIdVO.create();\n    await queueService.add(\n      \"fail-me-with-retries\",\n      { email: \"f-retry@ex.com\" },\n      {\n        jobId: jobToRetryId.value,\n        attempts: 3,\n        backoff: { type: \"exponential\", delay: 100 },\n      }\n    );\n    const activeJobRetry = await queueService.fetchNextJobAndLock(\n      workerIdForFailTest,\n      10000\n    );\n    if (!activeJobRetry || activeJobRetry.getProps().id.value !== jobToRetryId.value)\n      throw new Error(\"Setup failed for jobToRetry\");\n  });\n\n  it(\"should mark job as FAILED if attempts exhausted, update DB, and emit event\", async () => {\n    await queueService.markJobAsFailed(\n      jobToFailPermanentlyId,\n      workerIdForFailTest,\n      errorForFailTest\n    );\n\n    const jobFromDb = await jobRepository.findById(jobToFailPermanentlyId);\n    expect(jobFromDb).not.toBeNull();\n    const jobFromDbProps = jobFromDb!.getProps();\n    expect(jobFromDbProps.status).toBe(JobStatus.FAILED);\n    expect(jobFromDbProps.failedReason).toBe(errorForFailTest.message);\n    expect(jobFromDbProps.finishedOn).toBeInstanceOf(Date);\n    expect(queueService.emit).toHaveBeenCalledWith(\n      \"job.failed\",\n      expect.objectContaining({\n        id: jobToFailPermanentlyId,\n        status: JobStatus.FAILED,\n      })\n    );\n  });\n\n  it(\"should mark job as DELAYED if retries are pending, update DB, and emit event\", async () => {\n    await queueService.markJobAsFailed(\n      jobToRetryId,\n      workerIdForFailTest,\n      errorForFailTest\n    );\n\n    const jobFromDb = await jobRepository.findById(jobToRetryId);\n    expect(jobFromDb).not.toBeNull();\n    const jobFromDbProps = jobFromDb!.getProps();\n    expect(jobFromDbProps.status).toBe(JobStatus.DELAYED);\n    expect(jobFromDbProps.failedReason).toBe(errorForFailTest.message);\n    expect(jobFromDbProps.delayUntil).toBeInstanceOf(Date);\n    expect(jobFromDbProps.delayUntil!.getTime()).toBeGreaterThanOrEqual(\n      Date.now() + 90\n    );\n    expect(jobFromDbProps.attemptsMade).toBe(1);\n    expect(queueService.emit).toHaveBeenCalledWith(\n      \"job.failed\",\n      expect.objectContaining({ id: jobToRetryId, status: JobStatus.DELAYED })\n    );\n  });\n\n  it(\"should accept string job ID for markJobAsFailed\", async () => {\n    await queueService.markJobAsFailed(\n      jobToFailPermanentlyId.value,\n      workerIdForFailTest,\n      errorForFailTest\n    );\n    const jobFromDb = await jobRepository.findById(jobToFailPermanentlyId);\n    expect(jobFromDb).not.toBeNull();\n    expect(jobFromDb!.getProps().status).toBe(JobStatus.FAILED);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/queue/drizzle/__tests__/queue.service.spec.ts","messages":[{"ruleId":"import/no-unresolved","severity":2,"message":"Unable to resolve path to module '../queue.service'.","line":26,"column":30,"nodeType":"Literal","endLine":26,"endColumn":48}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src_refactored/infrastructure/queue/drizzle/__tests__/queue.service.spec.ts\n// Main test file for QueueService.\n// Tests have been split into multiple files for better organization and to manage file length.\n// See:\n// - queue.service-add.spec.ts\n// - queue.service-get.spec.ts\n// - queue.service-lifecycle.spec.ts\n// - queue.service-updates.spec.ts\n// - queue.service-maintenance.spec.ts\n// - queue.service-admin.spec.ts\n\nimport {\n  vi,\n  // describe, // No top-level describe needed here anymore\n  // it,\n  // expect,\n  beforeEach,\n  beforeAll,\n  afterEach,\n} from \"vitest\";\n\n// import { JobEntity, JobStatus } from \"../../../../core/domain/job/job.entity\"; // Keep if needed by shared setup\n// import { JobIdVO } from \"../../../../core/domain/job/value-objects/job-id.vo\"; // Keep if needed by shared setup\nimport { type IJobOptions } from \"../../../../core/domain/job/value-objects/job-options.vo\";\nimport { DrizzleJobRepository } from \"../../../persistence/drizzle/job/drizzle-job.repository\";\nimport { QueueService } from \"../queue.service\";\n\nimport {\n  TestDb,\n  createTestDbClient,\n  runMigrations,\n  clearDatabaseTables,\n} from \"./test-db.helper\";\n\n// Top-level variables for test context, potentially used by split files if they import this setup.\n// However, each spec file currently re-declares this setup.\n// This file can be minimal if setup is fully duplicated, or it could export setup helpers.\nexport let db: TestDb;\nexport let jobRepository: DrizzleJobRepository;\nexport let queueService: QueueService<{ email: string }, { status: string }>;\nexport const queueName = \"test-email-queue\";\nexport const defaultJobOpts: IJobOptions = {\n  attempts: 1,\n  delay: 0,\n  priority: 0,\n  removeOnComplete: false,\n  removeOnFail: false,\n  maxStalledCount: 3,\n};\n\nbeforeAll(async () => {\n  db = createTestDbClient({ memory: true });\n  await runMigrations(db);\n  // Initialize repository and service here if they are to be shared and imported by other spec files.\n  // For now, each spec file initializes its own.\n});\n\nbeforeEach(async () => {\n  vi.clearAllMocks();\n  await clearDatabaseTables(db); // Clears for all tests using this shared db connection.\n\n  // If we intend split files to use a shared `queueService` instance, initialize it here.\n  // Otherwise, this beforeEach is only for this file (which has no tests directly).\n  // jobRepository = new DrizzleJobRepository(db);\n  // queueService = new QueueService(queueName, jobRepository, defaultJobOpts);\n  // vi.spyOn(queueService, \"emit\"); // This would need to be handled carefully if service is per-file.\n});\n\nafterEach(async () => {\n  // if (queueService) { // If service is shared\n  //   await queueService.close();\n  // }\n  vi.restoreAllMocks();\n});\n\n// No direct tests in this file anymore. All tests are in specific queue.service-*.spec.ts files.\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/queue/drizzle/__tests__/test-db.helper.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/queue/drizzle/drizzle-queue.facade.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/queue/drizzle/job-processing.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/queue/drizzle/queue-maintenance.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/queue/drizzle/queue-service-core.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/services/logger/console-logger.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/services/tool-registry/tool-registry.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/tools/file-system.tool.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/electron/main/handlers/agent-instance.handlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/electron/main/handlers/dm.handlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/electron/main/handlers/llm-config.handlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/electron/main/handlers/persona-template.handlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/electron/main/handlers/project.handlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/electron/main/handlers/user.handlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/electron/main/ipc-chat.handlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/electron/main/ipc-handlers/agent-instance.handlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/electron/main/ipc-handlers/dm.handlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/electron/main/ipc-handlers/llm-config.handlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/electron/main/ipc-handlers/persona-template.handlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/electron/main/ipc-handlers/project.handlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/electron/main/ipc-handlers/user.handlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/electron/main/ipc-project.handlers.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'Project' is not defined.","line":29,"column":50,"nodeType":"Identifier","messageId":"undef","endLine":29,"endColumn":57}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ipcMain, IpcMainInvokeEvent } from \"electron\";\n\nimport { ListProjectsUseCase } from \"@/core/application/use-cases/project/list-projects.use-case\";\n\n// import { appContainer } from \"@/infrastructure/ioc/inversify.config\"; // Removed import\n\nimport { IPCChannel } from \"@/shared/ipc-channels\";\nimport { ProjectListItem } from \"@/shared/ipc-project.types\";\n\nlet internalListProjectsUseCase: ListProjectsUseCase | null = null;\n\n// Removed initializeUseCases function\n\nexport function registerProjectIPCHandlers(\n  listProjectsUseCaseInstance: ListProjectsUseCase\n): void {\n  if (!listProjectsUseCaseInstance) {\n    console.error(\n      \"[IPC Project Handler] CRITICAL: Provided listProjectsUseCaseInstance is null or undefined.\"\n    );\n  }\n  internalListProjectsUseCase = listProjectsUseCaseInstance;\n\n  ipcMain.handle(IPCChannel.PROJECT_LIST_QUERY, handleProjectListQuery);\n\n  console.log(\"[IPC Project Handler] Project IPC handlers registered.\");\n}\n\nfunction mapProjectsToProjectListItems(projects: Project[]): ProjectListItem[] {\n  return projects.map((project) => ({\n    id: project.id.value,\n    name: project.name.value,\n    description: project.description?.value,\n    createdAt: project.createdAt.toISOString(),\n    updatedAt: project.updatedAt.toISOString(),\n    // ownerName: project.owner?.name.value, // Example, if Project entity has owner\n    // thumbnailUrl: project.thumbnailUrl?.value, // Example\n  }));\n}\n\nasync function handleProjectListQuery(_event: IpcMainInvokeEvent) {\n  console.log(\n    `[IPC Project Handler] Received ${IPCChannel.PROJECT_LIST_QUERY}`\n  );\n  try {\n    if (!internalListProjectsUseCase) {\n      console.error(\n        \"[IPC Project Handler] ListProjectsUseCase not initialized. Ensure it's passed to registerProjectIPCHandlers.\"\n      );\n      return {\n        success: false,\n        error: { message: \"ListProjectsUseCase not available.\" },\n      };\n    }\n\n    const result = await internalListProjectsUseCase.execute();\n\n    if (result.isSuccess()) {\n      const projects = result.value;\n      const projectListItems = mapProjectsToProjectListItems(projects);\n      console.log(\n        `[IPC Project Handler] Sending ${projectListItems.length} projects.`\n      );\n      return { success: true, data: projectListItems };\n    }\n    console.error(\n      \"[IPC Project Handler] Error listing projects:\",\n      result.error\n    );\n    return {\n      success: false,\n      error: { message: result.error.message, name: result.error.name },\n    };\n  } catch (error: unknown) {\n    console.error(\n      \"[IPC Project Handler] Exception in project:list handler:\",\n      error\n    );\n    // Ensure error.message is accessed safely\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    return {\n      success: false,\n      error: {\n        message:\n          errorMessage ||\n          \"An unexpected error occurred while listing projects.\",\n      },\n    };\n  }\n}\n\nexport function unregisterProjectIPCHandlers(): void {\n  ipcMain.removeHandler(IPCChannel.PROJECT_LIST_QUERY);\n  // Clear the reference\n  internalListProjectsUseCase = null;\n  console.log(\"[IPC Project Handler] Project IPC handlers unregistered.\");\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/electron/main/main.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/electron/main/mocks/agent-instance.mocks.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/electron/main/mocks/dm.mocks.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/electron/main/mocks/llm-config.mocks.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/electron/main/mocks/persona-template.mocks.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/electron/main/mocks/project.mocks.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/electron/main/mocks/user.mocks.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/electron/preload.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/_layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/agents/$agentId/edit/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/agents/$agentId/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/agents/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/agents/new/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/chat/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/dashboard/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/personas/$templateId/edit/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/personas/$templateId/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/personas/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/personas/new/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/projects/$projectId/chat/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/projects/$projectId/docs/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/projects/$projectId/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/projects/$projectId/members/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/projects/$projectId/settings/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/projects/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/projects/new/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/settings/appearance/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/settings/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/settings/llm/$configId/edit/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/settings/llm/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/settings/llm/new/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/settings/profile/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/user/_layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/user/dm/$conversationId/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/user/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(public)/onboarding/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/__root.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/common/MarkdownRenderer.tsx","messages":[],"suppressedMessages":[{"ruleId":"jsx-a11y/anchor-has-content","severity":2,"message":"Anchors must have content and the content must be accessible by a screen reader.","line":56,"column":57,"nodeType":"JSXOpeningElement","endLine":56,"endColumn":121,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/common/theme-provider.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/layout/AppSidebar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/accordion.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/alert-dialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/alert.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/aspect-ratio.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/avatar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/badge.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/breadcrumb.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/button.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/calendar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/card.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/carousel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/chart.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/checkbox.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/collapsible.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/command.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/context-menu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/dialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/drawer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/dropdown-menu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/form.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/hover-card.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/input-otp.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/input.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/label.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/navigation-menu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/pagination.tsx","messages":[],"suppressedMessages":[{"ruleId":"jsx-a11y/anchor-has-content","severity":2,"message":"Anchors must have content and the content must be accessible by a screen reader.","line":53,"column":5,"nodeType":"JSXOpeningElement","endLine":65,"endColumn":7,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/popover.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/progress.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/radio-group.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/resizable.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/scroll-area.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/select.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/separator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/sheet.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/sidebar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/skeleton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/slider.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/sonner.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/switch.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/table.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/tabs.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/textarea.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/toggle-group.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/toggle.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/tooltip.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/agent/components/AgentInstanceForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/agent/components/AgentInstanceList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/agent/components/AgentInstanceListItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/agent/components/fields/AgentLLMConfigSelectField.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/agent/components/fields/AgentNameField.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/agent/components/fields/AgentPersonaTemplateSelectField.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/agent/components/fields/AgentTemperatureSliderField.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/chat/components/ChatInput.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/chat/components/ChatSidebar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/chat/components/ChatWindow.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/chat/components/ConversationList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/chat/components/MessageInput.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/chat/components/MessageItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/chat/components/MessageList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/llm/components/LLMConfigForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/llm/components/LLMConfigList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/llm/components/LLMConfigListItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/llm/components/fields/ApiKeyField.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/llm/components/fields/BaseUrlField.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/llm/components/fields/ConfigNameField.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/llm/components/fields/ProviderSelectField.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/onboarding/components/InitialConfigStep.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/onboarding/components/OnboardingWizard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/onboarding/components/PersonaList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/onboarding/components/WelcomeStep.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/persona/components/PersonaTemplateForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/persona/components/PersonaTemplateList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/persona/components/PersonaTemplateListItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/persona/components/fields/PersonaBackstoryField.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/persona/components/fields/PersonaGoalField.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/persona/components/fields/PersonaNameField.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/persona/components/fields/PersonaRoleField.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/persona/components/fields/PersonaToolsField.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/project/components/ProjectCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/project/components/ProjectForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/project/components/ProjectList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/project/components/ProjectListItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/project/components/ProjectSidebar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/project/components/fields/ProjectDescriptionField.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/project/components/fields/ProjectNameField.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/project/components/layout/ParticipantListItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/project/components/layout/ProjectContextSidebar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/project/components/layout/ProjectParticipantsSidebar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/user/components/UserProfileForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/user/components/UserSidebar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/user/components/fields/AvatarUrlField.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/user/components/fields/DisplayNameField.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/user/components/fields/EmailDisplayField.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/user/components/layout/UserSidebar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/user/components/layout/UserSidebarParts.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/global.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/hooks/ipc/useIpcMutation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/hooks/ipc/useIpcQuery.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/hooks/ipc/useIpcSubscription.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/hooks/use-mobile.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/hooks/useIPC.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'IElectronIPC' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":22,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/lib/utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/main.tsx","messages":[],"suppressedMessages":[{"ruleId":"import/no-unresolved","severity":2,"message":"Unable to resolve path to module '@/ui/routeTree.gen'.","line":8,"column":27,"nodeType":"Literal","endLine":8,"endColumn":47,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/services/ipc.service.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":126,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":126,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4792,4795],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4792,4795],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":186,"column":72,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":186,"endColumn":75,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8168,8171],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8168,8171],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/services/ipc.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/shared/ipc-channels.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/shared/ipc-chat.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/shared/ipc-project.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/shared/ipc-types/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/shared/result.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/shared/types/entities.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]