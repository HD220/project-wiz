[{"filePath":"/app/src_refactored/core/application/common/errors.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/common/executable.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/common/ports/use-case.interface.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"An interface declaring no members is equivalent to its supertype.","line":18,"column":18,"nodeType":"Identifier","messageId":"noEmptyInterfaceWithSuper","endLine":18,"endColumn":26,"suggestions":[{"messageId":"replaceEmptyInterfaceWithSuper","fix":{"range":[743,1129],"text":"type IUseCase<\n  TRequest,\n  TResponse,\n  TError extends Error = DomainError | ApplicationError,\n> = Executable<TRequest, TResponse, TError>"},"desc":"Replace empty interface with a type alias."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/ports/events/i-job-event-emitter.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/ports/job-repository.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/ports/services/i-agent-executor.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/ports/services/i-chat.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/ports/services/i-embedding.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/ports/services/i-tool-registry.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/queue/abstract-queue.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/queue/events/job-event.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/services/agent-interaction.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/services/agent-state.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/services/agent-tool.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/services/chat.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/services/generic-agent-executor.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/services/tool-validation.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/agent-internal-state/load-agent-internal-state.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/agent-internal-state/load-agent-internal-state.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/agent-internal-state/save-agent-internal-state.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/agent-internal-state/save-agent-internal-state.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/agent-persona-template/create-persona-template.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/agent-persona-template/create-persona-template.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/agent/create-agent.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/agent/create-agent.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/annotation/list-annotations.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/annotation/list-annotations.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/annotation/remove-annotation.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/annotation/remove-annotation.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/annotation/save-annotation.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/annotation/save-annotation.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/llm-provider-config/create-llm-provider-config.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/llm-provider-config/create-llm-provider-config.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/memory/remove-memory-item.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/memory/remove-memory-item.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/memory/save-memory-item.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/memory/save-memory-item.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/memory/search-memory-items.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/memory/search-memory-items.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/memory/search-similar-memory-items.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/memory/search-similar-memory-items.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/project/create-project.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/project/create-project.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/project/get-project-details.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/project/get-project-details.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/project/list-projects.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/project/list-projects.use-case.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'input' is defined but never used. Allowed unused args must match /^_/u.","line":32,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":32,"endColumn":10,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/user/create-user.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/user/create-user.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/user/get-user.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/use-cases/user/get-user.use-case.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/worker/__tests__/worker.service.close.spec.ts","messages":[],"suppressedMessages":[{"ruleId":"boundaries/element-types","severity":2,"message":"APPLICATION: Proibido importar de infrastructure (permitido: domain, shared).","line":6,"column":38,"nodeType":"Literal","endLine":6,"endColumn":113,"suppressions":[{"kind":"directive","justification":"Integration test needs access to infrastructure"}]},{"ruleId":"boundaries/element-types","severity":2,"message":"APPLICATION: Proibido importar de infrastructure (permitido: domain, shared).","line":8,"column":59,"nodeType":"Literal","endLine":8,"endColumn":126,"suppressions":[{"kind":"directive","justification":"Integration test needs access to infrastructure"}]},{"ruleId":"boundaries/element-types","severity":2,"message":"APPLICATION: Proibido importar de infrastructure (permitido: domain, shared).","line":10,"column":30,"nodeType":"Literal","endLine":10,"endColumn":86,"suppressions":[{"kind":"directive","justification":"Integration test needs access to infrastructure"}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/worker/__tests__/worker.service.error-handling.spec.ts","messages":[],"suppressedMessages":[{"ruleId":"boundaries/element-types","severity":2,"message":"APPLICATION: Proibido importar de infrastructure (permitido: domain, shared).","line":6,"column":38,"nodeType":"Literal","endLine":6,"endColumn":113,"suppressions":[{"kind":"directive","justification":"Integration test needs access to infrastructure"}]},{"ruleId":"boundaries/element-types","severity":2,"message":"APPLICATION: Proibido importar de infrastructure (permitido: domain, shared).","line":8,"column":59,"nodeType":"Literal","endLine":8,"endColumn":126,"suppressions":[{"kind":"directive","justification":"Integration test needs access to infrastructure"}]},{"ruleId":"boundaries/element-types","severity":2,"message":"APPLICATION: Proibido importar de infrastructure (permitido: domain, shared).","line":10,"column":30,"nodeType":"Literal","endLine":10,"endColumn":86,"suppressions":[{"kind":"directive","justification":"Integration test needs access to infrastructure"}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/worker/__tests__/worker.service.initialization.spec.ts","messages":[],"suppressedMessages":[{"ruleId":"boundaries/element-types","severity":2,"message":"APPLICATION: Proibido importar de infrastructure (permitido: domain, shared).","line":4,"column":38,"nodeType":"Literal","endLine":4,"endColumn":113,"suppressions":[{"kind":"directive","justification":"Integration test needs access to infrastructure"}]},{"ruleId":"boundaries/element-types","severity":2,"message":"APPLICATION: Proibido importar de infrastructure (permitido: domain, shared).","line":6,"column":59,"nodeType":"Literal","endLine":6,"endColumn":126,"suppressions":[{"kind":"directive","justification":"Integration test needs access to infrastructure"}]},{"ruleId":"boundaries/element-types","severity":2,"message":"APPLICATION: Proibido importar de infrastructure (permitido: domain, shared).","line":8,"column":30,"nodeType":"Literal","endLine":8,"endColumn":86,"suppressions":[{"kind":"directive","justification":"Integration test needs access to infrastructure"}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/worker/__tests__/worker.service.job-processing.spec.ts","messages":[],"suppressedMessages":[{"ruleId":"boundaries/element-types","severity":2,"message":"APPLICATION: Proibido importar de infrastructure (permitido: domain, shared).","line":6,"column":38,"nodeType":"Literal","endLine":6,"endColumn":113,"suppressions":[{"kind":"directive","justification":"Integration test needs access to infrastructure"}]},{"ruleId":"boundaries/element-types","severity":2,"message":"APPLICATION: Proibido importar de infrastructure (permitido: domain, shared).","line":8,"column":59,"nodeType":"Literal","endLine":8,"endColumn":126,"suppressions":[{"kind":"directive","justification":"Integration test needs access to infrastructure"}]},{"ruleId":"boundaries/element-types","severity":2,"message":"APPLICATION: Proibido importar de infrastructure (permitido: domain, shared).","line":10,"column":30,"nodeType":"Literal","endLine":10,"endColumn":86,"suppressions":[{"kind":"directive","justification":"Integration test needs access to infrastructure"}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/worker/__tests__/worker.service.lock-renewal.spec.ts","messages":[],"suppressedMessages":[{"ruleId":"boundaries/element-types","severity":2,"message":"APPLICATION: Proibido importar de infrastructure (permitido: domain, shared).","line":6,"column":38,"nodeType":"Literal","endLine":6,"endColumn":113,"suppressions":[{"kind":"directive","justification":"Integration test needs access to infrastructure"}]},{"ruleId":"boundaries/element-types","severity":2,"message":"APPLICATION: Proibido importar de infrastructure (permitido: domain, shared).","line":8,"column":59,"nodeType":"Literal","endLine":8,"endColumn":126,"suppressions":[{"kind":"directive","justification":"Integration test needs access to infrastructure"}]},{"ruleId":"boundaries/element-types","severity":2,"message":"APPLICATION: Proibido importar de infrastructure (permitido: domain, shared).","line":10,"column":30,"nodeType":"Literal","endLine":10,"endColumn":86,"suppressions":[{"kind":"directive","justification":"Integration test needs access to infrastructure"}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/worker/__tests__/worker.service.spec.helper.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/worker/worker.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'clearTimeout' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'Timeout' is not defined.","line":15,"column":40,"nodeType":"Identifier","messageId":"undef","endLine":15,"endColumn":47},{"ruleId":"max-lines","severity":2,"message":"File has too many lines (202). Maximum allowed is 200.","line":228,"column":1,"nodeType":null,"messageId":"exceed","endLine":230,"endColumn":1}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { randomUUID } from \"node:crypto\";\nimport EventEmitter from \"node:events\";\nimport { clearTimeout, setInterval, clearInterval, setTimeout } from \"node:timers\";\n\nimport { AbstractQueue } from \"@/core/application/queue/abstract-queue\";\nimport { JobEntity } from \"@/core/domain/job/job.entity\";\n\nimport { ProcessorFunction, WorkerOptions } from \"./worker.types\";\n\nexport class WorkerService<P, R> extends EventEmitter {\n  public readonly workerId: string;\n  private _isRunning: boolean = false;\n  private _isClosed: boolean = false;\n  private _activeJobs: number = 0;\n  private lockRenewTimers: Map<string, Timeout> = new Map();\n  private pollLoopPromise: Promise<void> | null = null;\n  private readonly pollingIntervalMs: number = 1000;\n\n  constructor(\n    protected readonly queue: AbstractQueue<P, R>,\n    protected readonly processor: ProcessorFunction<P, R>,\n    protected readonly opts: WorkerOptions = { lockDuration: 30000 }\n  ) {\n    super();\n    this.workerId = randomUUID();\n    if (opts.concurrency && opts.concurrency > 1) {\n      console.warn(\n        `[WorkerService] Concurrency option > 1 is not supported in this sequential version. Effective concurrency is 1.`\n      );\n    }\n  }\n\n  get isRunning(): boolean {\n    return this._isRunning;\n  }\n  get isClosed(): boolean {\n    return this._isClosed;\n  }\n  get activeJobCount(): number {\n    return this._activeJobs;\n  }\n\n  public run(): void {\n    if (this._isRunning || this._isClosed) return;\n    this._isRunning = true;\n    this.pollLoopPromise = this.poll();\n  }\n\n  public async close(): Promise<void> {\n    if (this._isClosed) return;\n\n    this._isRunning = false;\n    this._isClosed = true;\n\n    if (this.pollLoopPromise) {\n      try {\n        await this.pollLoopPromise;\n      } catch (error) {\n        this.emit(\n          \"worker.error\",\n          new Error(\n            `Error during poll loop shutdown: ${error instanceof Error ? error.message : String(error)}`\n          )\n        );\n      }\n    }\n\n    const gracefulShutdownTimeout = this.opts.lockDuration\n      ? this.opts.lockDuration * 2\n      : 60000;\n    const startTime = Date.now();\n    while (\n      this._activeJobs > 0 &&\n      Date.now() - startTime < gracefulShutdownTimeout\n    ) {\n      await new Promise((resolve) => setTimeout(resolve, 100));\n    }\n\n    if (this._activeJobs > 0) {\n      this.emit(\n        \"worker.error\",\n        new Error(\n          `Worker closed with ${this._activeJobs} active job(s) still running after timeout.`\n        )\n      );\n    }\n\n    this.lockRenewTimers.forEach((timer) => clearInterval(timer));\n    this.lockRenewTimers.clear();\n    this.emit(\"worker.closed\");\n  }\n\n  private async poll(): Promise<void> {\n    while (this._isRunning && !this._isClosed) {\n      if (this._activeJobs !== 0) {\n        await new Promise((resolve) =>\n          setTimeout(resolve, this.pollingIntervalMs)\n        );\n        continue;\n      }\n\n      try {\n        const job = await this.queue.fetchNextJobAndLock(\n          this.workerId,\n          this.opts.lockDuration ?? 30000\n        );\n\n        if (!job) {\n          await new Promise((resolve) =>\n            setTimeout(resolve, this.pollingIntervalMs)\n          );\n          continue;\n        }\n\n        if (!this._isRunning || this._isClosed) {\n          console.warn(\n            `[WorkerService] Worker stopped while job ${job.id.value} was fetched. Job may become stalled.`\n          );\n          break;\n        }\n\n        this._activeJobs = 1;\n        await this.processJob(job);\n      } catch (error) {\n        this.emit(\"worker.error\", error);\n        await new Promise((resolve) =>\n          setTimeout(resolve, this.pollingIntervalMs * 2)\n        );\n      }\n    }\n  }\n\n  private _instrumentJobForWorker(job: JobEntity<P, R>): {\n    originalUpdateProgress: JobEntity<P, R>[\"updateProgress\"];\n    originalAddLog: JobEntity<P, R>[\"addLog\"];\n  } {\n    const originalUpdateProgress = job.updateProgress.bind(job);\n    job.updateProgress = (progress: number | object) => {\n      originalUpdateProgress(progress);\n      this.queue\n        .updateJobProgress(job.id, this.workerId, progress)\n        .catch((err) => {\n          this.emit(\n            \"worker.error\",\n            new Error(\n              `Failed to update progress for job ${job.id.value}: ${err instanceof Error ? err.message : String(err)}`\n            )\n          );\n        });\n    };\n\n    const originalAddLog = job.addLog.bind(job);\n    job.addLog = (message: string, level?: string) => {\n      originalAddLog(message, level);\n      this.queue\n        .addJobLog(job.id, this.workerId, message, level)\n        .catch((err) => {\n          this.emit(\n            \"worker.error\",\n            new Error(\n              `Failed to add log for job ${job.id.value}: ${err instanceof Error ? err.message : String(err)}`\n            )\n          );\n        });\n    };\n    return { originalUpdateProgress, originalAddLog };\n  }\n\n  private async _executeProcessor(job: JobEntity<P, R>): Promise<void> {\n    try {\n      const result = await this.processor(job);\n      if (this._isClosed && !job.finishedOn) {\n        this.emit(\"worker.job.interrupted\", job);\n      } else if (!this._isClosed) {\n        await this.queue.markJobAsCompleted(job.id, this.workerId, result, job);\n        this.emit(\"worker.job.processed\", job, result);\n      }\n    } catch (error) {\n      if (!this._isClosed) {\n        await this.queue.markJobAsFailed(\n          job.id,\n          this.workerId,\n          error as Error,\n          job\n        );\n        this.emit(\"worker.job.errored\", job, error);\n      } else {\n        this.emit(\"worker.job.interrupted\", job, error);\n      }\n    }\n  }\n\n  private async processJob(job: JobEntity<P, R>): Promise<void> {\n    const { originalUpdateProgress, originalAddLog } =\n      this._instrumentJobForWorker(job);\n\n    this.emit(\"worker.job.active\", job);\n    this.setupLockRenewal(job);\n\n    try {\n      await this._executeProcessor(job);\n    } finally {\n      this._activeJobs = 0;\n      this.clearLockRenewal(job.id.value);\n      job.updateProgress = originalUpdateProgress;\n      job.addLog = originalAddLog;\n    }\n  }\n\n  private setupLockRenewal(job: JobEntity<P, R>): void {\n    const renewBuffer =\n      this.opts.lockRenewTimeBuffer ?? this.opts.lockDuration / 2;\n    const renewInterval = this.opts.lockDuration - renewBuffer;\n\n    const timer = setInterval(() => {\n      this.queue.extendJobLock(job.id, this.workerId, this.opts.lockDuration);\n    }, renewInterval);\n\n    this.lockRenewTimers.set(job.id.value, timer);\n  }\n\n  private clearLockRenewal(jobId: string): void {\n    const timer = this.lockRenewTimers.get(jobId);\n    if (timer) {\n      clearInterval(timer);\n      this.lockRenewTimers.delete(jobId);\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/worker/worker.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/common/base.entity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/common/ports/repository.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/common/services/i-logger.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/common/value-objects/base.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/common/value-objects/identity.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/agent/agent-internal-state.entity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/agent/agent-persona-template.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/agent/agent.entity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/agent/ports/agent-internal-state-repository.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/agent/ports/agent-persona-template-repository.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/agent/ports/agent-repository.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/agent/value-objects/agent-id.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/agent/value-objects/agent-max-iterations.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/agent/value-objects/agent-temperature.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/agent/value-objects/internal-state/current-goal.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/agent/value-objects/internal-state/current-project-id.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/agent/value-objects/internal-state/general-notes.collection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/agent/value-objects/persona/persona-backstory.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/agent/value-objects/persona/persona-goal.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/agent/value-objects/persona/persona-id.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/agent/value-objects/persona/persona-name.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/agent/value-objects/persona/persona-role.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/agent/value-objects/persona/tool-names.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/agent/value-objects/target-agent-role.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/annotation/annotation.entity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/annotation/ports/annotation-repository.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/annotation/ports/annotation-repository.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/annotation/value-objects/annotation-id.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/annotation/value-objects/annotation-text.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/common/errors.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":14,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":14,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[464,467],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[464,467],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":16,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":16,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[590,593],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[590,593],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/job/__tests__/job-options.vo.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/job/__tests__/job.entity.serialization.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/job/__tests__/job.entity.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/job/__tests__/job.entity.state-transitions.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/job/job-persistence.mapper.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/job/job-processing.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/job/job-state.mutator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/job/job.entity.ts","messages":[{"ruleId":"max-lines","severity":2,"message":"File has too many lines (276). Maximum allowed is 200.","line":215,"column":1,"nodeType":null,"messageId":"exceed","endLine":299,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { AbstractEntity } from \"@/core/common/base.entity\";\n\nimport { ExecutionHistoryEntry } from \"./job-processing.types\";\nimport { JobStateMutator } from \"./job-state.mutator\";\nimport {\n  JobStatus,\n  JobLogEntry,\n  JobEntityProps,\n  // JobPersistenceData, // Not used directly in this file after refactor\n} from \"./job.types\";\nimport {\n  ActivityHistoryVO,\n  ActivityHistoryEntryVO,\n} from \"./value-objects/activity-history.vo\";\nimport { JobIdVO } from \"./value-objects/job-id.vo\";\nimport { IJobOptions, JobOptionsVO } from \"./value-objects/job-options.vo\";\n\nexport class JobEntity<P = unknown, R = unknown> extends AbstractEntity<\n  JobIdVO,\n  JobEntityProps<P, R>\n> {\n  private _progressChanged: boolean = false;\n  private _logsChanged: boolean = false;\n  private _stateMutator: JobStateMutator<P, R>;\n\n  private constructor(\n    props: JobEntityProps<P, R>,\n    initialConversationHistory?: ActivityHistoryVO,\n    initialExecutionHistory?: ExecutionHistoryEntry[]\n  ) {\n    super(props);\n    this._stateMutator = new JobStateMutator(\n      this.props,\n      initialConversationHistory,\n      initialExecutionHistory\n    );\n  }\n\n  public static create<P, R>(params: {\n    id?: JobIdVO;\n    queueName: string;\n    name: string;\n    payload: P;\n    options?: IJobOptions;\n  }): JobEntity<P, R> {\n    const jobOptions = JobOptionsVO.create(params.options);\n    const idFromOptions = jobOptions.jobId;\n    const finalJobId =\n      params.id ||\n      (idFromOptions ? JobIdVO.create(idFromOptions) : JobIdVO.create());\n    const now = new Date();\n\n    const props: JobEntityProps<P, R> = {\n      id: finalJobId,\n      queueName: params.queueName,\n      name: params.name,\n      payload: params.payload,\n      options: jobOptions,\n      status:\n        jobOptions.delay && jobOptions.delay > 0\n          ? JobStatus.DELAYED\n          : JobStatus.WAITING,\n      attemptsMade: 0,\n      progress: 0,\n      logs: [],\n      createdAt: now,\n      updatedAt: now,\n      delayUntil:\n        jobOptions.delay && jobOptions.delay > 0\n          ? new Date(now.getTime() + jobOptions.delay)\n          : undefined,\n    };\n    return new JobEntity<P, R>(props, ActivityHistoryVO.create(), []);\n  }\n\n  get id(): JobIdVO {\n    return this.props.id;\n  }\n  get queueName(): string {\n    return this.props.queueName;\n  }\n  get name(): string {\n    return this.props.name;\n  }\n  get payload(): P {\n    return this.props.payload;\n  }\n  get options(): JobOptionsVO {\n    return this.props.options;\n  }\n  get status(): JobStatus {\n    return this.props.status;\n  }\n  get attemptsMade(): number {\n    return this.props.attemptsMade;\n  }\n  get maxAttempts(): number {\n    return this.props.options.attempts;\n  }\n  get progress(): number | object {\n    return this.props.progress;\n  }\n  get logs(): ReadonlyArray<JobLogEntry> {\n    return this.props.logs;\n  }\n  get createdAt(): Date {\n    return this.props.createdAt;\n  }\n  get updatedAt(): Date {\n    return this.props.updatedAt;\n  }\n  get processedOn(): Date | undefined {\n    return this.props.processedOn;\n  }\n  get finishedOn(): Date | undefined {\n    return this.props.finishedOn;\n  }\n  get delayUntil(): Date | undefined {\n    return this.props.delayUntil;\n  }\n  get lockUntil(): Date | undefined {\n    return this.props.lockUntil;\n  }\n  get workerId(): string | undefined {\n    return this.props.workerId;\n  }\n  get returnValue(): R | undefined {\n    return this.props.returnValue;\n  }\n  get failedReason(): string | undefined {\n    return this.props.failedReason;\n  }\n  get stacktrace(): string[] | undefined {\n    return this.props.stacktrace;\n  }\n\n  get isRetry(): boolean {\n    if (this.props.status === JobStatus.ACTIVE) {\n      return this.props.attemptsMade > 1;\n    }\n    return (\n      this.props.attemptsMade > 0 &&\n      (this.props.status === JobStatus.WAITING ||\n        this.props.status === JobStatus.DELAYED) &&\n      this.props.failedReason !== undefined\n    );\n  }\n\n  get progressChanged(): boolean {\n    return this._progressChanged;\n  }\n  get logsChanged(): boolean {\n    return this._logsChanged;\n  }\n\n  public updateProgress(progress: number | object): void {\n    if (\n      this.status === JobStatus.COMPLETED ||\n      this.status === JobStatus.FAILED\n    ) {\n      console.warn(\n        `[JobEntity] Cannot update progress for job ${this.id.value} as it is already in status ${this.status}.`\n      );\n      return;\n    }\n    this.props.progress = progress;\n    this.props.updatedAt = new Date();\n    this._progressChanged = true;\n  }\n\n  public addLog(message: string, level: string = \"INFO\"): void {\n    this.props.logs.push({ message, level, timestamp: new Date() });\n    this.props.updatedAt = new Date();\n    this._logsChanged = true;\n  }\n\n  public clearChangeFlags(): void {\n    this._progressChanged = false;\n    this._logsChanged = false;\n  }\n\n  public moveToActive(workerId: string, lockUntil: Date): void {\n    this._stateMutator.moveToActive(workerId, lockUntil);\n  }\n  public extendLock(newLockUntil: Date, workerId: string): void {\n    this._stateMutator.extendLock(newLockUntil, workerId);\n  }\n  public markAsCompleted(returnValue: R): void {\n    this._stateMutator.markAsCompleted(returnValue);\n  }\n  public markAsFailed(reason: string, stacktrace?: string[]): void {\n    this._stateMutator.markAsFailed(reason, stacktrace);\n  }\n  public moveToDelayed(delayUntil: Date, originalError?: Error): void {\n    this._stateMutator.moveToDelayed(delayUntil, originalError);\n  }\n  public moveToWaiting(): void {\n    this._stateMutator.moveToWaiting();\n  }\n\n  public markAsStalled(): boolean {\n    const shouldFail = this._stateMutator.markAsStalled();\n    if (shouldFail) {\n      this.addLog(\n        `Job failed after becoming stalled and exceeding max attempts. (worker: ${this.props.workerId}, lock expired: ${this.props.lockUntil})`,\n        \"ERROR\"\n      );\n    } else {\n      this.addLog(\n        `Job marked as stalled (worker: ${this.props.workerId}, lock expired: ${this.props.lockUntil})`,\n        \"WARN\"\n      );\n    }\n    return shouldFail;\n  }\n  public pause(): void {\n    this._stateMutator.pause();\n  }\n  public resume(): void {\n    this._stateMutator.resume();\n  }\n\n  public toPersistence(): {\n    id: string;\n    queueName: string;\n    name: string;\n    payload: P;\n    options: IJobOptions;\n    status: JobStatus;\n    attemptsMade: number;\n    progress: number | object;\n    logs: Array<{ message: string; level: string; timestamp: number }>;\n    createdAt: Date;\n    updatedAt: Date;\n    priority: number;\n    processedOn?: Date;\n    finishedOn?: Date;\n    delayUntil?: Date;\n    lockUntil?: Date;\n    workerId?: string;\n    returnValue?: R;\n    failedReason?: string;\n    stacktrace?: string[];\n  } {\n    return {\n      id: this.props.id.value,\n      queueName: this.props.queueName,\n      name: this.props.name,\n      payload: this.props.payload,\n      options: this.props.options.toPersistence(),\n      status: this.props.status,\n      attemptsMade: this.props.attemptsMade,\n      progress: this.props.progress,\n      logs: this.props.logs.map((logEntry) => ({\n        ...logEntry,\n        timestamp: logEntry.timestamp.getTime(),\n      })),\n      createdAt: this.props.createdAt,\n      updatedAt: this.props.updatedAt,\n      priority: this.props.options.priority,\n\n      ...(this.props.processedOn && { processedOn: this.props.processedOn }),\n      ...(this.props.finishedOn && { finishedOn: this.props.finishedOn }),\n      ...(this.props.delayUntil && { delayUntil: this.props.delayUntil }),\n      ...(this.props.lockUntil && { lockUntil: this.props.lockUntil }),\n      ...(this.props.workerId && { workerId: this.props.workerId }),\n      ...(this.props.returnValue !== undefined && {\n        returnValue: this.props.returnValue,\n      }),\n      ...(this.props.failedReason && { failedReason: this.props.failedReason }),\n      ...(this.props.stacktrace && { stacktrace: this.props.stacktrace }),\n    };\n  }\n\n  public getConversationHistory(): ActivityHistoryVO {\n    return this._stateMutator.getConversationHistory();\n  }\n\n  public addConversationEntry(entry: ActivityHistoryEntryVO): void {\n    this._stateMutator.addConversationEntry(entry);\n  }\n\n  public getExecutionHistory(): ReadonlyArray<ExecutionHistoryEntry> {\n    return this._stateMutator.getExecutionHistory();\n  }\n\n  public addExecutionHistoryEntry(entry: ExecutionHistoryEntry): void {\n    this._stateMutator.addExecutionHistoryEntry(entry);\n  }\n\n  public setConversationHistory(history: ActivityHistoryVO): void {\n    this._stateMutator.setConversationHistory(history);\n  }\n\n  public setExecutionHistory(history: ExecutionHistoryEntry[]): void {\n    this._stateMutator.setExecutionHistory(history);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/job/job.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/job/utils/calculate-backoff.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/job/value-objects/__tests__/job-id.vo.spec.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`uuid` import should occur before import of `vitest`","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":49,"fix":{"range":[0,96],"text":"import { validate as uuidValidate } from \"uuid\";\nimport { describe, it, expect } from \"vitest\";\n"}},{"ruleId":"import/no-unresolved","severity":2,"message":"Unable to resolve path to module 'uuid'.","line":2,"column":42,"nodeType":"Literal","endLine":2,"endColumn":48}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { describe, it, expect } from \"vitest\";\nimport { validate as uuidValidate } from \"uuid\";\n\nimport { JobIdVO } from \"../job-id.vo\";\n\ndescribe(\"JobIdVO\", () => {\n  it(\"should create a JobIdVO with a valid UUID v4 if no id is provided\", () => {\n    const jobId = JobIdVO.create();\n    expect(jobId).toBeInstanceOf(JobIdVO);\n  });\n\n  it(\"should create a JobIdVO with a provided valid UUID\", () => {\n    const validUuid = \"7f6c6a90-4d8a-4f1e-9b0a-7b1d7e4c8a2b\";\n    const jobId = JobIdVO.create(validUuid);\n    expect(jobId).toBeInstanceOf(JobIdVO);\n    expect(jobId.value).toBe(validUuid);\n  });\n\n  it(\"should throw an error if a provided id is not a valid UUID\", () => {\n    const invalidUuid = \"invalid-uuid\";\n    expect(() => JobIdVO.create(invalidUuid)).toThrow(\n      \"Invalid Job ID format (must be a valid UUID v4).\"\n    ); // Corrected message\n  });\n\n  it(\"equals should return true for JobIdVOs with the same id\", () => {\n    const uuid = \"c1b2a3f4-1b2c-4d5e-8f6a-1b2c3d4e5f6a\";\n    const jobId1 = JobIdVO.create(uuid);\n    const jobId2 = JobIdVO.create(uuid);\n    expect(jobId1.equals(jobId2)).toBe(true);\n  });\n\n  it(\"equals should return false for JobIdVOs with different ids\", () => {\n    const jobId1 = JobIdVO.create();\n    const jobId2 = JobIdVO.create();\n    expect(jobId1.equals(jobId2)).toBe(false);\n  });\n\n  it(\"equals should return false when compared with null or undefined\", () => {\n    const jobId = JobIdVO.create();\n    expect(jobId.equals(null)).toBe(false); // Removed 'as any'\n    expect(jobId.equals(undefined)).toBe(false); // Removed 'as any'\n  });\n\n  it(\"should allow node:crypto.randomUUID() to be used if uuid library is not available (conceptual check)\", () => {\n    // This test is more about ensuring the VO doesn't strictly depend on the 'uuid' library's specific output\n    // if node:crypto is the fallback or primary. Both generate valid UUIDs.\n    const cryptoGeneratedId = JobIdVO.create(); // Uses node:crypto.randomUUID() internally\n    expect(uuidValidate(cryptoGeneratedId.value)).toBe(true);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/job/value-objects/__tests__/job-options.vo.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/job/value-objects/activity-history-entry.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/job/value-objects/activity-history.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/job/value-objects/job-id.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/job/value-objects/job-options.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/llm-provider-config/llm-provider-config.entity.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'id' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":45,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":45,"endColumn":15,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/llm-provider-config/ports/llm-provider-config-repository.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/llm-provider-config/value-objects/llm-api-key.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/llm-provider-config/value-objects/llm-provider-config-id.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/llm-provider-config/value-objects/llm-provider-config-name.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/llm-provider-config/value-objects/llm-provider-id.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/memory/memory-item.entity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/memory/ports/memory-repository.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/memory/ports/memory-repository.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/memory/value-objects/memory-item-content.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/memory/value-objects/memory-item-embedding.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/memory/value-objects/memory-item-id.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/memory/value-objects/memory-item-source.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/memory/value-objects/memory-item-tags.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/project/ports/project-repository.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/project/project.entity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/project/value-objects/project-description.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/project/value-objects/project-id.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/project/value-objects/project-name.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/source-code/ports/source-code-repository.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/source-code/source-code.entity.ts","messages":[{"ruleId":"no-inline-comments","severity":2,"message":"Unexpected comment inline with code.","line":22,"column":47,"nodeType":"Line","messageId":"unexpectedInlineComment","endLine":22,"endColumn":94}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ProjectId } from \"../project/value-objects/project-id.vo\";\n\nimport { RepositoryDocsPath } from \"./value-objects/repository-docs-path.vo\";\nimport { RepositoryId } from \"./value-objects/repository-id.vo\";\nimport { RepositoryPath } from \"./value-objects/repository-path.vo\";\n\ninterface SourceCodeProps {\n  id: RepositoryId;\n  projectId: ProjectId;\n  path: RepositoryPath;\n  docsPath?: RepositoryDocsPath;\n  // createdAt: Date;\n  // updatedAt: Date;\n}\n\nexport class SourceCode {\n  private readonly _id: RepositoryId;\n  private readonly props: Readonly<Omit<SourceCodeProps, \"id\">>;\n\n  private constructor(props: SourceCodeProps) {\n    this._id = props.id;\n    const { id: _id, ...otherProps } = props; // _id is unused, props.id is used for this._id\n    this.props = Object.freeze(otherProps);\n  }\n\n  public static create(props: {\n    id?: RepositoryId;\n    projectId: ProjectId;\n    path: RepositoryPath;\n    docsPath?: RepositoryDocsPath;\n  }): SourceCode {\n    const repoId = props.id || RepositoryId.generate();\n    return new SourceCode({\n      id: repoId,\n      projectId: props.projectId,\n      path: props.path,\n      docsPath: props.docsPath,\n      // createdAt: new Date(),\n      // updatedAt: new Date(),\n    });\n  }\n\n  public id(): RepositoryId {\n    return this._id;\n  }\n\n  public projectId(): ProjectId {\n    return this.props.projectId;\n  }\n\n  public path(): RepositoryPath {\n    return this.props.path;\n  }\n\n  public docsPath(): RepositoryDocsPath | undefined {\n    return this.props.docsPath;\n  }\n\n  public equals(other?: SourceCode): boolean {\n    if (other === null || other === undefined) {\n      return false;\n    }\n    if (!(other instanceof SourceCode)) {\n      return false;\n    }\n    return this._id.equals(other._id);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/source-code/value-objects/repository-docs-path.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/source-code/value-objects/repository-id.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/source-code/value-objects/repository-path.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/user/ports/user-repository.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/user/user.entity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/user/value-objects/user-avatar.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/user/value-objects/user-email.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/user/value-objects/user-id.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/user/value-objects/user-nickname.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/user/value-objects/user-username.vo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/ports/adapters/file-system.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/ports/adapters/job-queue.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/ports/adapters/llm-adapter.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/ports/adapters/llm-adapter.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/ports/adapters/version-control-system.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/tools/tool.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/examples/queue-usage-example.final.ts","messages":[{"ruleId":"max-lines-per-function","severity":2,"message":"Function 'setupEventListeners' has too many lines (51). Maximum allowed is 50.","line":55,"column":1,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":106,"endColumn":2},{"ruleId":"no-inline-comments","severity":2,"message":"Unexpected comment inline with code.","line":138,"column":14,"nodeType":"Line","messageId":"unexpectedInlineComment","endLine":138,"endColumn":42}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src_refactored/examples/queue-usage-example.final.ts\nimport { WorkerService } from \"@/core/application/worker/worker.service\";\nimport { JobEntity } from \"@/core/domain/job/job.entity\";\n\nimport { db } from \"@/infrastructure/persistence/drizzle/drizzle.client\";\nimport { DrizzleJobRepository } from \"@/infrastructure/persistence/drizzle/job/drizzle-job.repository\";\nimport { QueueService } from \"@/infrastructure/queue/drizzle/queue.service\";\n\ntype EmailJobPayload = { email: string };\ntype EmailJobResult = { status: string };\n\nfunction setupProcessor(): (\n  job: JobEntity<EmailJobPayload, EmailJobResult>\n) => Promise<EmailJobResult> {\n  return async (\n    job: JobEntity<EmailJobPayload, EmailJobResult>\n  ): Promise<EmailJobResult> => {\n    process.stdout.write(\n      `[Worker] Processing job ${job.id.value} (attempt ${job.attemptsMade}) for email: ${job.payload.email}\\n`\n    );\n\n    for (let progressValue = 0; progressValue <= 100; progressValue += 25) {\n      await new Promise((resolve) => setTimeout(resolve, 500));\n      job.updateProgress(progressValue);\n      job.addLog(`Progress updated to ${progressValue}%`);\n      process.stdout.write(\n        `[Worker] Job ${job.id.value} progress: ${progressValue}%\\n`\n      );\n    }\n\n    if (job.attemptsMade < 3 && job.payload.email === \"retry@example.com\") {\n      job.addLog(\"Simulating transient failure for retry job.\", \"ERROR\");\n      process.stdout.write(\n        `[Worker] Job ${job.id.value} (retry job) failed. Attempts made: ${job.attemptsMade}\\n`\n      );\n      throw new Error(\"Simulated transient error\");\n    }\n\n    if (job.payload.email === \"fail@example.com\") {\n      job.addLog(\"Simulating permanent failure.\", \"ERROR\");\n      process.stdout.write(\n        `[Worker] Job ${job.id.value} (fail job) failed permanently.\\n`\n      );\n      throw new Error(\"Simulated permanent error\");\n    }\n\n    job.addLog(\"Job completed successfully.\", \"INFO\");\n    process.stdout.write(\n      `[Worker] Job ${job.id.value} completed successfully.\\n`\n    );\n    return { status: \"Email sent\" };\n  };\n}\n\nfunction setupEventListeners(\n  queue: QueueService<EmailJobPayload, EmailJobResult>,\n  worker: WorkerService<EmailJobPayload, EmailJobResult>\n): void {\n  queue.on(\"job.added\", (job) =>\n    process.stdout.write(\n      `[Queue] Job added: ${job.id.value} (Name: ${job.name}, Status: ${job.status})\\n`\n    )\n  );\n  queue.on(\"job.completed\", (job) =>\n    process.stdout.write(\n      `[Queue] Job completed: ${job.id.value} (Result: ${JSON.stringify(job.returnValue)})\\n`\n    )\n  );\n  queue.on(\"job.failed\", (job) =>\n    process.stdout.write(\n      `[Queue] Job failed: ${job.id.value} (Reason: ${job.failedReason}, Attempts: ${job.attemptsMade})\\n`\n    )\n  );\n  queue.on(\"job.active\", (job) =>\n    process.stdout.write(`[Queue] Job ${job.id.value} is now active.\\n`)\n  );\n  queue.on(\"job.stalled\", (job) =>\n    process.stdout.write(`[Queue] Job ${job.id.value} stalled and re-queued.\\n`)\n  );\n  queue.on(\"job.progress\", (job) =>\n    process.stdout.write(\n      `[Queue] Job ${job.id.value} progress updated to ${job.progress}\\n`\n    )\n  );\n  queue.on(\"job.log\", (job) =>\n    process.stdout.write(\n      `[Queue] Job ${job.id.value} log: ${job.logs[job.logs.length - 1].message}\\n`\n    )\n  );\n\n  worker.on(\"worker.job.active\", (job) =>\n    process.stdout.write(\n      `[Worker] Worker started processing job: ${job.id.value}\\n`\n    )\n  );\n  worker.on(\"worker.job.processed\", (job) =>\n    process.stdout.write(\n      `[Worker] Worker finished processing job: ${job.id.value}\\n`\n    )\n  );\n  worker.on(\"worker.job.errored\", (job, error) =>\n    process.stdout.write(\n      `[Worker] Worker encountered error for job ${job.id.value}: ${error.message}\\n`\n    )\n  );\n}\n\nasync function addJobsAndRun(\n  queue: QueueService<EmailJobPayload, EmailJobResult>,\n  worker: WorkerService<EmailJobPayload, EmailJobResult>\n): Promise<void> {\n  await queue.add(\"send-email\", { email: \"success@example.com\" });\n  await queue.add(\n    \"send-email\",\n    { email: \"delayed@example.com\" },\n    { delay: 7000 }\n  );\n  await queue.add(\n    \"send-email\",\n    { email: \"retry@example.com\" },\n    { attempts: 3, backoff: { type: \"exponential\", delay: 1000 } }\n  );\n  await queue.add(\"send-email\", { email: \"fail@example.com\" }, { attempts: 1 });\n\n  worker.run();\n  queue.startMaintenance();\n\n  process.stdout.write(\n    \"Queue and Worker started. Waiting for jobs to complete...\\n\"\n  );\n\n  setTimeout(async () => {\n    process.stdout.write(\"Shutting down worker and queue...\\n\");\n    await worker.close();\n    await queue.close();\n    process.stdout.write(\"Worker and queue closed. Exiting.\\n\");\n    process.exit(0);\n  }, 60000); // Keep alive for 60 seconds\n}\n\nasync function main() {\n  const jobRepository = new DrizzleJobRepository(db);\n  const queue = new QueueService<EmailJobPayload, EmailJobResult>(\n    \"default\",\n    jobRepository\n  );\n  const processor = setupProcessor();\n  const worker = new WorkerService(queue, processor, {\n    concurrency: 2,\n    lockDuration: 15000,\n    lockRenewTimeBuffer: 5000,\n  });\n\n  setupEventListeners(queue, worker);\n  await addJobsAndRun(queue, worker);\n}\n\nprocess.on(\"unhandledRejection\", (reason, promise) => {\n  console.error(\"Unhandled Rejection at:\", promise, \"reason:\", reason);\n  // Application specific logging, throwing an error, or other logic here\n});\n\nprocess.on(\"uncaughtException\", (error) => {\n  console.error(\"Uncaught Exception:\", error);\n  // Application specific logging, throwing an error, or other logic here\n  process.exit(1);\n});\n\nmain().catch((err) => {\n  console.error(\"Error in main execution:\", err);\n  process.exit(1);\n});\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/adapters/llm/mock-llm.adapter.ts","messages":[{"ruleId":"no-inline-comments","severity":2,"message":"Unexpected comment inline with code.","line":77,"column":55,"nodeType":"Line","messageId":"unexpectedInlineComment","endLine":77,"endColumn":99},{"ruleId":"no-inline-comments","severity":2,"message":"Unexpected comment inline with code.","line":99,"column":23,"nodeType":"Line","messageId":"unexpectedInlineComment","endLine":99,"endColumn":44}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { injectable, inject } from \"inversify\";\nimport { z } from \"zod\";\n\nimport {\n  ILoggerService,\n  LoggerServiceToken,\n} from \"@/core/common/services/i-logger.service\";\nimport { LLMError } from \"@/core/domain/common/errors\";\nimport { ILLMAdapter } from \"@/core/ports/adapters/llm-adapter.interface\";\nimport {\n  LLMGenerationOptions,\n  LanguageModelMessage,\n} from \"@/core/ports/adapters/llm-adapter.types\";\n\nimport { Result, Ok, Err } from \"@/shared/result\";\n\n@injectable()\nexport class MockLLMAdapter implements ILLMAdapter {\n  constructor(\n    @inject(LoggerServiceToken) private readonly logger: ILoggerService\n  ) {\n    this.logger.info(\"[MockLLMAdapter] Initialized\");\n  }\n\n  async generateText(\n    messages: LanguageModelMessage[],\n    options?: LLMGenerationOptions\n  ): Promise<Result<LanguageModelMessage, LLMError>> {\n    this.logger.info(\"[MockLLMAdapter] generateText called\", {\n      messages,\n      options,\n    });\n    const lastUserMessage = messages\n      .filter((message) => message.role === \"user\")\n      .pop();\n    const responseContent = `Mock response to: ${lastUserMessage?.content || \"your request\"}. Options: ${JSON.stringify(options || {})}`;\n\n    // Simulate tool call if prompt asks for it\n    if (lastUserMessage?.content?.toLowerCase().includes(\"use tool\")) {\n      return Ok({\n        role: \"assistant\",\n        content: null,\n        tool_calls: [\n          {\n            id: \"tool_call_mock_123\",\n            type: \"function\",\n            function: {\n              name: \"example.tool\",\n              arguments: JSON.stringify({\n                message: \"hello from mock tool call\",\n              }),\n            },\n          },\n        ],\n      });\n    }\n\n    return Ok({\n      role: \"assistant\",\n      content: responseContent,\n    });\n  }\n\n  async generateStructuredOutput<S extends z.ZodTypeAny>(\n    prompt: string,\n    schema: S,\n    options?: LLMGenerationOptions\n  ): Promise<Result<z.infer<S>, LLMError>> {\n    this.logger.info(\"[MockLLMAdapter] generateStructuredOutput called\", {\n      prompt,\n      schemaDef: schema.description,\n      options,\n    });\n    // Try to return a mock object that somewhat fits common schemas, or a default based on schema type\n    try {\n      if (schema instanceof z.ZodObject) {\n        const mockData: Record<string, unknown> = {}; // Replaced any with Record<string, unknown>\n        for (const key in schema.shape) {\n          const fieldSchema = schema.shape[key];\n          if (fieldSchema instanceof z.ZodString) {\n            mockData[key] = `mock string for ${key}`;\n          } else if (fieldSchema instanceof z.ZodNumber) {\n            mockData[key] = 123;\n          } else if (fieldSchema instanceof z.ZodBoolean) {\n            mockData[key] = true;\n          } else {\n            mockData[key] = null;\n          }\n        }\n        const validation = schema.safeParse(mockData);\n        if (validation.success) return Ok(validation.data);\n        return Err(\n          new LLMError(\n            \"Failed to generate mock structured output matching schema.\",\n            validation.error\n          )\n        );\n      }\n    } catch (error) { // Renamed e to error\n      return Err(\n        new LLMError(\n          \"Error generating mock structured output for schema.\",\n          error instanceof Error ? error : undefined\n        )\n      );\n    }\n    return Err(\n      new LLMError(\n        \"Mock structured output for this schema type not implemented.\"\n      )\n    );\n  }\n\n  async *streamText(\n    prompt: string,\n    options?: LLMGenerationOptions\n  ): AsyncGenerator<Result<string, LLMError>> {\n    this.logger.info(\"[MockLLMAdapter] streamText called\", { prompt, options });\n    const response = `Mock streamed response to: ${prompt}. Options: ${JSON.stringify(options || {})}`;\n    const words = response.split(\" \");\n    for (const word of words) {\n      await new Promise((resolve) => setTimeout(resolve, 50));\n      yield Ok(word + \" \");\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/ioc/inversify.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/ioc/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/persistence/drizzle/drizzle.client.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/persistence/drizzle/job/__tests__/drizzle-job.repository.spec.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be no empty line within import group","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":40,"fix":{"range":[412,413],"text":""}},{"ruleId":"max-lines","severity":2,"message":"File has too many lines (310). Maximum allowed is 200.","line":241,"column":1,"nodeType":null,"messageId":"exceed","endLine":369,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import BetterSqlite3 from \"better-sqlite3\";\nimport { drizzle, BetterSQLite3Database } from \"drizzle-orm/better-sqlite3\";\nimport { migrate } from \"drizzle-orm/better-sqlite3/migrator\";\nimport { describe, it, expect, beforeEach, beforeAll, afterAll } from \"vitest\";\n\nimport { JobEntity, JobStatus } from \"@/core/domain/job/job.entity\";\n\nimport * as schema from \"../../schema\"; // Adjusted path to be two levels up\n\nimport { DrizzleJobRepository } from \"../drizzle-job.repository\"; // Adjusted path to be one level up\n\n// Define more specific types for payload and result for these tests\ninterface TestJobPayload {\n  data?: string;\n  order?: number;\n  newData?: string;\n  [key: string]: unknown;\n}\ninterface TestJobResult {\n  [key: string]: unknown;\n}\n\n// Helper function to create a job entity for tests\nconst createTestJob = (\n  props: Partial<\n    Parameters<typeof JobEntity.create<TestJobPayload, TestJobResult>>[0]\n  > = {}\n): JobEntity<TestJobPayload, TestJobResult> => {\n  return JobEntity.create<TestJobPayload, TestJobResult>({\n    queueName: \"test-queue\",\n    name: \"test-job-name\",\n    payload: { data: \"sample\" },\n    options: { priority: 10, attempts: 1 },\n    ...props,\n  });\n};\n\n// Variables for shared test context\nlet testDb: BetterSQLite3Database<typeof schema>;\nlet sqliteInstance: BetterSqlite3.Database;\nlet repository: DrizzleJobRepository;\n\nbeforeAll(() => {\n  sqliteInstance = new BetterSqlite3(\":memory:\");\n  testDb = drizzle(sqliteInstance, { schema });\n  migrate(testDb, {\n    migrationsFolder:\n      \"./src_refactored/infrastructure/persistence/drizzle/migrations\",\n  });\n});\n\nafterAll(() => {\n  sqliteInstance.close();\n});\n\nbeforeEach(async () => {\n  // Ensure repository is new for each test, and tables are clean\n  repository = new DrizzleJobRepository(testDb);\n  await testDb.delete(schema.jobsTable);\n});\n\ndescribe(\"DrizzleJobRepository - save and findById\", () => {\n  it(\"should save a new job and find it by ID\", async () => {\n    const job = createTestJob();\n      await repository.save(job);\n\n      const foundJob = await repository.findById(job.id);\n      expect(foundJob).not.toBeNull();\n      expect(foundJob!.id.equals(job.id)).toBe(true);\n      expect(foundJob!.name).toBe(job.name);\n      expect(foundJob!.payload).toEqual(job.payload);\n    });\n\n    it(\"save should update an existing job (upsert behavior)\", async () => {\n      const job = createTestJob();\n      await repository.save(job);\n\n      job.updateProgress(50);\n      (job.payload as TestJobPayload).newData = \"updated\";\n      await repository.save(job);\n\n      const foundJob = (await repository.findById(job.id)) as JobEntity<\n        TestJobPayload,\n        TestJobResult\n      > | null;\n      expect(foundJob).not.toBeNull();\n      expect(foundJob!.progress).toBe(50);\n      expect(foundJob!.payload.newData).toBe(\"updated\");\n    });\n  });\n\n  describe(\"update\", () => {\n    it(\"should update an existing job properties\", async () => {\n      const job = createTestJob();\n      await repository.save(job);\n\n      job.updateProgress(75);\n      job.addLog(\"Update log\");\n      await repository.update(job);\n\n      const updatedJob = await repository.findById(job.id);\n      expect(updatedJob).not.toBeNull();\n      expect(updatedJob!.progress).toBe(75);\n      expect(updatedJob!.logs.length).toBe(1);\n      expect(updatedJob!.logs[0].message).toBe(\"Update log\");\n    });\n  });\n\n  describe(\"findNextJobsToProcess\", () => {\n    it(\"should find WAITING jobs ordered by priority then createdAt\", async () => {\n      const job1 = createTestJob({ options: { priority: 5 } });\n      const job2 = createTestJob({ options: { priority: 10 } });\n      const job3Delayed = createTestJob({\n        options: { priority: 1, delay: 10000 },\n      });\n\n      await repository.save(job2);\n      await repository.save(job1);\n      await repository.save(job3Delayed);\n\n      const nextJobs = await repository.findNextJobsToProcess(\"test-queue\", 3);\n      expect(nextJobs.length).toBe(2);\n      expect(nextJobs[0].id.equals(job1.id)).toBe(true);\n      expect(nextJobs[1].id.equals(job2.id)).toBe(true);\n    });\n\n    it(\"should find DELAYED jobs whose delayUntil has passed\", async () => {\n      const pastDelay = new Date(Date.now() - 5000);\n      const jobDelayedPast = createTestJob({ options: { delay: 1 } });\n      (\n        jobDelayedPast.props as {\n          createdAt: Date;\n          delayUntil: Date;\n          status: JobStatus;\n        }\n      ).createdAt = new Date(Date.now() - 10000);\n      (jobDelayedPast.props as { delayUntil: Date }).delayUntil = pastDelay;\n      (jobDelayedPast.props as { status: JobStatus }).status =\n        JobStatus.DELAYED;\n      await repository.save(jobDelayedPast);\n\n      const nextJobs = await repository.findNextJobsToProcess(\"test-queue\", 1);\n      expect(nextJobs.length).toBe(1);\n      expect(nextJobs[0].id.equals(jobDelayedPast.id)).toBe(true);\n    });\n  });\n\n  describe(\"acquireLock and extendLock\", () => {\n    it(\"should acquire a lock for an available job\", async () => {\n      const job = createTestJob();\n      await repository.save(job);\n\n      const workerId = \"worker-1\";\n      const lockUntil = new Date(Date.now() + 30000);\n      const locked = await repository.acquireLock(job.id, workerId, lockUntil);\n      expect(locked).toBe(true);\n\n      const lockedJob = await repository.findById(job.id);\n      expect(lockedJob!.status).toBe(JobStatus.ACTIVE);\n      expect(lockedJob!.workerId).toBe(workerId);\n      expect(lockedJob!.lockUntil!.getTime()).toBeCloseTo(lockUntil.getTime());\n    });\n\n    it(\"should not acquire a lock if job is already locked by another worker\", async () => {\n      const job = createTestJob();\n      await repository.save(job);\n      await repository.acquireLock(\n        job.id,\n        \"worker-1\",\n        new Date(Date.now() + 30000)\n      );\n\n      const lockedByOther = await repository.acquireLock(\n        job.id,\n        \"worker-2\",\n        new Date(Date.now() + 30000)\n      );\n      expect(lockedByOther).toBe(false);\n    });\n\n    it(\"should acquire a lock if existing lock has expired\", async () => {\n      const job = createTestJob();\n      await repository.save(job);\n      await repository.acquireLock(\n        job.id,\n        \"worker-1\",\n        new Date(Date.now() - 1000)\n      );\n\n      const acquired = await repository.acquireLock(\n        job.id,\n        \"worker-2\",\n        new Date(Date.now() + 30000)\n      );\n      expect(acquired).toBe(true);\n      const lockedJob = await repository.findById(job.id);\n      expect(lockedJob!.workerId).toBe(\"worker-2\");\n    });\n\n    it(\"should extend an existing lock\", async () => {\n      const job = createTestJob();\n      await repository.save(job);\n      const workerId = \"worker-1\";\n      await repository.acquireLock(\n        job.id,\n        workerId,\n        new Date(Date.now() + 10000)\n      );\n\n      const newLockUntil = new Date(Date.now() + 60000);\n      await repository.extendLock(job.id, workerId, newLockUntil);\n\n      const extendedLockJob = await repository.findById(job.id);\n      expect(extendedLockJob!.lockUntil!.getTime()).toBeCloseTo(\n        newLockUntil.getTime()\n      );\n    });\n  });\n\n  describe(\"findStalledJobs\", () => {\n    it(\"should find active jobs whose lock has expired\", async () => {\n      const job = createTestJob();\n      await repository.save(job);\n\n      const workerId = \"worker-stalled\";\n      const expiredLockUntil = new Date(Date.now() - 1000);\n      job.moveToActive(workerId, expiredLockUntil);\n      await repository.update(job);\n\n      const stalledJobs = await repository.findStalledJobs(\n        \"test-queue\",\n        new Date(),\n        1\n      );\n      expect(stalledJobs.length).toBe(1);\n      expect(stalledJobs[0].id.equals(job.id)).toBe(true);\n    });\n  });\n\n  describe(\"remove\", () => {\n    it(\"should remove a job from the repository\", async () => {\n      const job = createTestJob();\n      await repository.save(job);\n      await repository.remove(job.id);\n      const foundJob = await repository.findById(job.id);\n      expect(foundJob).toBeNull();\n    });\n  });\n\n  describe(\"getJobsByStatus\", () => {\n    it(\"should retrieve jobs by specified statuses with pagination and ordering\", async () => {\n      const jobW1 = createTestJob({ payload: { order: 1 } });\n      const jobW2 = createTestJob({ payload: { order: 2 } });\n      const jobA1 = createTestJob({ payload: { order: 3 } });\n      jobA1.moveToActive(\"w1\", new Date(Date.now() + 1000));\n\n      await repository.save(jobW1);\n      await repository.save(jobA1);\n      await repository.save(jobW2);\n\n      const waitingJobs = await repository.getJobsByStatus(\n        \"test-queue\",\n        [JobStatus.WAITING],\n        0,\n        10,\n        true\n      ); // asc\n      expect(waitingJobs.length).toBe(2);\n      expect(waitingJobs[0].id.equals(jobW1.id)).toBe(true);\n      expect(waitingJobs[1].id.equals(jobW2.id)).toBe(true);\n\n      const activeJobs = await repository.getJobsByStatus(\n        \"test-queue\",\n        [JobStatus.ACTIVE],\n        0,\n        1\n      );\n      expect(activeJobs.length).toBe(1);\n      expect(activeJobs[0].id.equals(jobA1.id)).toBe(true);\n    });\n  });\n\n  describe(\"countJobsByStatus\", () => {\n    it(\"should count jobs by their status\", async () => {\n      await repository.save(createTestJob());\n      const activeJob = createTestJob();\n      activeJob.moveToActive(\"w1\", new Date(Date.now() + 1000));\n      await repository.save(activeJob);\n\n      const counts = await repository.countJobsByStatus(\"test-queue\");\n      expect(counts[JobStatus.WAITING]).toBe(2);\n      expect(counts[JobStatus.ACTIVE]).toBe(1);\n      expect(counts[JobStatus.COMPLETED]).toBeUndefined();\n    });\n  });\n\n  describe(\"clean\", () => {\n    it(\"should clean old completed jobs respecting limit and grace period\", async () => {\n      const veryOldDate = new Date(Date.now() - 2 * 24 * 60 * 60 * 1000);\n      const recentDate = new Date(Date.now() - 10 * 60 * 1000);\n\n      const jobOld = createTestJob({ name: \"old\" });\n      jobOld.moveToActive(\"w\", new Date());\n      jobOld.markAsCompleted({});\n      (jobOld.props as { finishedOn: Date }).finishedOn = veryOldDate;\n      await repository.save(jobOld);\n\n      const jobRecent = createTestJob({ name: \"recent\" });\n      jobRecent.moveToActive(\"w\", new Date());\n      jobRecent.markAsCompleted({});\n      (jobRecent.props as { finishedOn: Date }).finishedOn = recentDate;\n      await repository.save(jobRecent);\n\n      const jobFailedOld = createTestJob({ name: \"failedOld\" });\n      jobFailedOld.moveToActive(\"w\", new Date());\n      jobFailedOld.markAsFailed(\"err\");\n      (jobFailedOld.props as { finishedOn: Date }).finishedOn = veryOldDate;\n      await repository.save(jobFailedOld);\n\n      const cleanedCount = await repository.clean(\n        \"test-queue\",\n        24 * 60 * 60 * 1000,\n        1,\n        JobStatus.COMPLETED\n      );\n      expect(cleanedCount).toBe(1);\n\n      const foundOld = await repository.findById(jobOld.id);\n      expect(foundOld).toBeNull();\n      const foundRecent = await repository.findById(jobRecent.id);\n      expect(foundRecent).not.toBeNull();\n      const foundFailedOld = await repository.findById(jobFailedOld.id);\n      expect(foundFailedOld).not.toBeNull();\n    });\n\n    it(\"should clean old completed or failed jobs if status is not specified\", async () => {\n      const oldDate = new Date(Date.now() - 2 * 24 * 60 * 60 * 1000);\n      const jobCompletedOld = createTestJob({ name: \"c-old\" });\n      jobCompletedOld.moveToActive(\"w\", new Date());\n      jobCompletedOld.markAsCompleted({});\n      (jobCompletedOld.props as { finishedOn: Date }).finishedOn = oldDate;\n      await repository.save(jobCompletedOld);\n\n      const jobFailedOld = createTestJob({ name: \"f-old\" });\n      jobFailedOld.moveToActive(\"w\", new Date());\n      jobFailedOld.markAsFailed(\"err\");\n      (jobFailedOld.props as { finishedOn: Date }).finishedOn = oldDate;\n      await repository.save(jobFailedOld);\n\n      const jobWaiting = createTestJob({ name: \"w-old\" });\n      (jobWaiting.props as { createdAt: Date; finishedOn?: Date }).createdAt =\n        oldDate;\n      (jobWaiting.props as { finishedOn?: Date }).finishedOn = undefined;\n      await repository.save(jobWaiting);\n\n      const cleanedCount = await repository.clean(\n        \"test-queue\",\n        24 * 60 * 60 * 1000,\n        5\n      );\n      expect(cleanedCount).toBe(2);\n\n      expect(await repository.findById(jobCompletedOld.id)).toBeNull();\n      expect(await repository.findById(jobFailedOld.id)).toBeNull();\n      expect(await repository.findById(jobWaiting.id)).not.toBeNull();\n    });\n  });\n// Removed the all-encompassing describe block, tests are now top-level describes\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/persistence/drizzle/job/drizzle-job.mapper.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":63,"fix":{"range":[204,204],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@/core/domain/job/job.entity` import should occur before import of `@/core/domain/job/job.types`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":63,"fix":{"range":[58,205],"text":"import { JobPersistence } from \"@/core/domain/job/job.entity\";\nimport {\n  IJobOptions,\n  JobPersistenceData,\n} from \"@/core/domain/job/job.types\";\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { JobStatus } from \"@/core/domain/job/job.entity\";\nimport {\n  IJobOptions,\n  JobPersistenceData,\n} from \"@/core/domain/job/job.types\";\nimport { JobPersistence } from \"@/core/domain/job/job.entity\";\nimport * as schema from \"../schema\";\n\nexport function mapToPersistenceData<P, R>(\n  jobData: schema.JobSelect\n): JobPersistenceData<P, R> {\n  const options = jobData.options as IJobOptions;\n  const logs =\n    (jobData.logs as Array<{\n      message: string;\n      level: string;\n      timestamp: number;\n    }>) || [];\n  const payload = jobData.payload as P;\n  const returnValue = jobData.returnValue as R | null;\n  const progress = jobData.progress as number | object;\n  const stacktrace = jobData.stacktrace as string[] | null;\n\n  return {\n    id: jobData.id,\n    queueName: jobData.queueName,\n    name: jobData.name,\n    payload: payload,\n    options: options,\n    status: jobData.status as JobStatus,\n    attemptsMade: jobData.attemptsMade,\n    progress: progress,\n    logs: logs,\n    createdAt: jobData.createdAt.getTime(),\n    updatedAt: jobData.updatedAt.getTime(),\n    processedOn: jobData.processedOn ? jobData.processedOn.getTime() : null,\n    finishedOn: jobData.finishedOn ? jobData.finishedOn.getTime() : null,\n    delayUntil: jobData.delayUntil ? jobData.delayUntil.getTime() : null,\n    lockUntil: jobData.lockUntil ? jobData.lockUntil.getTime() : null,\n    workerId: jobData.workerId,\n    returnValue: returnValue,\n    failedReason: jobData.failedReason,\n    stacktrace: stacktrace,\n  };\n}\n\nexport function mapToDrizzleInput(\n  data: JobPersistence\n): typeof schema.jobsTable.$inferInsert {\n  return {\n    ...data,\n    createdAt: new Date(data.createdAt),\n    updatedAt: new Date(data.updatedAt),\n    processedOn: data.processedOn ? new Date(data.processedOn) : null,\n    finishedOn: data.finishedOn ? new Date(data.finishedOn) : null,\n    delayUntil: data.delayUntil ? new Date(data.delayUntil) : null,\n    lockUntil: data.lockUntil ? new Date(data.lockUntil) : null,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/persistence/drizzle/job/drizzle-job.repository.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'JobPersistence' is defined but never used. Allowed unused vars must match /^_/u.","line":16,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":17},{"ruleId":"no-inline-comments","severity":2,"message":"Unexpected comment inline with code.","line":16,"column":19,"nodeType":"Line","messageId":"unexpectedInlineComment","endLine":16,"endColumn":50},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'IJobOptions' is defined but never used. Allowed unused vars must match /^_/u.","line":19,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":19,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'JobPersistenceData' is defined but never used. Allowed unused vars must match /^_/u.","line":20,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":20,"endColumn":21},{"ruleId":"no-inline-comments","severity":2,"message":"Unexpected comment inline with code.","line":20,"column":23,"nodeType":"Line","messageId":"unexpectedInlineComment","endLine":20,"endColumn":53},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":26,"column":1,"nodeType":"ImportDeclaration","endLine":26,"endColumn":37,"fix":{"range":[637,637],"text":"\n"}},{"ruleId":"max-lines","severity":2,"message":"File has too many lines (220). Maximum allowed is 200.","line":219,"column":1,"nodeType":null,"messageId":"exceed","endLine":244,"endColumn":1}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import {\n  and,\n  asc as ascDrizzle,\n  desc,\n  eq,\n  inArray,\n  isNull,\n  lt,\n  or,\n} from \"drizzle-orm\";\n\nimport { IJobRepository } from \"@/core/application/ports/job-repository.interface\";\nimport {\n  JobEntity,\n  JobStatus,\n  JobPersistence, // Correctly from job.entity.ts\n} from \"@/core/domain/job/job.entity\";\nimport {\n  IJobOptions,\n  JobPersistenceData, // Correctly from job.types.ts\n} from \"@/core/domain/job/job.types\";\nimport { JobIdVO } from \"@/core/domain/job/value-objects/job-id.vo\";\n\n// Import 'db' type for constructor injection\nimport { type db as DbType } from \"../drizzle.client\";\nimport * as schema from \"../schema\";\nimport {\n  mapToDrizzleInput,\n  mapToPersistenceData,\n} from \"./drizzle-job.mapper\";\n\n\nexport class DrizzleJobRepository implements IJobRepository {\n  constructor(private readonly drizzleDbInstance: DbType) {}\n\n  async save(job: JobEntity<unknown, unknown>): Promise<void> {\n    const persistenceData = job.toPersistence();\n    const drizzleInput = mapToDrizzleInput(persistenceData);\n    await this.drizzleDbInstance\n      .insert(schema.jobsTable)\n      .values(drizzleInput)\n      .onConflictDoUpdate({ target: schema.jobsTable.id, set: drizzleInput });\n  }\n\n  async update(job: JobEntity<unknown, unknown>): Promise<void> {\n    const persistenceData = job.toPersistence();\n    const drizzleInput = this.mapToDrizzleInput(persistenceData);\n    await this.drizzleDbInstance\n      .update(schema.jobsTable)\n      .set(drizzleInput)\n      .where(eq(schema.jobsTable.id, drizzleInput.id));\n  }\n\n  async findById(id: JobIdVO): Promise<JobEntity<unknown, unknown> | null> {\n    const result = await this.drizzleDbInstance.query.jobsTable.findFirst({\n      where: eq(schema.jobsTable.id, id.value),\n    });\n    if (!result) return null;\n    return JobEntity.fromPersistence(mapToPersistenceData(result));\n  }\n\n  async findNextJobsToProcess(\n    queueName: string,\n    limit: number\n  ): Promise<Array<JobEntity<unknown, unknown>>> {\n    const now = new Date();\n    const results = await this.drizzleDbInstance.query.jobsTable.findMany({\n      where: and(\n        eq(schema.jobsTable.queueName, queueName),\n        or(\n          eq(schema.jobsTable.status, JobStatus.WAITING),\n          and(\n            eq(schema.jobsTable.status, JobStatus.DELAYED),\n            lt(schema.jobsTable.delayUntil, now)\n          )\n        )\n      ),\n      orderBy: [\n        ascDrizzle(schema.jobsTable.priority),\n        ascDrizzle(schema.jobsTable.createdAt),\n      ],\n      limit,\n    });\n    return results.map((jobData) =>\n      JobEntity.fromPersistence(mapToPersistenceData(jobData))\n    );\n  }\n\n  async acquireLock(\n    jobId: JobIdVO,\n    workerId: string,\n    lockUntil: Date\n  ): Promise<boolean> {\n    const result = await this.drizzleDbInstance\n      .update(schema.jobsTable)\n      .set({ workerId, lockUntil, status: JobStatus.ACTIVE })\n      .where(\n        and(\n          eq(schema.jobsTable.id, jobId.value),\n          or(\n            isNull(schema.jobsTable.workerId),\n            lt(schema.jobsTable.lockUntil, new Date())\n          )\n        )\n      );\n    return result.changes > 0;\n  }\n\n  async extendLock(\n    jobId: JobIdVO,\n    workerId: string,\n    lockUntil: Date\n  ): Promise<void> {\n    await this.drizzleDbInstance\n      .update(schema.jobsTable)\n      .set({ lockUntil })\n      .where(\n        and(\n          eq(schema.jobsTable.id, jobId.value),\n          eq(schema.jobsTable.workerId, workerId)\n        )\n      );\n  }\n\n  async findStalledJobs(\n    queueName: string,\n    olderThan: Date,\n    limit: number\n  ): Promise<Array<JobEntity<unknown, unknown>>> {\n    const results = await this.drizzleDbInstance.query.jobsTable.findMany({\n      where: and(\n        eq(schema.jobsTable.queueName, queueName),\n        eq(schema.jobsTable.status, JobStatus.ACTIVE),\n        lt(schema.jobsTable.lockUntil, olderThan)\n      ),\n      limit,\n    });\n    return results.map((jobData) =>\n      JobEntity.fromPersistence(mapToPersistenceData(jobData))\n    );\n  }\n\n  async remove(jobId: JobIdVO): Promise<void> {\n    await this.drizzleDbInstance\n      .delete(schema.jobsTable)\n      .where(eq(schema.jobsTable.id, jobId.value));\n  }\n\n  async getJobsByStatus(\n    queueName: string,\n    statuses: JobStatus[],\n    start: number = 0,\n    end: number = 100,\n    asc: boolean = false\n  ): Promise<Array<JobEntity<unknown, unknown>>> {\n    const results = await this.drizzleDbInstance.query.jobsTable.findMany({\n      where: and(\n        eq(schema.jobsTable.queueName, queueName),\n        inArray(schema.jobsTable.status, statuses)\n      ),\n      orderBy: [\n        asc\n          ? ascDrizzle(schema.jobsTable.createdAt)\n          : desc(schema.jobsTable.createdAt),\n      ],\n      offset: start,\n      limit: end,\n    });\n    return results.map((jobData) =>\n      JobEntity.fromPersistence(mapToPersistenceData(jobData))\n    );\n  }\n\n  async countJobsByStatus(\n    queueName: string,\n    statuses?: JobStatus[]\n  ): Promise<Partial<Record<JobStatus, number>>> {\n    const query = this.drizzleDbInstance\n      .select({\n        status: schema.jobsTable.status,\n        count: schema.sql`count(*)`.mapWith(Number),\n      })\n      .from(schema.jobsTable)\n      .where(\n        and(\n          eq(schema.jobsTable.queueName, queueName),\n          statuses ? inArray(schema.jobsTable.status, statuses) : undefined\n        )\n      )\n      .groupBy(schema.jobsTable.status);\n\n    const results = await query;\n    return results.reduce(\n      (acc, row) => {\n        acc[row.status as JobStatus] = row.count as number;\n        return acc;\n      },\n      {} as Partial<Record<JobStatus, number>>\n    );\n  }\n\n  async clean(\n    queueName: string,\n    gracePeriodMs: number,\n    limit: number,\n    status?: JobStatus\n  ): Promise<number> {\n    const now = new Date();\n    const finishedOlderThan = new Date(now.getTime() - gracePeriodMs);\n\n    const jobsToDeleteIdsQuery = this.drizzleDbInstance\n      .select({ id: schema.jobsTable.id })\n      .from(schema.jobsTable)\n      .where(\n        and(\n          eq(schema.jobsTable.queueName, queueName),\n          status\n            ? eq(schema.jobsTable.status, status)\n            : or(\n                eq(schema.jobsTable.status, JobStatus.COMPLETED),\n                eq(schema.jobsTable.status, JobStatus.FAILED)\n              ),\n          lt(schema.jobsTable.finishedOn, finishedOlderThan)\n        )\n      )\n      .orderBy(ascDrizzle(schema.jobsTable.finishedOn))\n      .limit(limit);\n\n    const jobsToDelete = await jobsToDeleteIdsQuery;\n\n    if (jobsToDelete.length === 0) {\n      return 0;\n    }\n\n    const ids = jobsToDelete.map((jobEntry) => jobEntry.id);\n\n    const result = await this.drizzleDbInstance\n      .delete(schema.jobsTable)\n      .where(inArray(schema.jobsTable.id, ids));\n\n    return result.changes;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/persistence/drizzle/repositories/project.repository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/persistence/drizzle/schema/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/persistence/drizzle/schema/jobs.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/persistence/drizzle/test-db.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/persistence/in-memory/repositories/agent-internal-state.repository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/persistence/in-memory/repositories/agent-persona-template.repository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/persistence/in-memory/repositories/agent.repository.ts","messages":[{"ruleId":"import/no-unresolved","severity":2,"message":"Unable to resolve path to module '@/core/domain/agent/value-objects/persona-id.vo'.","line":6,"column":29,"nodeType":"Literal","endLine":6,"endColumn":78},{"ruleId":"no-inline-comments","severity":2,"message":"Unexpected comment inline with code.","line":6,"column":80,"nodeType":"Line","messageId":"unexpectedInlineComment","endLine":6,"endColumn":95}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { injectable } from \"inversify\";\n\nimport { Agent } from \"@/core/domain/agent/agent.entity\";\nimport { IAgentRepository } from \"@/core/domain/agent/ports/agent-repository.interface\";\nimport { AgentId } from \"@/core/domain/agent/value-objects/agent-id.vo\";\nimport { PersonaIdVO } from \"@/core/domain/agent/value-objects/persona-id.vo\"; // Added import\n\nimport { Result, Ok, Err } from \"@/shared/result\";\n\n@injectable()\nexport class InMemoryAgentRepository implements IAgentRepository {\n  private readonly agents: Map<string, Agent> = new Map();\n\n  async save(agent: Agent): Promise<Result<void, Error>> {\n    this.agents.set(agent.id.value, agent);\n    return Ok(undefined);\n  }\n\n  async findById(id: AgentId): Promise<Result<Agent | null, Error>> {\n    const agent = this.agents.get(id.value);\n    return Ok(agent || null);\n  }\n\n  async findAll(): Promise<Result<Agent[], Error>> {\n    return Ok(Array.from(this.agents.values()));\n  }\n\n  async delete(id: AgentId): Promise<Result<void, Error>> {\n    if (!this.agents.has(id.value)) {\n      return Err(new Error(`Agent with ID ${id.value} not found.`));\n    }\n    this.agents.delete(id.value);\n    return Ok(undefined);\n  }\n\n  async findByPersonaId(personaId: PersonaIdVO): Promise<Result<Agent[], Error>> {\n    const foundAgents = Array.from(this.agents.values()).filter((agent) =>\n      agent.personaId.equals(personaId)\n    );\n    return Ok(foundAgents);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/persistence/in-memory/repositories/annotation.repository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/persistence/in-memory/repositories/llm-provider-config.repository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/persistence/in-memory/repositories/memory.repository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/persistence/in-memory/repositories/project.repository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/persistence/in-memory/repositories/source-code.repository.ts","messages":[{"ruleId":"no-inline-comments","severity":2,"message":"Unexpected comment inline with code.","line":6,"column":108,"nodeType":"Line","messageId":"unexpectedInlineComment","endLine":6,"endColumn":127}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { injectable } from \"inversify\";\n\nimport { ProjectId } from \"@/core/domain/project/value-objects/project-id.vo\";\nimport { ISourceCodeRepository } from \"@/core/domain/source-code/ports/source-code-repository.interface\";\nimport { SourceCode } from \"@/core/domain/source-code/source-code.entity\";\nimport { RepositoryIdVO as SourceCodeId } from \"@/core/domain/source-code/value-objects/repository-id.vo\"; // Corrected import\n\nimport { Result, Ok, Err } from \"@/shared/result\";\n\n@injectable()\nexport class InMemorySourceCodeRepository implements ISourceCodeRepository {\n  private readonly sourceCodes: Map<string, SourceCode> = new Map();\n\n  async save(sourceCode: SourceCode): Promise<Result<void, Error>> {\n    this.sourceCodes.set(sourceCode.id.value, sourceCode);\n    return Ok(undefined);\n  }\n\n  async findById(id: SourceCodeId): Promise<Result<SourceCode | null, Error>> {\n    const sourceCode = this.sourceCodes.get(id.value);\n    return Ok(sourceCode || null);\n  }\n\n  async findByProjectId(\n    projectId: ProjectId\n  ): Promise<Result<SourceCode[], Error>> {\n    const found = Array.from(this.sourceCodes.values()).filter((sc) =>\n      sc.projectId.equals(projectId)\n    );\n    return Ok(found);\n  }\n\n  async delete(id: SourceCodeId): Promise<Result<void, Error>> {\n    if (!this.sourceCodes.has(id.value)) {\n      return Err(new Error(`SourceCode with ID ${id.value} not found.`));\n    }\n    this.sourceCodes.delete(id.value);\n    return Ok(undefined);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/persistence/in-memory/repositories/user.repository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/queue/drizzle/__tests__/queue.service-add.spec.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":42,"fix":{"range":[124,124],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"// src_refactored/infrastructure/queue/drizzle/__tests__/queue.service-add.spec.ts\nimport { randomUUID } from \"node:crypto\";\nimport {\n  vi,\n  describe,\n  it,\n  expect,\n  beforeEach,\n  beforeAll,\n  afterEach,\n} from \"vitest\";\n\nimport { JobEntity, JobStatus } from \"../../../../core/domain/job/job.entity\";\nimport { IJobOptions } from \"../../../../core/domain/job/value-objects/job-options.vo\"; // Corrected: Use as value\nimport { DrizzleJobRepository } from \"../../../persistence/drizzle/job/drizzle-job.repository\";\nimport { QueueService } from \"../queue.service\";\n// import { JobIdVO } from \"../../../../core/domain/job/value-objects/job-id.vo\"; // Not directly used in this snippet, but likely needed\n\nimport {\n  TestDb,\n  createTestDbClient,\n  runMigrations,\n  clearDatabaseTables,\n} from \"./test-db.helper\";\n\n// Top-level variables for test context\nlet db: TestDb;\nlet jobRepository: DrizzleJobRepository;\nlet queueService: QueueService<{ email: string }, { status: string }>;\nconst queueName = \"test-email-queue\";\nconst defaultJobOpts: IJobOptions = {\n  attempts: 1,\n  delay: 0,\n  priority: 0,\n  removeOnComplete: false,\n  removeOnFail: false,\n  maxStalledCount: 3,\n};\n\nbeforeAll(async () => {\n  db = createTestDbClient({ memory: true });\n  await runMigrations(db);\n});\n\nbeforeEach(async () => {\n  vi.clearAllMocks();\n  await clearDatabaseTables(db);\n\n  jobRepository = new DrizzleJobRepository(db);\n  queueService = new QueueService(queueName, jobRepository, defaultJobOpts);\n  vi.spyOn(queueService, \"emit\");\n});\n\nafterEach(async () => {\n  if (queueService) {\n    await queueService.close();\n  }\n  vi.restoreAllMocks();\n});\n\ndescribe(\"QueueService - add\", () => {\n  it(\"should create a job, save it to DB, and emit job.added event\", async () => {\n    const jobData = { email: \"test@example.com\" };\n    const jobName = \"send-welcome-email\";\n\n    const createdJob = await queueService.add(jobName, jobData);\n\n    expect(createdJob).toBeInstanceOf(JobEntity);\n    expect(createdJob.name).toBe(jobName);\n    expect(createdJob.payload).toEqual(jobData);\n    expect(createdJob.queueName).toBe(queueName);\n    expect(createdJob.options.attempts).toBe(defaultJobOpts.attempts);\n    expect(queueService.emit).toHaveBeenCalledWith(\"job.added\", createdJob);\n\n    // Verify job is in the database\n    const jobFromDb = await jobRepository.findById(createdJob.id);\n    expect(jobFromDb).not.toBeNull();\n    expect(jobFromDb!.id.value).toBe(createdJob.id.value);\n    expect(jobFromDb!.name).toBe(jobName);\n    expect(jobFromDb!.payload).toEqual(jobData);\n  });\n\n  it(\"should apply custom options when adding a job, and save to DB\", async () => {\n    const jobData = { email: \"custom@example.com\" };\n    const jobName = \"custom-options-job\";\n    const validCustomJobId = randomUUID();\n    const customOpts: IJobOptions = {\n      attempts: 5,\n      delay: 5000,\n      priority: 1,\n      jobId: validCustomJobId,\n    };\n\n    const createdJob = await queueService.add(jobName, jobData, customOpts);\n\n    expect(createdJob.id.value).toBe(validCustomJobId);\n    expect(createdJob.options.attempts).toBe(5);\n    expect(createdJob.options.delay).toBe(5000);\n    expect(createdJob.options.priority).toBe(1);\n    expect(createdJob.status).toBe(JobStatus.DELAYED);\n\n    const jobFromDb = await jobRepository.findById(createdJob.id);\n    expect(jobFromDb).not.toBeNull();\n    expect(jobFromDb!.id.value).toBe(validCustomJobId);\n    expect(jobFromDb!.options.priority).toBe(1);\n  });\n});\n\ndescribe(\"QueueService - addBulk\", () => {\n  it(\"should add multiple jobs to DB, and emit events\", async () => {\n    const jobsToAdd = [\n      { name: \"bulk1\", data: { email: \"b1@example.com\" } },\n      {\n        name: \"bulk2\",\n        data: { email: \"b2@example.com\" },\n        opts: { priority: 1 },\n      },\n    ];\n\n    const addedJobs = await queueService.addBulk(jobsToAdd);\n\n    expect(addedJobs.length).toBe(2);\n    expect(queueService.emit).toHaveBeenCalledTimes(2);\n\n    const job1FromDb = await jobRepository.findById(addedJobs[0].id);\n    expect(job1FromDb).not.toBeNull();\n    expect(job1FromDb!.name).toBe(\"bulk1\");\n    expect(job1FromDb!.payload).toEqual({ email: \"b1@example.com\" });\n    expect(queueService.emit).toHaveBeenCalledWith(\"job.added\", addedJobs[0]);\n\n    const job2FromDb = await jobRepository.findById(addedJobs[1].id);\n    expect(job2FromDb).not.toBeNull();\n    expect(job2FromDb!.name).toBe(\"bulk2\");\n    expect(job2FromDb!.options.priority).toBe(1);\n    expect(queueService.emit).toHaveBeenCalledWith(\"job.added\", addedJobs[1]);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/queue/drizzle/__tests__/queue.service-admin.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/queue/drizzle/__tests__/queue.service-get.spec.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'JobEntity' is defined but never used. Allowed unused vars must match /^_/u.","line":12,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src_refactored/infrastructure/queue/drizzle/__tests__/queue.service-get.spec.ts\nimport {\n  vi,\n  describe,\n  it,\n  expect,\n  beforeEach,\n  beforeAll,\n  afterEach,\n} from \"vitest\";\n\nimport { JobEntity } from \"../../../../core/domain/job/job.entity\";\nimport { type IJobOptions } from \"../../../../core/domain/job/value-objects/job-options.vo\";\nimport { DrizzleJobRepository } from \"../../../persistence/drizzle/job/drizzle-job.repository\";\nimport { QueueService } from \"../queue.service\";\n// import { JobIdVO } from \"../../../../core/domain/job/value-objects/job-id.vo\"; // Not directly used here but JobEntity uses it\n\nimport {\n  TestDb,\n  createTestDbClient,\n  runMigrations,\n  clearDatabaseTables,\n} from \"./test-db.helper\";\n\n// Top-level variables for test context\nlet db: TestDb;\nlet jobRepository: DrizzleJobRepository;\nlet queueService: QueueService<{ email: string }, { status: string }>;\nconst queueName = \"test-email-queue\";\nconst defaultJobOpts: IJobOptions = {\n  attempts: 1,\n  delay: 0,\n  priority: 0,\n  removeOnComplete: false,\n  removeOnFail: false,\n  maxStalledCount: 3,\n};\n\nbeforeAll(async () => {\n  db = createTestDbClient({ memory: true });\n  await runMigrations(db);\n});\n\nbeforeEach(async () => {\n  vi.clearAllMocks();\n  await clearDatabaseTables(db);\n\n  jobRepository = new DrizzleJobRepository(db);\n  queueService = new QueueService(queueName, jobRepository, defaultJobOpts);\n  vi.spyOn(queueService, \"emit\");\n});\n\nafterEach(async () => {\n  if (queueService) {\n    await queueService.close();\n  }\n  vi.restoreAllMocks();\n});\n\ndescribe(\"QueueService - getJob\", () => {\n  it(\"should retrieve a job from DB by JobIdVO\", async () => {\n    const jobData = { email: \"find@me.com\" };\n    const jobName = \"find-me\";\n    // Need to add a job first to get it\n    const addedJob = await queueService.add(jobName, jobData);\n    const foundJob = await queueService.getJob(addedJob.id);\n\n    expect(foundJob).not.toBeNull();\n    expect(foundJob!.id.value).toBe(addedJob.id.value);\n    expect(foundJob!.name).toBe(jobName);\n  });\n\n  it(\"should retrieve a job from DB by string ID\", async () => {\n    const jobData = { email: \"find@me-str.com\" };\n    const jobName = \"find-me-str\";\n    // Need to add a job first to get it\n    const addedJob = await queueService.add(jobName, jobData);\n    const foundJob = await queueService.getJob(addedJob.id.value);\n\n    expect(foundJob).not.toBeNull();\n    expect(foundJob!.id.value).toBe(addedJob.id.value);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/queue/drizzle/__tests__/queue.service-lifecycle.spec.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":42,"fix":{"range":[168,168],"text":"\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'randomUUID' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'JobEntity' is defined but never used. Allowed unused vars must match /^_/u.","line":13,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":19},{"ruleId":"max-lines","severity":2,"message":"File has too many lines (348). Maximum allowed is 200.","line":232,"column":1,"nodeType":null,"messageId":"exceed","endLine":394,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":1,"source":"// src_refactored/infrastructure/queue/drizzle/__tests__/queue.service-lifecycle.spec.ts\nimport { randomUUID } from \"node:crypto\"; // Needed for custom Job IDs in tests\nimport {\n  vi,\n  describe,\n  it,\n  expect,\n  beforeEach,\n  beforeAll,\n  afterEach,\n} from \"vitest\";\n\nimport { JobEntity, JobStatus } from \"../../../../core/domain/job/job.entity\";\nimport { JobIdVO } from \"../../../../core/domain/job/value-objects/job-id.vo\";\nimport { IJobOptions } from \"../../../../core/domain/job/value-objects/job-options.vo\";\nimport { DrizzleJobRepository } from \"../../../persistence/drizzle/job/drizzle-job.repository\";\nimport { QueueService } from \"../queue.service\";\n\nimport {\n  TestDb,\n  createTestDbClient,\n  runMigrations,\n  clearDatabaseTables,\n} from \"./test-db.helper\";\n\n// Top-level variables for test context\nlet db: TestDb;\nlet jobRepository: DrizzleJobRepository;\nlet queueService: QueueService<{ email: string }, { status: string }>;\nconst queueName = \"test-email-queue\";\nconst defaultJobOpts: IJobOptions = {\n  attempts: 1,\n  delay: 0,\n  priority: 0,\n  removeOnComplete: false,\n  removeOnFail: false,\n  maxStalledCount: 3,\n};\n\nbeforeAll(async () => {\n  db = createTestDbClient({ memory: true });\n  await runMigrations(db);\n});\n\nbeforeEach(async () => {\n  vi.clearAllMocks();\n  await clearDatabaseTables(db);\n\n  jobRepository = new DrizzleJobRepository(db);\n  queueService = new QueueService(queueName, jobRepository, defaultJobOpts);\n  vi.spyOn(queueService, \"emit\");\n});\n\nafterEach(async () => {\n  if (queueService) {\n    await queueService.close();\n  }\n  vi.restoreAllMocks();\n});\n\ndescribe(\"QueueService - fetchNextJobAndLock\", () => {\n  const workerId = \"worker-007\";\n  const lockDurationMs = 30000;\n\n  it(\"should return null if no jobs are available in DB\", async () => {\n    const job = await queueService.fetchNextJobAndLock(\n      workerId,\n      lockDurationMs\n    );\n    expect(job).toBeNull();\n  });\n\n  it(\"should return null if lock cannot be acquired (e.g. another worker got it)\", async () => {\n    await queueService.add(\"job1\", {\n      email: \"e1@example.com\",\n    });\n\n    const fetchedAndLockedJob = await queueService.fetchNextJobAndLock(\n      workerId,\n      lockDurationMs\n    );\n    expect(fetchedAndLockedJob).not.toBeNull();\n\n    const anotherAttempt = await queueService.fetchNextJobAndLock(\n      \"worker-008\",\n      lockDurationMs\n    );\n    expect(anotherAttempt).toBeNull();\n  });\n\n  it(\"should fetch, lock, update job to active in DB, and emit event\", async () => {\n    const addedJob = await queueService.add(\"job2\", {\n      email: \"e2@example.com\",\n    });\n\n    const fetchedJob = await queueService.fetchNextJobAndLock(\n      workerId,\n      lockDurationMs\n    );\n\n    expect(fetchedJob).not.toBeNull();\n    expect(fetchedJob!.id.value).toBe(addedJob.id.value);\n    expect(fetchedJob!.status).toBe(JobStatus.ACTIVE);\n    expect(fetchedJob!.workerId).toBe(workerId);\n    expect(fetchedJob!.lockUntil).toBeInstanceOf(Date);\n    expect(fetchedJob!.lockUntil!.getTime()).toBeGreaterThan(Date.now());\n    expect(fetchedJob!.processedOn).toBeInstanceOf(Date);\n    expect(fetchedJob!.attemptsMade).toBe(1);\n    expect(queueService.emit).toHaveBeenCalledWith(\"job.active\", fetchedJob);\n\n    const jobFromDb = await jobRepository.findById(addedJob.id);\n    expect(jobFromDb).not.toBeNull();\n    expect(jobFromDb!.status).toBe(JobStatus.ACTIVE);\n    expect(jobFromDb!.workerId).toBe(workerId);\n  });\n});\n\ndescribe(\"QueueService - extendJobLock\", () => {\n  let jobId: JobIdVO;\n  const workerId = \"worker-extend\";\n  const lockDurationMs = 15000;\n\n  beforeEach(async () => {\n    jobId = JobIdVO.create();\n    const jobOptions: IJobOptions = { jobId: jobId.value };\n    await queueService.add(\n      \"extend-me\",\n      { email: \"extend@example.com\" },\n      jobOptions\n    );\n    const activeJob = await queueService.fetchNextJobAndLock(workerId, 10000);\n    expect(activeJob).not.toBeNull();\n    expect(activeJob!.id.value).toBe(jobId.value);\n  });\n\n  it(\"should extend lock for an active job owned by the worker\", async () => {\n    const jobBeforeExtend = await jobRepository.findById(jobId);\n    expect(jobBeforeExtend).not.toBeNull();\n    const originalLockUntil = jobBeforeExtend!.lockUntil;\n\n    await queueService.extendJobLock(jobId, workerId, lockDurationMs);\n\n    const jobAfterExtend = await jobRepository.findById(jobId);\n    expect(jobAfterExtend).not.toBeNull();\n    expect(jobAfterExtend!.lockUntil!.getTime()).toBeGreaterThan(\n      originalLockUntil!.getTime()\n    );\n    expect(jobAfterExtend!.lockUntil!.getTime()).toBeGreaterThanOrEqual(\n      Date.now() + lockDurationMs - 2000\n    );\n    expect(queueService.emit).toHaveBeenCalledWith(\n      \"job.lock.extended\",\n      expect.objectContaining({ id: jobId })\n    );\n  });\n\n  it(\"should accept string job ID for extendJobLock\", async () => {\n    await queueService.extendJobLock(jobId.value, workerId, lockDurationMs);\n    const jobAfterExtend = await jobRepository.findById(jobId);\n    expect(jobAfterExtend).not.toBeNull();\n    expect(jobAfterExtend!.lockUntil!.getTime()).toBeGreaterThanOrEqual(\n      Date.now() + lockDurationMs - 2000\n    );\n  });\n\n  it(\"should not extend lock if job not found\", async () => {\n    const nonExistentJobId = JobIdVO.create();\n    await queueService.extendJobLock(\n      nonExistentJobId,\n      workerId,\n      lockDurationMs\n    );\n    expect(queueService.emit).not.toHaveBeenCalledWith(\n      \"job.lock.extended\",\n      expect.anything()\n    );\n  });\n\n  it(\"should not extend lock if workerId does not match\", async () => {\n    const jobBeforeExtend = await jobRepository.findById(jobId);\n    await queueService.extendJobLock(jobId, \"other-worker\", lockDurationMs);\n    const jobAfterExtend = await jobRepository.findById(jobId);\n    expect(jobAfterExtend!.lockUntil!.getTime()).toEqual(\n      jobBeforeExtend!.lockUntil!.getTime()\n    );\n  });\n\n  it(\"should not extend lock if job is not active\", async () => {\n    await queueService.markJobAsCompleted(jobId, workerId, {\n      status: \"done\",\n    });\n    const jobCompleted = await jobRepository.findById(jobId);\n    const lockTimeBefore = jobCompleted!.lockUntil;\n\n    await queueService.extendJobLock(jobId, workerId, lockDurationMs);\n    const jobAfterAttemptedExtend = await jobRepository.findById(jobId);\n    if (lockTimeBefore) {\n      expect(jobAfterAttemptedExtend!.lockUntil!.getTime()).toEqual(\n        lockTimeBefore.getTime()\n      );\n    } else {\n      expect(jobAfterAttemptedExtend!.lockUntil).toBeNull();\n    }\n  });\n});\n\ndescribe(\"QueueService - markJobAsCompleted\", () => {\n  let jobIdForCompleteTest: JobIdVO;\n  const workerIdForCompleteTest = \"worker-complete\";\n  const resultForCompleteTest = { status: \"Email Sent!\" };\n\n  beforeEach(async () => {\n    jobIdForCompleteTest = JobIdVO.create();\n    await queueService.add(\n      \"complete-me\",\n      { email: \"c@ex.com\" },\n      { jobId: jobIdForCompleteTest.value }\n    );\n    const activeJob = await queueService.fetchNextJobAndLock(\n      workerIdForCompleteTest,\n      10000\n    );\n    if (!activeJob || activeJob.id.value !== jobIdForCompleteTest.value)\n      throw new Error(\"Setup failed for markJobAsCompleted\");\n  });\n\n  it(\"should mark job as completed, update DB, and emit event\", async () => {\n    const jobInstanceFromWorker =\n      await jobRepository.findById(jobIdForCompleteTest);\n    jobInstanceFromWorker!.addLog(\n      \"Log from worker before completion\",\n      \"INFO\"\n    );\n\n    await queueService.markJobAsCompleted(\n      jobIdForCompleteTest,\n      workerIdForCompleteTest,\n      resultForCompleteTest,\n      jobInstanceFromWorker!\n    );\n\n    const jobFromDb = await jobRepository.findById(jobIdForCompleteTest);\n    expect(jobFromDb).not.toBeNull();\n    expect(jobFromDb!.status).toBe(JobStatus.COMPLETED);\n    expect(jobFromDb!.returnValue).toEqual(resultForCompleteTest);\n    expect(jobFromDb!.finishedOn).toBeInstanceOf(Date);\n    expect(\n      jobFromDb!.logs.some(\n        (log) => log.message === \"Log from worker before completion\"\n      )\n    ).toBe(false); // Logs from instance are not persisted unless explicitly added via queueService.addJobLog\n\n    expect(queueService.emit).toHaveBeenCalledWith(\n      \"job.completed\",\n      expect.objectContaining({\n        id: jobIdForCompleteTest,\n        status: JobStatus.COMPLETED,\n      })\n    );\n  });\n\n  it(\"should accept string job ID for markJobAsCompleted\", async () => {\n    await queueService.markJobAsCompleted(\n      jobIdForCompleteTest.value,\n      workerIdForCompleteTest,\n      resultForCompleteTest\n    );\n    const jobFromDb = await jobRepository.findById(jobIdForCompleteTest);\n    expect(jobFromDb!.status).toBe(JobStatus.COMPLETED);\n  });\n\n  it(\"should not complete if job not found in DB\", async () => {\n    const nonExistentJobId = JobIdVO.create();\n    await queueService.markJobAsCompleted(\n      nonExistentJobId,\n      workerIdForCompleteTest,\n      resultForCompleteTest\n    );\n    expect(queueService.emit).not.toHaveBeenCalledWith(\n      \"job.completed\",\n      expect.objectContaining({ id: nonExistentJobId })\n    );\n  });\n\n  it(\"should not complete if workerId does not match job in DB\", async () => {\n    await queueService.markJobAsCompleted(\n      jobIdForCompleteTest,\n      \"another-worker\",\n      resultForCompleteTest\n    );\n    const jobFromDb = await jobRepository.findById(jobIdForCompleteTest);\n    expect(jobFromDb!.status).toBe(JobStatus.ACTIVE); // Should remain active\n    expect(queueService.emit).not.toHaveBeenCalledWith(\n      \"job.completed\",\n      expect.anything()\n    );\n  });\n});\n\ndescribe(\"QueueService - markJobAsFailed\", () => {\n  let jobToFailPermanentlyId: JobIdVO;\n  let jobToRetryId: JobIdVO;\n  const workerIdForFailTest = \"worker-fail\";\n  const errorForFailTest = new Error(\"Test Job Failed\");\n\n  beforeEach(async () => {\n    jobToFailPermanentlyId = JobIdVO.create();\n    await queueService.add(\n      \"fail-me-permanently\",\n      { email: \"f-perm@ex.com\" },\n      { jobId: jobToFailPermanentlyId.value, attempts: 1 }\n    );\n    const activeJobPerm = await queueService.fetchNextJobAndLock(\n      workerIdForFailTest,\n      10000\n    );\n    if (\n      !activeJobPerm ||\n      activeJobPerm.id.value !== jobToFailPermanentlyId.value\n    )\n      throw new Error(\"Setup failed for jobToFailPermanently\");\n\n    jobToRetryId = JobIdVO.create();\n    await queueService.add(\n      \"fail-me-with-retries\",\n      { email: \"f-retry@ex.com\" },\n      {\n        jobId: jobToRetryId.value,\n        attempts: 3,\n        backoff: { type: \"exponential\", delay: 100 },\n      }\n    );\n    const activeJobRetry = await queueService.fetchNextJobAndLock(\n      workerIdForFailTest,\n      10000\n    );\n    if (!activeJobRetry || activeJobRetry.id.value !== jobToRetryId.value)\n      throw new Error(\"Setup failed for jobToRetry\");\n  });\n\n  it(\"should mark job as FAILED if attempts exhausted, update DB, and emit event\", async () => {\n    await queueService.markJobAsFailed(\n      jobToFailPermanentlyId,\n      workerIdForFailTest,\n      errorForFailTest\n    );\n\n    const jobFromDb = await jobRepository.findById(jobToFailPermanentlyId);\n    expect(jobFromDb).not.toBeNull();\n    expect(jobFromDb!.status).toBe(JobStatus.FAILED);\n    expect(jobFromDb!.failedReason).toBe(errorForFailTest.message);\n    expect(jobFromDb!.finishedOn).toBeInstanceOf(Date);\n    expect(queueService.emit).toHaveBeenCalledWith(\n      \"job.failed\",\n      expect.objectContaining({\n        id: jobToFailPermanentlyId,\n        status: JobStatus.FAILED,\n      })\n    );\n  });\n\n  it(\"should mark job as DELAYED if retries are pending, update DB, and emit event\", async () => {\n    await queueService.markJobAsFailed(\n      jobToRetryId,\n      workerIdForFailTest,\n      errorForFailTest\n    );\n\n    const jobFromDb = await jobRepository.findById(jobToRetryId);\n    expect(jobFromDb).not.toBeNull();\n    expect(jobFromDb!.status).toBe(JobStatus.DELAYED);\n    expect(jobFromDb!.failedReason).toBe(errorForFailTest.message);\n    expect(jobFromDb!.delayUntil).toBeInstanceOf(Date);\n    expect(jobFromDb!.delayUntil!.getTime()).toBeGreaterThanOrEqual(\n      Date.now() + 90 // Approx 100ms (backoff delay) - some buffer for execution\n    );\n    expect(jobFromDb!.attemptsMade).toBe(1); // Assuming fetchNextJobAndLock increments it, then failure means this is the first *failed* attempt logic path\n    expect(queueService.emit).toHaveBeenCalledWith(\n      \"job.failed\",\n      expect.objectContaining({ id: jobToRetryId, status: JobStatus.DELAYED })\n    );\n  });\n\n  it(\"should accept string job ID for markJobAsFailed\", async () => {\n    await queueService.markJobAsFailed(\n      jobToFailPermanentlyId.value,\n      workerIdForFailTest,\n      errorForFailTest\n    );\n    const jobFromDb = await jobRepository.findById(jobToFailPermanentlyId);\n    expect(jobFromDb!.status).toBe(JobStatus.FAILED);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/queue/drizzle/__tests__/queue.service-maintenance.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/queue/drizzle/__tests__/queue.service-updates.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/queue/drizzle/__tests__/queue.service.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/queue/drizzle/__tests__/test-db.helper.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/queue/drizzle/queue.service.ts","messages":[{"ruleId":"no-inline-comments","severity":2,"message":"Unexpected comment inline with code.","line":217,"column":57,"nodeType":"Line","messageId":"unexpectedInlineComment","endLine":217,"endColumn":73},{"ruleId":"max-lines","severity":2,"message":"File has too many lines (287). Maximum allowed is 200.","line":223,"column":1,"nodeType":null,"messageId":"exceed","endLine":324,"endColumn":1},{"ruleId":"no-inline-comments","severity":2,"message":"Unexpected comment inline with code.","line":276,"column":14,"nodeType":"Line","messageId":"unexpectedInlineComment","endLine":276,"endColumn":60}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { IJobRepository } from \"@/core/application/ports/job-repository.interface\";\nimport { AbstractQueue } from \"@/core/application/queue/abstract-queue\";\nimport { JobEntity, JobStatus } from \"@/core/domain/job/job.entity\";\nimport { JobIdVO } from \"@/core/domain/job/value-objects/job-id.vo\";\nimport { IJobOptions } from \"@/core/domain/job/value-objects/job-options.vo\";\n\nexport class QueueService<P, R> extends AbstractQueue<P, R> {\n  private _isMaintenanceRunning: boolean = false;\n  private maintenanceLoopPromise: Promise<void> | null = null;\n  private readonly maintenanceIntervalMs: number = 15000;\n\n  constructor(\n    queueName: string,\n    jobRepository: IJobRepository,\n    defaultJobOptions?: IJobOptions\n  ) {\n    super(queueName, jobRepository, defaultJobOptions);\n  }\n\n  async add(\n    jobName: string,\n    data: P,\n    opts?: IJobOptions\n  ): Promise<JobEntity<P, R>> {\n    const job = JobEntity.create<P, R>({\n      queueName: this.queueName,\n      name: jobName,\n      payload: data,\n      options: { ...this.defaultJobOptions.toPersistence(), ...opts },\n    });\n    await this.jobRepository.save(job);\n    this.emit(\"job.added\", job);\n    return job;\n  }\n\n  async addBulk(\n    jobs: Array<{ name: string; data: P; opts?: IJobOptions }>\n  ): Promise<Array<JobEntity<P, R>>> {\n    const jobEntities = jobs.map((jobDef) =>\n      JobEntity.create<P, R>({\n        queueName: this.queueName,\n        name: jobDef.name,\n        payload: jobDef.data,\n        options: { ...this.defaultJobOptions.toPersistence(), ...jobDef.opts },\n      })\n    );\n    for (const job of jobEntities) {\n      await this.jobRepository.save(job);\n      this.emit(\"job.added\", job);\n    }\n    return jobEntities;\n  }\n\n  async getJob(jobId: string | JobIdVO): Promise<JobEntity<P, R> | null> {\n    const id = jobId instanceof JobIdVO ? jobId : JobIdVO.create(jobId);\n    return (await this.jobRepository.findById(id)) as JobEntity<P, R> | null;\n  }\n\n  async getJobsByStatus(\n    statuses: JobStatus[],\n    start?: number,\n    end?: number,\n    asc?: boolean\n  ): Promise<Array<JobEntity<P, R>>> {\n    return (await this.jobRepository.getJobsByStatus(\n      this.queueName,\n      statuses,\n      start,\n      end,\n      asc\n    )) as Array<JobEntity<P, R>>;\n  }\n\n  async countJobsByStatus(\n    statuses?: JobStatus[]\n  ): Promise<Partial<Record<JobStatus, number>>> {\n    return await this.jobRepository.countJobsByStatus(this.queueName, statuses);\n  }\n\n  async pause(): Promise<void> {\n    this.emit(\"queue.paused\");\n  }\n\n  async resume(): Promise<void> {\n    this.emit(\"queue.resumed\");\n  }\n\n  async clean(\n    gracePeriodMs: number,\n    limit: number,\n    status?: JobStatus\n  ): Promise<number> {\n    return await this.jobRepository.clean(\n      this.queueName,\n      gracePeriodMs,\n      limit,\n      status\n    );\n  }\n\n  public async stopMaintenance(): Promise<void> {\n    if (!this._isMaintenanceRunning && !this.maintenanceLoopPromise) {\n      return;\n    }\n    this._isMaintenanceRunning = false;\n    if (this.maintenanceLoopPromise) {\n      try {\n        await this.maintenanceLoopPromise;\n      } catch (error) {\n        this.emit(\n          \"queue.error\",\n          new Error(\n            `Error during maintenance loop stop: ${error instanceof Error ? error.message : String(error)}`\n          )\n        );\n      }\n    }\n    this.maintenanceLoopPromise = null;\n  }\n\n  public async close(): Promise<void> {\n    await this.stopMaintenance();\n    this.emit(\"queue.closed\");\n  }\n\n  async fetchNextJobAndLock(\n    workerId: string,\n    lockDurationMs: number\n  ): Promise<JobEntity<P, R> | null> {\n    console.log(\n      `[QueueService] Attempting to fetch next job for worker ${workerId}...`\n    );\n    const jobs = await this.jobRepository.findNextJobsToProcess(\n      this.queueName,\n      1\n    );\n    if (jobs.length === 0) {\n      console.log(`[QueueService] No jobs found for worker ${workerId}.`);\n      return null;\n    }\n\n    const job = jobs[0] as JobEntity<P, R>;\n    console.log(\n      `[QueueService] Found job ${job.id.value}. Attempting to acquire lock...`\n    );\n    const lockUntil = new Date(Date.now() + lockDurationMs);\n    const locked = await this.jobRepository.acquireLock(\n      job.id,\n      workerId,\n      lockUntil\n    );\n\n    if (locked) {\n      console.log(\n        `[QueueService] Lock acquired for job ${job.id.value}. Moving to active.`\n      );\n      job.moveToActive(workerId, lockUntil);\n      await this.jobRepository.update(job);\n      this.emit(\"job.active\", job);\n      return job;\n    }\n    console.log(\n      `[QueueService] Failed to acquire lock for job ${job.id.value}.`\n    );\n    return null;\n  }\n\n  async extendJobLock(\n    jobId: string | JobIdVO,\n    workerId: string,\n    lockDurationMs: number\n  ): Promise<void> {\n    const id = jobId instanceof JobIdVO ? jobId : JobIdVO.create(jobId);\n    const job = await this.getJob(id);\n    if (job && job.workerId === workerId && job.status === JobStatus.ACTIVE) {\n      const newLockUntil = new Date(Date.now() + lockDurationMs);\n      job.extendLock(newLockUntil, workerId);\n      await this.jobRepository.update(job);\n      this.emit(\"job.lock.extended\", job);\n    }\n  }\n\n  async markJobAsCompleted(\n    jobId: string | JobIdVO,\n    workerId: string,\n    result: R,\n    _jobInstanceWithChanges?: JobEntity<P, R>\n  ): Promise<void> {\n    // Param removed/ignored\n    const id = jobId instanceof JobIdVO ? jobId : JobIdVO.create(jobId);\n    const job = await this.getJob(id);\n    if (job && job.workerId === workerId) {\n      job.markAsCompleted(result);\n      await this.jobRepository.update(job);\n      this.emit(\"job.completed\", job);\n    }\n  }\n\n  async markJobAsFailed(\n    jobId: string | JobIdVO,\n    workerId: string,\n    error: Error,\n    _jobInstanceWithChanges?: JobEntity<P, R>\n  ): Promise<void> {\n    // Param removed/ignored\n    const id = jobId instanceof JobIdVO ? jobId : JobIdVO.create(jobId);\n    const job = await this.getJob(id);\n    if (job && job.workerId === workerId) {\n      this._handleFailedJobRetryOrPermanentFail(job, error);\n      await this.jobRepository.update(job);\n      this.emit(\"job.failed\", job);\n    }\n  }\n\n  private _handleFailedJobRetryOrPermanentFail(job: JobEntity<P,R>, error: Error): void {\n    if (job.attemptsMade < job.maxAttempts) {\n      const delay = job.options.backoff?.delay || 1000; // Default to 1s\n      let backoffDelay = delay;\n      if (job.options.backoff?.type === \"exponential\") {\n        // Ensure attemptsMade is at least 1 for exponential calculation if it's 0-indexed internally before this point\n        const currentAttemptForBackoff = Math.max(1, job.attemptsMade);\n        backoffDelay = delay * Math.pow(2, currentAttemptForBackoff -1);\n      }\n      // Cap backoff delay to a reasonable maximum, e.g., 1 hour\n      const maxBackoff = job.options.backoff?.maxDelay || 60 * 60 * 1000;\n      backoffDelay = Math.min(backoffDelay, maxBackoff);\n\n      job.moveToDelayed(new Date(Date.now() + backoffDelay), error);\n    } else {\n      job.markAsFailed(error.message, error.stack?.split(\"\\n\"));\n    }\n  }\n\n  async updateJobProgress(\n    jobId: string | JobIdVO,\n    workerId: string,\n    progress: number | object\n  ): Promise<void> {\n    const id = jobId instanceof JobIdVO ? jobId : JobIdVO.create(jobId);\n    const job = await this.getJob(id);\n    if (job && job.workerId === workerId) {\n      job.updateProgress(progress);\n      await this.jobRepository.update(job);\n      this.emit(\"job.progress\", job);\n    }\n  }\n\n  async addJobLog(\n    jobId: string | JobIdVO,\n    workerId: string,\n    message: string,\n    level?: string\n  ): Promise<void> {\n    const id = jobId instanceof JobIdVO ? jobId : JobIdVO.create(jobId);\n    const job = await this.getJob(id);\n    if (job && job.workerId === workerId) {\n      job.addLog(message, level);\n      await this.jobRepository.update(job);\n      this.emit(\"job.log\", job);\n    }\n  }\n\n  public startMaintenance(): void {\n    if (this._isMaintenanceRunning) return;\n    this._isMaintenanceRunning = true;\n    this.maintenanceLoopPromise = this.runMaintenanceLoop();\n    // console.log('[QueueService] Maintenance loop started.');\n  }\n\n  private async runMaintenanceLoop(): Promise<void> {\n    while (this._isMaintenanceRunning) {\n      try {\n        const stalledJobs = await this.jobRepository.findStalledJobs(\n          this.queueName,\n          new Date(),\n          10 // Limit fetching to 10 stalled jobs per cycle\n        );\n        for (const job of stalledJobs) {\n          await this._processStalledJob(job as JobEntity<P, R>);\n        }\n      } catch (error) {\n        console.error(\n          \"[QueueService] Error during stalled job maintenance:\",\n          error\n        );\n        this.emit(\n          \"queue.error\",\n          new Error(\n            `Stalled job maintenance error: ${error instanceof Error ? error.message : String(error)}`\n          )\n        );\n      }\n\n      if (this._isMaintenanceRunning) {\n        try {\n          await new Promise((resolve) =>\n            setTimeout(resolve, this.maintenanceIntervalMs)\n          );\n        } catch (error) {\n          console.error(\n            \"[QueueService] Error during maintenance sleep:\",\n            error\n          );\n        }\n      }\n    }\n    // console.log('[QueueService] Maintenance loop stopped.');\n  }\n\n  private async _processStalledJob(jobEntity: JobEntity<P, R>): Promise<void> {\n    // console.log(`[QueueService] Processing stalled job ${jobEntity.id.value}, status: ${jobEntity.status}, attempts: ${jobEntity.attemptsMade}`);\n    const wasAlreadyFailedByStallLogic = jobEntity.markAsStalled();\n\n    if (!wasAlreadyFailedByStallLogic) {\n      jobEntity.moveToWaiting();\n      // console.log(`[QueueService] Stalled job ${jobEntity.id.value} moved to WAITING.`);\n    } else {\n      // console.log(`[QueueService] Stalled job ${jobEntity.id.value} marked as FAILED by entity logic.`);\n    }\n    await this.jobRepository.update(jobEntity);\n    this.emit(\"job.stalled\", jobEntity);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/services/logger/console-logger.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/services/tool-registry/tool-registry.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/tools/file-system.tool.ts","messages":[{"ruleId":"no-inline-comments","severity":2,"message":"Unexpected comment inline with code.","line":15,"column":42,"nodeType":"Line","messageId":"unexpectedInlineComment","endLine":15,"endColumn":53},{"ruleId":"no-inline-comments","severity":2,"message":"Unexpected comment inline with code.","line":19,"column":43,"nodeType":"Line","messageId":"unexpectedInlineComment","endLine":19,"endColumn":54},{"ruleId":"no-inline-comments","severity":2,"message":"Unexpected comment inline with code.","line":24,"column":43,"nodeType":"Line","messageId":"unexpectedInlineComment","endLine":24,"endColumn":54}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":88,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":88,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2985,2988],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2985,2988],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as fs from \"fs/promises\";\n\nimport { injectable, inject } from \"inversify\";\nimport { z, ZodAny } from \"zod\";\n\nimport { ILoggerService } from \"@/core/common/services/i-logger.service\";\nimport { IAgentTool, IToolExecutionContext } from \"@/core/tools/tool.interface\";\n\nimport { ToolError } from \"@/domain/common/errors\";\n\nimport { TYPES } from \"@/infrastructure/ioc/types\";\n\nimport { Result, Ok, Err } from \"@/shared/result\";\n\nconst _ReadFileParamsSchema = z.object({ // Prefixed\n  filePath: z.string().describe(\"The path to the file to read.\"),\n});\n\nconst _WriteFileParamsSchema = z.object({ // Prefixed\n  filePath: z.string().describe(\"The path to the file to write.\"),\n  content: z.string().describe(\"The content to write to the file.\"),\n});\n\nconst _ListFilesParamsSchema = z.object({ // Prefixed\n  directoryPath: z\n    .string()\n    .describe(\"The path to the directory to list files from.\"),\n});\n\n@injectable()\nexport class FileSystemTool implements IAgentTool<ZodAny, unknown> {\n  public readonly name = \"fileSystem\";\n  public readonly description =\n    \"A tool for interacting with the file system, like reading, writing, and listing files.\";\n\n  public readonly parameters = z.object({\n    action: z\n      .enum([\"readFile\", \"writeFile\", \"listFiles\"])\n      .describe(\"The action to perform.\"),\n    filePath: z\n      .string()\n      .optional()\n      .describe(\"Path to the file (for readFile, writeFile).\"),\n    directoryPath: z\n      .string()\n      .optional()\n      .describe(\"Path to the directory (for listFiles).\"),\n    content: z\n      .string()\n      .optional()\n      .describe(\"Content to write (for writeFile).\"),\n  });\n\n  constructor(\n    @inject(TYPES.ILoggerService) private readonly logger: ILoggerService\n  ) {\n    this.logger.info(\"[FileSystemTool] initialized\");\n  }\n\n  async execute(\n    params: z.infer<typeof this.parameters>,\n    _executionContext?: IToolExecutionContext\n  ): Promise<Result<string | string[], ToolError>> {\n    this.logger.info(`[FileSystemTool] executing action: ${params.action}`);\n    try {\n      switch (params.action) {\n        case \"readFile\": {\n          if (!params.filePath)\n            return Err(new ToolError(\"filePath is required for readFile.\"));\n          return this._handleReadFile(params.filePath);\n        }\n        case \"writeFile\": {\n          if (!params.filePath)\n            return Err(new ToolError(\"filePath is required for writeFile.\"));\n          if (!params.content)\n            return Err(new ToolError(\"content is required for writeFile.\"));\n          return this._handleWriteFile(params.filePath, params.content);\n        }\n        case \"listFiles\": {\n          if (!params.directoryPath)\n            return Err(\n              new ToolError(\"directoryPath is required for listFiles.\")\n            );\n          return this._handleListFiles(params.directoryPath);\n        }\n        default: {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          const action = (params as any).action;\n          return Err(new ToolError(`Unknown fileSystem action: ${action}`));\n        }\n      }\n    } catch (error: unknown) {\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n      this.logger.error(\n        `[FileSystemTool] Error during ${params.action}: ${errorMessage}`\n      );\n      return Err(\n        new ToolError(\n          `FileSystemTool action ${params.action} failed: ${errorMessage}`\n        )\n      );\n    }\n  }\n\n  private async _handleReadFile(\n    filePath: string\n  ): Promise<Result<string, ToolError>> {\n    if (filePath.includes(\"..\"))\n      return Err(new ToolError(\"Invalid file path (path traversal detected).\"));\n    try {\n      const content = await fs.readFile(filePath, \"utf-8\");\n      return Ok(content);\n    } catch (error) {\n      return Err(this._createError(\"readFile\", error));\n    }\n  }\n\n  private async _handleWriteFile(\n    filePath: string,\n    content: string\n  ): Promise<Result<string, ToolError>> {\n    if (filePath.includes(\"..\"))\n      return Err(new ToolError(\"Invalid file path (path traversal detected).\"));\n    try {\n      await fs.writeFile(filePath, content, \"utf-8\");\n      return Ok(`File written successfully to ${filePath}`);\n    } catch (error) {\n      return Err(this._createError(\"writeFile\", error));\n    }\n  }\n\n  private async _handleListFiles(\n    directoryPath: string\n  ): Promise<Result<string[], ToolError>> {\n    if (directoryPath.includes(\"..\"))\n      return Err(\n        new ToolError(\"Invalid directory path (path traversal detected).\")\n      );\n    try {\n      const files = await fs.readdir(directoryPath);\n      return Ok(files);\n    } catch (error) {\n      return Err(this._createError(\"listFiles\", error));\n    }\n  }\n\n  private _createError(action: string, error: unknown): ToolError {\n    const errorMessage =\n      error instanceof Error ? error.message : String(error);\n    this.logger.error(\n      `[FileSystemTool] Error during ${action}: ${errorMessage}`\n    );\n    return new ToolError(\n      `FileSystemTool action ${action} failed: ${errorMessage}`\n    );\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/electron/main/handlers/agent-instance.handlers.ts","messages":[{"ruleId":"no-inline-comments","severity":2,"message":"Unexpected comment inline with code.","line":20,"column":40,"nodeType":"Line","messageId":"unexpectedInlineComment","endLine":20,"endColumn":57},{"ruleId":"@typescript-eslint/naming-convention","severity":1,"message":"Function name `_registerQueryAgentInstanceHandlers` must match one of the following formats: camelCase, PascalCase","line":25,"column":10,"nodeType":"Identifier","messageId":"doesNotMatchFormat","endLine":25,"endColumn":45},{"ruleId":"max-lines-per-function","severity":2,"message":"Function '_registerMutationAgentInstanceHandlers' has too many lines (61). Maximum allowed is 50.","line":66,"column":1,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":127,"endColumn":2},{"ruleId":"@typescript-eslint/naming-convention","severity":1,"message":"Function name `_registerMutationAgentInstanceHandlers` must match one of the following formats: camelCase, PascalCase","line":66,"column":10,"nodeType":"Identifier","messageId":"doesNotMatchFormat","endLine":66,"endColumn":48}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ipcMain } from \"electron\";\n\nimport {\n  GET_AGENT_INSTANCES_CHANNEL,\n  GET_AGENT_INSTANCE_DETAILS_CHANNEL,\n  CREATE_AGENT_INSTANCE_CHANNEL,\n  UPDATE_AGENT_INSTANCE_CHANNEL,\n  GET_AGENT_INSTANCES_BY_PROJECT_CHANNEL,\n} from \"../../../../shared/ipc-channels\";\nimport {\n  GetAgentInstancesResponse,\n  GetAgentInstanceDetailsRequest,\n  GetAgentInstanceDetailsResponse,\n  CreateAgentInstanceRequest,\n  CreateAgentInstanceResponse,\n  UpdateAgentInstanceRequest,\n  UpdateAgentInstanceResponse,\n  GetAgentInstancesByProjectRequest,\n  GetAgentInstancesByProjectResponse,\n} from \"../../../../shared/ipc-types\"; // Corrected path\nimport { AgentInstance } from \"../../../../shared/types/entities\";\nimport { AgentLLM } from \"../../../../shared/types/entities\";\nimport { mockAgentInstances } from \"../mocks/agent-instance.mocks\";\n\nfunction _registerQueryAgentInstanceHandlers() {\n  ipcMain.handle(\n    GET_AGENT_INSTANCES_CHANNEL,\n    async (): Promise<GetAgentInstancesResponse> => {\n      await new Promise((resolve) => setTimeout(resolve, 50));\n      return { agentInstances: mockAgentInstances };\n    }\n  );\n\n  ipcMain.handle(\n    GET_AGENT_INSTANCES_BY_PROJECT_CHANNEL,\n    async (\n      _event,\n      req: GetAgentInstancesByProjectRequest\n    ): Promise<GetAgentInstancesByProjectResponse> => {\n      await new Promise((resolve) => setTimeout(resolve, 50));\n      const instances = mockAgentInstances.filter(\n        (ai) => ai.projectId === req.projectId\n      );\n      return { agentInstances: instances };\n    }\n  );\n\n  ipcMain.handle(\n    GET_AGENT_INSTANCE_DETAILS_CHANNEL,\n    async (\n      _event,\n      req: GetAgentInstanceDetailsRequest\n    ): Promise<GetAgentInstanceDetailsResponse> => {\n      await new Promise((resolve) => setTimeout(resolve, 50));\n      const instance = mockAgentInstances.find(\n        (ai) => ai.id === req.instanceId\n      );\n      if (instance) {\n        return { agentInstance: instance };\n      }\n      return { agentInstance: undefined, error: \"Agent Instance not found\" };\n    }\n  );\n}\n\nfunction _registerMutationAgentInstanceHandlers() {\n  ipcMain.handle(\n    CREATE_AGENT_INSTANCE_CHANNEL,\n    async (\n      _event,\n      req: CreateAgentInstanceRequest\n    ): Promise<CreateAgentInstanceResponse> => {\n      await new Promise((resolve) => setTimeout(resolve, 50));\n      const newInstance: AgentInstance = {\n        id: `agent-${Date.now()}`,\n        name: req.name,\n        personaTemplateId: req.personaTemplateId,\n        projectId: req.projectId,\n        llmConfig: req.llmConfig || {\n          llm: AgentLLM.OPENAI_GPT_4_TURBO,\n          temperature: 0.7,\n          maxTokens: 2048,\n        },\n        tools: req.tools || [],\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n      };\n      mockAgentInstances.push(newInstance);\n      return { agentInstance: newInstance };\n    }\n  );\n\n  ipcMain.handle(\n    UPDATE_AGENT_INSTANCE_CHANNEL,\n    async (\n      _event,\n      req: UpdateAgentInstanceRequest\n    ): Promise<UpdateAgentInstanceResponse> => {\n      await new Promise((resolve) => setTimeout(resolve, 50));\n      const instanceIndex = mockAgentInstances.findIndex(\n        (ai) => ai.id === req.instanceId\n      );\n      if (instanceIndex !== -1) {\n        const currentInstance = mockAgentInstances[instanceIndex];\n        const updatedInstance = {\n          ...currentInstance,\n          ...req.updates,\n          ...(req.updates.llmConfig && currentInstance.llmConfig\n            ? {\n                llmConfig: {\n                  ...currentInstance.llmConfig,\n                  ...req.updates.llmConfig,\n                },\n              }\n            : currentInstance.llmConfig),\n          updatedAt: new Date().toISOString(),\n        };\n        mockAgentInstances[instanceIndex] = updatedInstance;\n        return { agentInstance: updatedInstance };\n      }\n      return {\n        agentInstance: undefined,\n        error: \"Agent Instance not found for update\",\n      };\n    }\n  );\n}\n\nexport function registerAgentInstanceHandlers() {\n  _registerQueryAgentInstanceHandlers();\n  _registerMutationAgentInstanceHandlers();\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/electron/main/handlers/dm.handlers.ts","messages":[{"ruleId":"no-inline-comments","severity":2,"message":"Unexpected comment inline with code.","line":16,"column":40,"nodeType":"Line","messageId":"unexpectedInlineComment","endLine":16,"endColumn":57},{"ruleId":"max-lines-per-function","severity":2,"message":"Async function '_handleSendDMMessage' has too many lines (54). Maximum allowed is 50.","line":33,"column":1,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":91,"endColumn":2},{"ruleId":"@typescript-eslint/naming-convention","severity":1,"message":"Function name `_handleSendDMMessage` must match one of the following formats: camelCase, PascalCase","line":33,"column":16,"nodeType":"Identifier","messageId":"doesNotMatchFormat","endLine":33,"endColumn":36},{"ruleId":"no-undef","severity":2,"message":"'Electron' is not defined.","line":34,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":34,"endColumn":19},{"ruleId":"@typescript-eslint/naming-convention","severity":1,"message":"Function name `_registerQueryDMHandlers` must match one of the following formats: camelCase, PascalCase","line":93,"column":10,"nodeType":"Identifier","messageId":"doesNotMatchFormat","endLine":93,"endColumn":34},{"ruleId":"no-undef","severity":2,"message":"'Electron' is not defined.","line":102,"column":15,"nodeType":"Identifier","messageId":"undef","endLine":102,"endColumn":23},{"ruleId":"id-length","severity":1,"message":"Identifier name 'd' is too short (< 2).","line":106,"column":32,"nodeType":"Identifier","messageId":"tooShort","endLine":106,"endColumn":33}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ipcMain, BrowserWindow } from \"electron\";\n\nimport {\n  GET_DMS_CHANNEL,\n  GET_DM_DETAILS_CHANNEL,\n  SEND_DM_MESSAGE_CHANNEL,\n  DM_MESSAGE_RECEIVED_CHANNEL,\n} from \"../../../../shared/ipc-channels\";\nimport {\n  GetDMsResponse,\n  GetDMDetailsRequest,\n  GetDMDetailsResponse,\n  SendDMMessageRequest,\n  SendDMMessageResponse,\n  DMMessageReceivedPayload,\n} from \"../../../../shared/ipc-types\"; // Corrected path\nimport { Message } from \"../../../../shared/types/entities\";\nimport { mockDMs, addMessageToMockDM } from \"../mocks/dm.mocks\";\n\nfunction notifyAllWindows(channel: string, payload: unknown) {\n  BrowserWindow.getAllWindows().forEach((win) => {\n    if (\n      !win.isDestroyed() &&\n      win.webContents &&\n      !win.webContents.isDestroyed()\n    ) {\n      win.webContents.send(channel, payload);\n    }\n  });\n}\n\n// Helper function to handle the logic for sending a DM message\nasync function _handleSendDMMessage(\n  _event: Electron.IpcMainInvokeEvent,\n  req: SendDMMessageRequest\n): Promise<SendDMMessageResponse> {\n  await new Promise((resolve) => setTimeout(resolve, 50));\n  const { dmId, content, senderId } = req;\n\n  const newMessage: Message = {\n    id: `msg-${Date.now()}`,\n    conversationId: dmId,\n    senderId: senderId,\n    content: content,\n    contentType: \"text\",\n    timestamp: new Date().toISOString(),\n  };\n\n  const updatedDM = addMessageToMockDM(dmId, newMessage);\n\n  if (updatedDM) {\n    const notificationPayload: DMMessageReceivedPayload = {\n      dmId: dmId,\n      message: newMessage,\n    };\n    notifyAllWindows(DM_MESSAGE_RECEIVED_CHANNEL, notificationPayload);\n\n    // Simulate agent reply\n    const dmParticipants = updatedDM.participantIds || [];\n    if (senderId !== \"agent-1\" && dmParticipants.includes(\"agent-1\")) {\n      setTimeout(() => {\n        const agentReply: Message = {\n          id: `msg-agent-${Date.now()}`,\n          conversationId: dmId,\n          senderId: \"agent-1\",\n          content: `Got it! You said: \"${content.substring(0, 30)}${\n            content.length > 30 ? \"...\" : \"\"\n          }\"`,\n          contentType: \"text\",\n          timestamp: new Date().toISOString(),\n        };\n        const finalDM = addMessageToMockDM(dmId, agentReply);\n        if (finalDM) {\n          const agentNotificationPayload: DMMessageReceivedPayload = {\n            dmId: dmId,\n            message: agentReply,\n          };\n          notifyAllWindows(\n            DM_MESSAGE_RECEIVED_CHANNEL,\n            agentNotificationPayload\n          );\n        }\n      }, 1000 + Math.random() * 1000);\n    }\n    return { success: true, message: newMessage };\n  }\n  return {\n    success: false,\n    error: \"DM not found or failed to send message\",\n  };\n}\n\nfunction _registerQueryDMHandlers() {\n  ipcMain.handle(GET_DMS_CHANNEL, async (): Promise<GetDMsResponse> => {\n    await new Promise((resolve) => setTimeout(resolve, 50));\n    return { dms: mockDMs };\n  });\n\n  ipcMain.handle(\n    GET_DM_DETAILS_CHANNEL,\n    async (\n      _event: Electron.IpcMainInvokeEvent,\n      req: GetDMDetailsRequest\n    ): Promise<GetDMDetailsResponse> => {\n      await new Promise((resolve) => setTimeout(resolve, 50));\n      const dm = mockDMs.find((d) => d.id === req.dmId);\n      if (dm) {\n        return { dm };\n      }\n      return { dm: undefined, error: \"DM not found\" };\n    }\n  );\n}\n\nexport function registerDMHandlers() {\n  _registerQueryDMHandlers();\n  ipcMain.handle(SEND_DM_MESSAGE_CHANNEL, _handleSendDMMessage);\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/electron/main/handlers/llm-config.handlers.ts","messages":[{"ruleId":"import/no-unresolved","severity":2,"message":"Unable to resolve path to module '../../../../shared/ipc-types/llm-config'.","line":13,"column":8,"nodeType":"Literal","endLine":13,"endColumn":49}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ipcMain } from 'electron';\n\nimport {\n  GET_AVAILABLE_LLMS_CHANNEL,\n  GET_USER_LLM_CONFIGS_CHANNEL,\n  UPDATE_USER_LLM_CONFIG_CHANNEL,\n} from '../../../../shared/ipc-channels';\nimport {\n  GetAvailableLLMsResponse,\n  GetUserLLMConfigsResponse,\n  UpdateUserLLMConfigRequest,\n  UpdateUserLLMConfigResponse\n} from '../../../../shared/ipc-types/llm-config';\nimport { AgentLLM, LLMConfig } from '../../../../shared/types/entities';\nimport {\n  mockAvailableLLMs,\n  // mockUserLLMConfigs, // Not directly used, access via getLLMConfigWithDefaults or updateUserLLMConfig\n  updateUserLLMConfig,\n  getLLMConfigWithDefaults\n} from '../mocks/llm-config.mocks';\n\nexport function registerLLMConfigHandlers() {\n  ipcMain.handle(GET_AVAILABLE_LLMS_CHANNEL, async (): Promise<GetAvailableLLMsResponse> => {\n    await new Promise(resolve => setTimeout(resolve, 50));\n    return { availableLLMs: mockAvailableLLMs };\n  });\n\n  ipcMain.handle(GET_USER_LLM_CONFIGS_CHANNEL, async (): Promise<GetUserLLMConfigsResponse> => {\n    await new Promise(resolve => setTimeout(resolve, 50));\n    // Construct full configs with defaults for all available LLMs\n    const fullUserConfigs = Object.values(AgentLLM).reduce((acc, llmKey) => {\n      // Ensure llmKey is treated as a key of AgentLLM enum\n      const key = llmKey as AgentLLM;\n      acc[key] = getLLMConfigWithDefaults(key);\n      return acc;\n    }, {} as Record<AgentLLM, LLMConfig>); \n\n    return { userLLMConfigs: fullUserConfigs };\n  });\n\n  ipcMain.handle(UPDATE_USER_LLM_CONFIG_CHANNEL, async (_event, req: UpdateUserLLMConfigRequest): Promise<UpdateUserLLMConfigResponse> => {\n    await new Promise(resolve => setTimeout(resolve, 50));\n    const { llm, config } = req;\n    updateUserLLMConfig(llm, config);\n    const updatedConfig = getLLMConfigWithDefaults(llm);\n    return { updatedConfig: updatedConfig };\n  });\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/electron/main/handlers/persona-template.handlers.ts","messages":[{"ruleId":"no-inline-comments","severity":2,"message":"Unexpected comment inline with code.","line":17,"column":40,"nodeType":"Line","messageId":"unexpectedInlineComment","endLine":17,"endColumn":57}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ipcMain } from 'electron';\n\nimport {\n  GET_PERSONA_TEMPLATES_CHANNEL,\n  GET_PERSONA_TEMPLATE_DETAILS_CHANNEL,\n  CREATE_PERSONA_TEMPLATE_CHANNEL,\n  UPDATE_PERSONA_TEMPLATE_CHANNEL,\n} from '../../../../shared/ipc-channels';\nimport {\n  GetPersonaTemplatesResponse,\n  GetPersonaTemplateDetailsRequest,\n  GetPersonaTemplateDetailsResponse,\n  CreatePersonaTemplateRequest,\n  CreatePersonaTemplateResponse,\n  UpdatePersonaTemplateRequest,\n  UpdatePersonaTemplateResponse,\n} from '../../../../shared/ipc-types'; // Corrected path\nimport { PersonaTemplate } from '../../../../shared/types/entities';\nimport { mockPersonaTemplates } from '../mocks/persona-template.mocks';\n\nexport function registerPersonaTemplateHandlers() {\n  ipcMain.handle(GET_PERSONA_TEMPLATES_CHANNEL, async (): Promise<GetPersonaTemplatesResponse> => {\n    await new Promise(resolve => setTimeout(resolve, 50));\n    return { personaTemplates: mockPersonaTemplates };\n  });\n\n  ipcMain.handle(GET_PERSONA_TEMPLATE_DETAILS_CHANNEL, async (_event, req: GetPersonaTemplateDetailsRequest): Promise<GetPersonaTemplateDetailsResponse> => {\n    await new Promise(resolve => setTimeout(resolve, 50));\n    const template = mockPersonaTemplates.find(pt => pt.id === req.templateId);\n    if (template) {\n      return { personaTemplate: template };\n    }\n      return { personaTemplate: undefined, error: 'Persona Template not found' };\n\n  });\n\n  ipcMain.handle(CREATE_PERSONA_TEMPLATE_CHANNEL, async (_event, req: CreatePersonaTemplateRequest): Promise<CreatePersonaTemplateResponse> => {\n    await new Promise(resolve => setTimeout(resolve, 50));\n    const newTemplate: PersonaTemplate = {\n      id: `pt-${Date.now()}`,\n      name: req.name,\n      description: req.description,\n      systemPrompt: req.systemPrompt,\n      visionEnabled: req.visionEnabled || false,\n      exampleConversations: req.exampleConversations || [],\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n    };\n    // In a real scenario, you'd add this to your persistent or in-memory store\n    mockPersonaTemplates.push(newTemplate);\n    return { personaTemplate: newTemplate };\n  });\n\n  ipcMain.handle(UPDATE_PERSONA_TEMPLATE_CHANNEL, async (_event, req: UpdatePersonaTemplateRequest): Promise<UpdatePersonaTemplateResponse> => {\n    await new Promise(resolve => setTimeout(resolve, 50));\n    const templateIndex = mockPersonaTemplates.findIndex(pt => pt.id === req.templateId);\n    if (templateIndex !== -1) {\n      const updatedTemplate = { ...mockPersonaTemplates[templateIndex], ...req.updates, updatedAt: new Date().toISOString() };\n      mockPersonaTemplates[templateIndex] = updatedTemplate;\n      return { personaTemplate: updatedTemplate };\n    }\n      return { personaTemplate: undefined, error: 'Persona Template not found for update' };\n\n  });\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/electron/main/handlers/project.handlers.ts","messages":[{"ruleId":"no-inline-comments","severity":2,"message":"Unexpected comment inline with code.","line":18,"column":40,"nodeType":"Line","messageId":"unexpectedInlineComment","endLine":18,"endColumn":57},{"ruleId":"@typescript-eslint/naming-convention","severity":1,"message":"Function name `_registerQueryProjectHandlers` must match one of the following formats: camelCase, PascalCase","line":27,"column":10,"nodeType":"Identifier","messageId":"doesNotMatchFormat","endLine":27,"endColumn":39},{"ruleId":"@typescript-eslint/naming-convention","severity":1,"message":"Function name `_registerMutationProjectHandlers` must match one of the following formats: camelCase, PascalCase","line":54,"column":10,"nodeType":"Identifier","messageId":"doesNotMatchFormat","endLine":54,"endColumn":42}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ipcMain } from \"electron\";\n\nimport {\n  GET_PROJECTS_CHANNEL,\n  GET_PROJECT_DETAILS_CHANNEL,\n  CREATE_PROJECT_CHANNEL,\n  UPDATE_PROJECT_CHANNEL,\n  // DELETE_PROJECT_CHANNEL, // Example for later\n} from \"../../../../shared/ipc-channels\";\nimport {\n  GetProjectDetailsRequest,\n  GetProjectDetailsResponse,\n  GetProjectsResponse,\n  CreateProjectRequest,\n  CreateProjectResponse,\n  UpdateProjectRequest,\n  UpdateProjectResponse,\n} from \"../../../../shared/ipc-types\"; // Corrected path\nimport { Project } from \"../../../../shared/types/entities\";\nimport { AgentLLM } from \"../../../../shared/types/entities\";\nimport {\n  mockProjects,\n  addMockProject,\n  updateMockProject,\n} from \"../mocks/project.mocks\";\n\nfunction _registerQueryProjectHandlers() {\n  ipcMain.handle(\n    GET_PROJECTS_CHANNEL,\n    async (): Promise<GetProjectsResponse> => {\n      await new Promise((resolve) => setTimeout(resolve, 50));\n      return { projects: mockProjects };\n    }\n  );\n\n  ipcMain.handle(\n    GET_PROJECT_DETAILS_CHANNEL,\n    async (\n      _event,\n      req: GetProjectDetailsRequest\n    ): Promise<GetProjectDetailsResponse> => {\n      await new Promise((resolve) => setTimeout(resolve, 50));\n      const projectDetails = mockProjects.find(\n        (project) => project.id === req.projectId\n      );\n      if (projectDetails) {\n        return { project: projectDetails };\n      }\n      return { project: undefined, error: \"Project not found\" };\n    }\n  );\n}\n\nfunction _registerMutationProjectHandlers() {\n  ipcMain.handle(\n    CREATE_PROJECT_CHANNEL,\n    async (\n      _event,\n      req: CreateProjectRequest\n    ): Promise<CreateProjectResponse> => {\n      await new Promise((resolve) => setTimeout(resolve, 50));\n      const newProject: Project = {\n        id: `proj-${Date.now()}`,\n        name: req.name,\n        description: req.description,\n        platformUrl: req.platformUrl,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        projectManager: \"user-123\",\n        teamMembers: [\"user-123\"],\n        status: \"active\",\n        version: \"1.0.0\",\n        repositoryUrl: req.repositoryUrl,\n        tags: req.tags || [],\n        llmConfig: req.llmConfig || {\n          llm: AgentLLM.OPENAI_GPT_4_TURBO,\n          temperature: 0.7,\n          maxTokens: 2048,\n        },\n        // agentInstances: [], // Assuming this might be populated later or via another mechanism\n      };\n      addMockProject(newProject);\n      return { project: newProject };\n    }\n  );\n\n  ipcMain.handle(\n    UPDATE_PROJECT_CHANNEL,\n    async (\n      _event,\n      req: UpdateProjectRequest\n    ): Promise<UpdateProjectResponse> => {\n      await new Promise((resolve) => setTimeout(resolve, 50));\n      const updatedProject = updateMockProject(req.projectId, req.updates);\n      if (updatedProject) {\n        return { project: updatedProject };\n      }\n      return { project: undefined, error: \"Project not found for update\" };\n    }\n  );\n}\n\nexport function registerProjectHandlers() {\n  _registerQueryProjectHandlers();\n  _registerMutationProjectHandlers();\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/electron/main/handlers/user.handlers.ts","messages":[{"ruleId":"no-inline-comments","severity":2,"message":"Unexpected comment inline with code.","line":11,"column":40,"nodeType":"Line","messageId":"unexpectedInlineComment","endLine":11,"endColumn":57}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ipcMain } from 'electron';\n\nimport {\n  GET_USER_PROFILE_CHANNEL,\n  UPDATE_USER_PROFILE_CHANNEL,\n} from '../../../../shared/ipc-channels';\nimport {\n  GetUserProfileResponse,\n  UpdateUserProfileRequest,\n  UpdateUserProfileResponse,\n} from '../../../../shared/ipc-types'; // Corrected path\nimport { mockUserProfile, updateMockUserProfile } from '../mocks/user.mocks';\n\nexport function registerUserHandlers() {\n  ipcMain.handle(GET_USER_PROFILE_CHANNEL, async (): Promise<GetUserProfileResponse> => {\n    await new Promise(resolve => setTimeout(resolve, 50));\n    return { userProfile: mockUserProfile };\n  });\n\n  ipcMain.handle(UPDATE_USER_PROFILE_CHANNEL, async (_event, req: UpdateUserProfileRequest): Promise<UpdateUserProfileResponse> => {\n    await new Promise(resolve => setTimeout(resolve, 50));\n    const updatedProfile = updateMockUserProfile(req.updates);\n    return { userProfile: updatedProfile };\n  });\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/electron/main/ipc-chat.handlers.ts","messages":[{"ruleId":"no-redeclare","severity":2,"message":"'IChatService' is already defined.","line":5,"column":3,"nodeType":"Identifier","messageId":"redeclared","endLine":5,"endColumn":15},{"ruleId":"@typescript-eslint/naming-convention","severity":1,"message":"Function name `_handleChatSendMessage` must match one of the following formats: camelCase, PascalCase","line":34,"column":16,"nodeType":"Identifier","messageId":"doesNotMatchFormat","endLine":34,"endColumn":38},{"ruleId":"no-inline-comments","severity":2,"message":"Unexpected comment inline with code.","line":90,"column":31,"nodeType":"Line","messageId":"unexpectedInlineComment","endLine":90,"endColumn":62}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ipcMain, IpcMainInvokeEvent } from \"electron\";\n\nimport {\n  IChatService,\n  IChatService,\n  // CHAT_SERVICE_TOKEN, // No longer used directly here\n} from \"@/core/application/ports/services/i-chat.service\";\n\n// import { appContainer } from \"@/infrastructure/ioc/inversify.config\"; // Removed import\n\nimport { IPCChannel } from \"@/shared/ipc-channels\";\nimport {\n  ChatSendMessagePayload,\n  ChatStreamEventPayload,\n} from \"@/shared/ipc-chat.types\";\n\nlet internalChatService: IChatService | null = null;\n\n// Removed initializeChatService as service is now injected.\n\nexport function registerChatIPCHandlers(chatServiceInstance: IChatService): void {\n  if (!chatServiceInstance) {\n    console.error(\"[IPC Chat Handler] CRITICAL: Provided chatServiceInstance is null or undefined.\");\n    // Optionally, throw an error or handle this case more gracefully\n    // For now, internalChatService will remain null, and handlers will fail.\n  }\n  internalChatService = chatServiceInstance;\n\n  ipcMain.handle(IPCChannel.CHAT_SEND_MESSAGE, _handleChatSendMessage);\n\n  console.log(\"[IPC Chat Handler] Chat IPC handlers registered.\");\n}\n\nasync function _handleChatSendMessage(\n  event: IpcMainInvokeEvent,\n  payload: ChatSendMessagePayload\n) {\n  console.log(\n    `[IPC Chat Handler] Received ${IPCChannel.CHAT_SEND_MESSAGE} for session: ${payload.sessionId}`\n  );\n\n  if (!internalChatService) {\n    console.error(\n      \"[IPC Chat Handler] ChatService not available. It might not have been initialized correctly or passed to registerChatIPCHandlers.\"\n    );\n    const errorEvent: ChatStreamEventPayload = {\n      type: \"error\",\n      error: {\n        name: \"ServiceError\",\n        message: \"ChatService not available in main process.\",\n      },\n    };\n    if (!event.sender.isDestroyed()) {\n      event.sender.send(IPCChannel.CHAT_STREAM_EVENT, errorEvent);\n    }\n    const endEvent: ChatStreamEventPayload = { type: \"end\" };\n    if (!event.sender.isDestroyed()) {\n      event.sender.send(IPCChannel.CHAT_STREAM_EVENT, endEvent);\n    }\n    return {\n      success: false,\n      error: { message: \"ChatService not available.\" },\n    };\n  }\n\n  const sendStreamEventCallback = (\n    streamPayload: ChatStreamEventPayload\n  ) => {\n    if (!event.sender.isDestroyed()) {\n      event.sender.send(IPCChannel.CHAT_STREAM_EVENT, streamPayload);\n    }\n  };\n\n  const result = await internalChatService.handleSendMessageStream(\n    payload,\n    sendStreamEventCallback\n  );\n\n  if (result.isSuccess()) {\n    return { success: true, data: result.value };\n  }\n  return {\n    success: false,\n    error: { message: result.error.message, name: result.error.name },\n  };\n}\n\nexport function unregisterChatIPCHandlers(): void {\n  ipcMain.removeHandler(IPCChannel.CHAT_SEND_MESSAGE);\n  internalChatService = null; // Clear the internal reference\n  console.log(\"[IPC Chat Handler] Chat IPC handlers unregistered.\");\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/electron/main/ipc-handlers/agent-instance.handlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/electron/main/ipc-handlers/dm.handlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/electron/main/ipc-handlers/llm-config.handlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/electron/main/ipc-handlers/persona-template.handlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/electron/main/ipc-handlers/project.handlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/electron/main/ipc-handlers/user.handlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/electron/main/ipc-project.handlers.ts","messages":[{"ruleId":"max-lines-per-function","severity":2,"message":"Async function '_handleProjectListQuery' has too many lines (55). Maximum allowed is 50.","line":29,"column":1,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":88,"endColumn":2},{"ruleId":"@typescript-eslint/naming-convention","severity":1,"message":"Function name `_handleProjectListQuery` must match one of the following formats: camelCase, PascalCase","line":29,"column":16,"nodeType":"Identifier","messageId":"doesNotMatchFormat","endLine":29,"endColumn":39},{"ruleId":"no-inline-comments","severity":2,"message":"Unexpected comment inline with code.","line":92,"column":39,"nodeType":"Line","messageId":"unexpectedInlineComment","endLine":92,"endColumn":61}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ipcMain, IpcMainInvokeEvent } from \"electron\";\n\nimport { ListProjectsUseCase } from \"@/core/application/use-cases/project/list-projects.use-case\";\n\n// import { appContainer } from \"@/infrastructure/ioc/inversify.config\"; // Removed import\n\nimport { IPCChannel } from \"@/shared/ipc-channels\";\nimport { ProjectListItem } from \"@/shared/ipc-project.types\";\n\nlet internalListProjectsUseCase: ListProjectsUseCase | null = null;\n\n// Removed initializeUseCases function\n\nexport function registerProjectIPCHandlers(\n  listProjectsUseCaseInstance: ListProjectsUseCase\n): void {\n  if (!listProjectsUseCaseInstance) {\n    console.error(\n      \"[IPC Project Handler] CRITICAL: Provided listProjectsUseCaseInstance is null or undefined.\"\n    );\n  }\n  internalListProjectsUseCase = listProjectsUseCaseInstance;\n\n  ipcMain.handle(IPCChannel.PROJECT_LIST_QUERY, _handleProjectListQuery);\n\n  console.log(\"[IPC Project Handler] Project IPC handlers registered.\");\n}\n\nasync function _handleProjectListQuery(_event: IpcMainInvokeEvent) {\n  console.log(\n    `[IPC Project Handler] Received ${IPCChannel.PROJECT_LIST_QUERY}`\n  );\n  try {\n    if (!internalListProjectsUseCase) {\n      console.error(\n        \"[IPC Project Handler] ListProjectsUseCase not initialized. Ensure it's passed to registerProjectIPCHandlers.\"\n      );\n      return {\n        success: false,\n        error: { message: \"ListProjectsUseCase not available.\" },\n      };\n    }\n\n    const result = await internalListProjectsUseCase.execute();\n\n    if (result.isSuccess()) {\n      const projects = result.value;\n      const projectListItems: ProjectListItem[] = projects.map(\n        (project) => ({\n          id: project.id.value,\n          name: project.name.value,\n          description: project.description?.value,\n          createdAt: project.createdAt.toISOString(),\n          updatedAt: project.updatedAt.toISOString(),\n          // ownerName: project.owner?.name.value, // Example, if Project entity has owner\n          // thumbnailUrl: project.thumbnailUrl?.value, // Example\n        })\n      );\n      console.log(\n        `[IPC Project Handler] Sending ${projectListItems.length} projects.`\n      );\n      return { success: true, data: projectListItems };\n    }\n    console.error(\n      \"[IPC Project Handler] Error listing projects:\",\n      result.error\n    );\n    return {\n      success: false,\n      error: { message: result.error.message, name: result.error.name },\n    };\n  } catch (error: unknown) {\n    console.error(\n      \"[IPC Project Handler] Exception in project:list handler:\",\n      error\n    );\n    // Ensure error.message is accessed safely\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    return {\n      success: false,\n      error: {\n        message:\n          errorMessage ||\n          \"An unexpected error occurred while listing projects.\",\n      },\n    };\n  }\n}\n\nexport function unregisterProjectIPCHandlers(): void {\n  ipcMain.removeHandler(IPCChannel.PROJECT_LIST_QUERY);\n  internalListProjectsUseCase = null; // Clear the reference\n  console.log(\"[IPC Project Handler] Project IPC handlers unregistered.\");\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/electron/main/main.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/electron/main/mocks/agent-instance.mocks.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/electron/main/mocks/dm.mocks.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/electron/main/mocks/llm-config.mocks.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/electron/main/mocks/persona-template.mocks.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/electron/main/mocks/project.mocks.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/electron/main/mocks/user.mocks.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/electron/preload.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/_layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/agents/$agentId/edit/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/agents/$agentId/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/agents/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/agents/new/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/chat/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/dashboard/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/personas/$templateId/edit/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/personas/$templateId/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/personas/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/personas/new/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/projects/$projectId/chat/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/projects/$projectId/docs/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/projects/$projectId/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/projects/$projectId/members/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/projects/$projectId/settings/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/projects/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/projects/new/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/settings/appearance/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/settings/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/settings/llm/$configId/edit/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/settings/llm/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/settings/llm/new/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/settings/profile/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/user/_layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/user/dm/$conversationId/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(app)/user/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/(public)/onboarding/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/__root.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/app/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/common/MarkdownRenderer.tsx","messages":[],"suppressedMessages":[{"ruleId":"jsx-a11y/anchor-has-content","severity":2,"message":"Anchors must have content and the content must be accessible by a screen reader.","line":56,"column":57,"nodeType":"JSXOpeningElement","endLine":56,"endColumn":121,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/common/theme-provider.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/layout/AppSidebar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/accordion.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/alert-dialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/alert.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/aspect-ratio.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/avatar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/badge.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/breadcrumb.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/button.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/calendar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/card.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/carousel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/chart.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/checkbox.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/collapsible.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/command.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/context-menu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/dialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/drawer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/dropdown-menu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/form.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/hover-card.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/input-otp.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/input.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/label.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/navigation-menu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/pagination.tsx","messages":[],"suppressedMessages":[{"ruleId":"jsx-a11y/anchor-has-content","severity":2,"message":"Anchors must have content and the content must be accessible by a screen reader.","line":53,"column":5,"nodeType":"JSXOpeningElement","endLine":65,"endColumn":7,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/popover.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/progress.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/radio-group.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/resizable.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/scroll-area.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/select.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/separator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/sheet.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/sidebar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/skeleton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/slider.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/sonner.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/switch.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/table.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/tabs.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/textarea.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/toggle-group.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/toggle.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/components/ui/tooltip.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/agent/components/AgentInstanceForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/agent/components/AgentInstanceList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/agent/components/AgentInstanceListItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/agent/components/fields/AgentLLMConfigSelectField.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/agent/components/fields/AgentNameField.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/agent/components/fields/AgentPersonaTemplateSelectField.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/agent/components/fields/AgentTemperatureSliderField.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/chat/components/ChatInput.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/chat/components/ChatSidebar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/chat/components/ChatWindow.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/chat/components/ConversationList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/chat/components/MessageInput.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/chat/components/MessageItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/chat/components/MessageList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/llm/components/LLMConfigForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/llm/components/LLMConfigList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/llm/components/LLMConfigListItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/llm/components/fields/ApiKeyField.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/llm/components/fields/BaseUrlField.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/llm/components/fields/ConfigNameField.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/llm/components/fields/ProviderSelectField.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/onboarding/components/InitialConfigStep.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/onboarding/components/OnboardingWizard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/onboarding/components/PersonaList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/onboarding/components/WelcomeStep.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/persona/components/PersonaTemplateForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/persona/components/PersonaTemplateList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/persona/components/PersonaTemplateListItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/persona/components/fields/PersonaBackstoryField.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/persona/components/fields/PersonaGoalField.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/persona/components/fields/PersonaNameField.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/persona/components/fields/PersonaRoleField.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/persona/components/fields/PersonaToolsField.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/project/components/ProjectCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/project/components/ProjectForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/project/components/ProjectList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/project/components/ProjectListItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/project/components/ProjectSidebar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/project/components/fields/ProjectDescriptionField.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/project/components/fields/ProjectNameField.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/project/components/layout/ParticipantListItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/project/components/layout/ProjectContextSidebar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/project/components/layout/ProjectParticipantsSidebar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/user/components/UserProfileForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/user/components/UserSidebar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/user/components/fields/AvatarUrlField.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/user/components/fields/DisplayNameField.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/user/components/fields/EmailDisplayField.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/user/components/layout/UserSidebar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/features/user/components/layout/UserSidebarParts.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/global.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/hooks/ipc/useIpcMutation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/hooks/ipc/useIpcQuery.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/hooks/ipc/useIpcSubscription.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/hooks/use-mobile.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/hooks/useIPC.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'IElectronIPC' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":22,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/lib/utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/main.tsx","messages":[],"suppressedMessages":[{"ruleId":"import/no-unresolved","severity":2,"message":"Unable to resolve path to module '@/ui/routeTree.gen'.","line":8,"column":27,"nodeType":"Literal","endLine":8,"endColumn":47,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/services/ipc.service.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":126,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":126,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4792,4795],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4792,4795],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":186,"column":72,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":186,"endColumn":75,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8168,8171],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8168,8171],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/presentation/ui/services/ipc.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/shared/ipc-channels.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/shared/ipc-chat.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/shared/ipc-project.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/shared/ipc-types/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/shared/result.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/shared/types/entities.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
