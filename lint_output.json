[{"filePath":"/app/src_refactored/core/application/ports/job-repository.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/queue/abstract-queue.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/worker/__tests__/worker.service.spec.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":1,"endColumn":85,"fix":{"range":[84,84],"text":"\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ProcessorFunction' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":40,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":57},{"ruleId":"import/order","severity":1,"message":"`@/core/application/queue/abstract-queue` import should occur before import of `../worker.service`","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":73,"fix":{"range":[0,158],"text":"import { AbstractQueue } from '@/core/application/queue/abstract-queue';\nimport { WorkerService, WorkerOptions, ProcessorFunction } from '../worker.service';\n"}},{"ruleId":"import/order","severity":1,"message":"`@/core/domain/job/job.entity` import should occur before import of `../worker.service`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":69,"fix":{"range":[0,227],"text":"import { JobEntity, JobStatus } from '@/core/domain/job/job.entity';\nimport { WorkerService, WorkerOptions, ProcessorFunction } from '../worker.service';\nimport { AbstractQueue } from '@/core/application/queue/abstract-queue';\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":69,"fix":{"range":[295,295],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@/core/domain/job/value-objects/job-id.vo` import should occur before import of `../worker.service`","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":69,"fix":{"range":[0,296],"text":"import { JobIdVO } from '@/core/domain/job/value-objects/job-id.vo';\nimport { WorkerService, WorkerOptions, ProcessorFunction } from '../worker.service';\nimport { AbstractQueue } from '@/core/application/queue/abstract-queue';\nimport { JobEntity, JobStatus } from '@/core/domain/job/job.entity';\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":80,"fix":{"range":[375,375],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`vitest` import should occur before import of `../worker.service`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":80,"fix":{"range":[0,376],"text":"import { vi, describe, it, expect, beforeEach, Mock, afterEach } from 'vitest';\nimport { WorkerService, WorkerOptions, ProcessorFunction } from '../worker.service';\nimport { AbstractQueue } from '@/core/application/queue/abstract-queue';\nimport { JobEntity, JobStatus } from '@/core/domain/job/job.entity';\nimport { JobIdVO } from '@/core/domain/job/value-objects/job-id.vo';\n"}},{"ruleId":"import/order","severity":1,"message":"`events` import should occur before import of `../worker.service`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":35,"fix":{"range":[0,411],"text":"import EventEmitter from 'events';\nimport { WorkerService, WorkerOptions, ProcessorFunction } from '../worker.service';\nimport { AbstractQueue } from '@/core/application/queue/abstract-queue';\nimport { JobEntity, JobStatus } from '@/core/domain/job/job.entity';\nimport { JobIdVO } from '@/core/domain/job/value-objects/job-id.vo';\nimport { vi, describe, it, expect, beforeEach, Mock, afterEach } from 'vitest';\n"}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":11,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[548,551],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[548,551],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":12,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[628,631],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[628,631],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":19,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":19,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[733,736],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[733,736],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":20,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":20,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[795,798],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[795,798],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":22,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[953,956],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[953,956],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":23,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":23,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1032,1035],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1032,1035],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":26,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1204,1207],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1204,1207],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"id-length","severity":1,"message":"Identifier name 'j' is too short (< 2).","line":194,"column":51,"nodeType":"Identifier","messageId":"tooShort","endLine":194,"endColumn":52},{"ruleId":"id-length","severity":1,"message":"Identifier name 'j' is too short (< 2).","line":273,"column":51,"nodeType":"Identifier","messageId":"tooShort","endLine":273,"endColumn":52},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":339,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":339,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15462,15465],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15462,15465],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":8,"source":"import { WorkerService, WorkerOptions, ProcessorFunction } from '../worker.service';\nimport { AbstractQueue } from '@/core/application/queue/abstract-queue';\nimport { JobEntity, JobStatus } from '@/core/domain/job/job.entity';\nimport { JobIdVO } from '@/core/domain/job/value-objects/job-id.vo';\nimport { vi, describe, it, expect, beforeEach, Mock, afterEach } from 'vitest';\nimport EventEmitter from 'events';\n\n// Mock AbstractQueue\nclass MockQueue<P, R> extends EventEmitter implements AbstractQueue<P, R> {\n  queueName: string;\n  jobRepository: any; // Not used directly by WorkerService, can be minimal\n  defaultJobOptions: any;\n\n  constructor(name: string) {\n    super();\n    this.queueName = name;\n  }\n\n  add = vi.fn() as Mock<any[], Promise<JobEntity<P, R>>>;\n  addBulk = vi.fn() as Mock<any[], Promise<Array<JobEntity<P, R>>>>;\n  getJob = vi.fn() as Mock<[string | JobIdVO], Promise<JobEntity<P, R> | null>>;\n  getJobsByStatus = vi.fn() as Mock<any[], Promise<Array<JobEntity<P, R>>>>;\n  countJobsByStatus = vi.fn() as Mock<any[], Promise<Partial<Record<JobStatus, number>>>>;\n  pause = vi.fn() as Mock<[], Promise<void>>;\n  resume = vi.fn() as Mock<[], Promise<void>>;\n  clean = vi.fn() as Mock<any[], Promise<number>>;\n  close = vi.fn() as Mock<[], Promise<void>>;\n\n  fetchNextJobAndLock = vi.fn() as Mock<[string, number], Promise<JobEntity<P, R> | null>>;\n  extendJobLock = vi.fn() as Mock<[string | JobIdVO, string, number], Promise<void>>;\n  markJobAsCompleted = vi.fn() as Mock<[string | JobIdVO, string, R, JobEntity<P,R>], Promise<void>>;\n  markJobAsFailed = vi.fn() as Mock<[string | JobIdVO, string, Error, JobEntity<P,R>], Promise<void>>;\n  updateJobProgress = vi.fn() as Mock<[string | JobIdVO, string, number | object], Promise<void>>;\n  addJobLog = vi.fn() as Mock<[string | JobIdVO, string, string, string?], Promise<void>>;\n  startMaintenance = vi.fn() as Mock<[], void>;\n}\n\ntype TestPayload = { data: string };\ntype TestResult = { status: string };\n\ndescribe('WorkerService', () => {\n  let workerService: WorkerService<TestPayload, TestResult>;\n  let mockQueue: MockQueue<TestPayload, TestResult>;\n  let mockProcessor: Mock<[JobEntity<TestPayload, TestResult>], Promise<TestResult>>;\n\n  const workerOptions: WorkerOptions = {\n    concurrency: 1,\n    lockDuration: 10000, // 10s\n    lockRenewTimeBuffer: 2000, // Renew 2s before lock expires\n  };\n\n  beforeEach(() => {\n    vi.useFakeTimers();\n    mockQueue = new MockQueue('test-queue');\n    mockProcessor = vi.fn();\n    workerService = new WorkerService(mockQueue, mockProcessor, workerOptions);\n    vi.spyOn(workerService, 'emit');\n  });\n\n  afterEach(async () => {\n    await workerService.close(); // Ensure worker is closed and timers are cleared\n    vi.clearAllMocks();\n    vi.restoreAllMocks();\n    vi.useRealTimers();\n  });\n\nimport { randomUUID } from 'node:crypto';\n\n// ... (other imports)\n\n  const createMockJob = (idSuffix: string, payload: TestPayload, status = JobStatus.WAITING): JobEntity<TestPayload, TestResult> => {\n    // Use a passed suffix for easier debugging if needed, but generate a valid UUID for the ID itself.\n    // Or, just use randomUUID directly if the suffix isn't strictly for ID.\n    // For this case, let's make the ID a valid UUID. The suffix can be for logging/tracking in tests.\n    const job = JobEntity.create<TestPayload, TestResult>({\n      id: JobIdVO.create(randomUUID()), // Generate valid UUID\n      queueName: mockQueue.queueName,\n      name: `test-job-${idSuffix}`, // Keep suffix in name for easier test identification\n      payload,\n    });\n    job.status = status; // manually set for testing different scenarios\n    if (status === JobStatus.ACTIVE) {\n        job.moveToActive(`worker-${idSuffix}`, new Date(Date.now() + workerOptions.lockDuration));\n    }\n    return job;\n  };\n\n  it('should create a worker instance', () => {\n    expect(workerService).toBeInstanceOf(WorkerService);\n    expect(workerService.isClosed).toBe(false);\n    expect(workerService.isRunning).toBe(false);\n  });\n\n  describe('run and job processing', () => {\n    it('should fetch and process a job successfully', async () => {\n      const job = createMockJob('success', { data: 'process me' });\n      const expectedResult = { status: 'processed' };\n\n      mockQueue.fetchNextJobAndLock.mockResolvedValueOnce(job);\n      mockProcessor.mockResolvedValueOnce(expectedResult);\n\n      workerService.run();\n      await vi.advanceTimersByTimeAsync(100); // Allow polling and processing\n\n      expect(mockQueue.fetchNextJobAndLock).toHaveBeenCalledWith(workerService.workerId, workerOptions.lockDuration);\n      expect(mockProcessor).toHaveBeenCalledWith(job);\n      expect(mockQueue.markJobAsCompleted).toHaveBeenCalledWith(job.id, workerService.workerId, expectedResult, job);\n      expect(workerService.emit).toHaveBeenCalledWith('worker.job.active', job);\n      expect(workerService.emit).toHaveBeenCalledWith('worker.job.processed', job, expectedResult);\n      expect(workerService.isRunning).toBe(true);\n    });\n\n    it('should handle job processing failure', async () => {\n      const job = createMockJob('fail', { data: 'fail me' });\n      const error = new Error('Processing failed');\n\n      mockQueue.fetchNextJobAndLock.mockResolvedValueOnce(job);\n      mockProcessor.mockRejectedValueOnce(error);\n\n      workerService.run();\n      await vi.advanceTimersByTimeAsync(100);\n\n      expect(mockProcessor).toHaveBeenCalledWith(job);\n      expect(mockQueue.markJobAsFailed).toHaveBeenCalledWith(job.id, workerService.workerId, error, job);\n      expect(workerService.emit).toHaveBeenCalledWith('worker.job.active', job);\n      expect(workerService.emit).toHaveBeenCalledWith('worker.job.errored', job, error);\n    });\n\n    it('should not fetch new jobs if concurrency limit is reached', async () => {\n      const job1 = createMockJob('c1', { data: 'c_data1' });\n      // Simulate job1 is being processed and takes time\n      mockQueue.fetchNextJobAndLock.mockResolvedValueOnce(job1);\n      mockProcessor.mockImplementationOnce(() => new Promise(resolve => setTimeout(() => resolve({status: 'done_c1'}), 5000)));\n\n      workerService.run(); // Starts processing job1\n      await vi.advanceTimersByTimeAsync(100); // job1 picked up\n\n      expect(mockQueue.fetchNextJobAndLock).toHaveBeenCalledTimes(1);\n      expect(workerService.activeJobCount).toBe(1);\n\n      // Try to advance time, but since concurrency is 1, no new job should be fetched yet\n      await vi.advanceTimersByTimeAsync(1000);\n      expect(mockQueue.fetchNextJobAndLock).toHaveBeenCalledTimes(1); // Still 1, as job1 is active\n\n      await vi.advanceTimersByTimeAsync(5000); // job1 finishes\n      await vi.advanceTimersByTimeAsync(100); // Polling for next\n\n      expect(mockQueue.markJobAsCompleted).toHaveBeenCalledWith(job1.id, workerService.workerId, {status: 'done_c1'}, job1);\n      expect(workerService.activeJobCount).toBe(0);\n      // Now it should poll again\n      expect(mockQueue.fetchNextJobAndLock).toHaveBeenCalledTimes(2);\n    });\n\n    it('should respect concurrency > 1', async () => {\n      workerService.close(); // close default worker\n      const multiConcurrencyOptions = { ...workerOptions, concurrency: 2 };\n      workerService = new WorkerService(mockQueue, mockProcessor, multiConcurrencyOptions);\n      vi.spyOn(workerService, 'emit');\n\n\n      const job1 = createMockJob('mc1', { data: 'mc_data1' });\n      const job2 = createMockJob('mc2', { data: 'mc_data2' });\n\n      mockQueue.fetchNextJobAndLock\n        .mockResolvedValueOnce(job1)\n        .mockResolvedValueOnce(job2)\n        .mockResolvedValue(null); // No more jobs after these two\n\n      mockProcessor.mockImplementation(async (job) => {\n        await new Promise(resolve => setTimeout(resolve, 1000)); // Simulate work\n        return { status: `done_${job.id.value}` };\n      });\n\n      workerService.run();\n      await vi.advanceTimersByTimeAsync(100); // Poll and pick up job1 & job2\n\n      expect(mockQueue.fetchNextJobAndLock).toHaveBeenCalledTimes(2); // Fetched two jobs due to concurrency\n      expect(workerService.activeJobCount).toBe(2);\n      expect(mockProcessor).toHaveBeenCalledWith(job1);\n      expect(mockProcessor).toHaveBeenCalledWith(job2);\n\n      await vi.advanceTimersByTimeAsync(1500); // Allow jobs to finish\n\n      expect(mockQueue.markJobAsCompleted).toHaveBeenCalledWith(job1.id, workerService.workerId, {status: `done_${job1.id.value}`}, job1);\n      expect(mockQueue.markJobAsCompleted).toHaveBeenCalledWith(job2.id, workerService.workerId, {status: `done_${job2.id.value}`}, job2);\n      expect(workerService.activeJobCount).toBe(0);\n    });\n\n\n    it('should handle job.updateProgress and job.addLog from processor', async () => {\n      const job = createMockJob('progress', { data: 'progress data' });\n      mockQueue.fetchNextJobAndLock.mockResolvedValueOnce(job);\n\n      mockProcessor.mockImplementationOnce(async (j) => {\n        j.updateProgress(50); // This should call queue.updateJobProgress via the bound method\n        j.addLog('Processor log 1', 'INFO'); // This should call queue.addJobLog\n        return { status: 'progress_done' };\n      });\n\n      workerService.run();\n      await vi.advanceTimersByTimeAsync(100);\n\n      expect(mockProcessor).toHaveBeenCalledWith(job);\n      // The actual call to queue methods happens because JobEntity methods are bound by WorkerService\n      // before passing the job to the processor.\n      expect(mockQueue.updateJobProgress).toHaveBeenCalledWith(job.id, workerService.workerId, 50);\n      expect(mockQueue.addJobLog).toHaveBeenCalledWith(job.id, workerService.workerId, 'Processor log 1', 'INFO');\n      expect(mockQueue.markJobAsCompleted).toHaveBeenCalled();\n    });\n  });\n\n  describe('lock renewal', () => {\n    it('should renew lock periodically for an active job', async () => {\n      const job = createMockJob('lockrenew', { data: 'renew me' });\n      mockQueue.fetchNextJobAndLock.mockResolvedValueOnce(job);\n\n      // Simulate a long-running job\n      mockProcessor.mockImplementationOnce(async () => {\n        await vi.advanceTimersByTimeAsync(workerOptions.lockDuration * 2); // Process longer than lock duration\n        return { status: 'renewed_done' };\n      });\n\n      workerService.run();\n      await vi.advanceTimersByTimeAsync(100); // Job picked up\n\n      expect(mockQueue.fetchNextJobAndLock).toHaveBeenCalledTimes(1);\n      expect(workerService.activeJobCount).toBe(1);\n\n      // Advance time to just before the first lock renewal should happen\n      // lockDuration = 10000, lockRenewTimeBuffer = 2000. So, renew at 8000ms.\n      await vi.advanceTimersByTimeAsync(workerOptions.lockDuration - workerOptions.lockRenewTimeBuffer - 100); // e.g., 7900ms\n      expect(mockQueue.extendJobLock).not.toHaveBeenCalled();\n\n      await vi.advanceTimersByTimeAsync(200); // e.g., total 8100ms, past renewal point\n      expect(mockQueue.extendJobLock).toHaveBeenCalledWith(job.id, workerService.workerId, workerOptions.lockDuration);\n\n      // Advance time for another renewal cycle\n      await vi.advanceTimersByTimeAsync(workerOptions.lockDuration - workerOptions.lockRenewTimeBuffer + 100);\n      expect(mockQueue.extendJobLock).toHaveBeenCalledTimes(2);\n\n      // Allow job to finish\n      await vi.runOnlyPendingTimersAsync();\n      await vi.runOnlyPendingTimersAsync(); // one more for safety for all promises to resolve\n\n      expect(mockQueue.markJobAsCompleted).toHaveBeenCalled();\n      expect(workerService.activeJobCount).toBe(0);\n    });\n\n    it('should stop renewing lock if job finishes', async () => {\n      const job = createMockJob('lockstop', { data: 'stop renew' });\n      mockQueue.fetchNextJobAndLock.mockResolvedValueOnce(job);\n\n      // Job finishes quickly, before first lock renewal\n      mockProcessor.mockResolvedValueOnce({ status: 'stopped_done' });\n\n      workerService.run();\n      await vi.advanceTimersByTimeAsync(100); // Job picked up and processed\n\n      expect(mockQueue.markJobAsCompleted).toHaveBeenCalled();\n\n      // Advance time past where a renewal would have happened\n      await vi.advanceTimersByTimeAsync(workerOptions.lockDuration);\n      expect(mockQueue.extendJobLock).not.toHaveBeenCalled();\n    });\n  });\n\n  describe('close', () => {\n    it('should stop polling for new jobs and wait for active jobs to complete (graceful shutdown)', async () => {\n      const job1 = createMockJob('close1', { data: 'closing job 1' });\n      mockQueue.fetchNextJobAndLock.mockResolvedValueOnce(job1);\n\n      // job1 takes 2 seconds to process\n      mockProcessor.mockImplementationOnce(async (j) => {\n        await new Promise(resolve => setTimeout(resolve, 2000));\n        return { status: `closed_${j.id.value}` };\n      });\n\n      workerService.run();\n      await vi.advanceTimersByTimeAsync(100); // job1 is picked up\n\n      expect(workerService.activeJobCount).toBe(1);\n      expect(workerService.isRunning).toBe(true);\n\n      const closePromise = workerService.close(); // Initiate close\n      expect(workerService.isClosing).toBe(true);\n      expect(workerService.isRunning).toBe(false); // Should stop polling loop immediately\n\n      // At this point, fetchNextJobAndLock should not be called again even if polling interval hits\n      mockQueue.fetchNextJobAndLock.mockClear(); // Clear previous calls\n      await vi.advanceTimersByTimeAsync(500); // Advance, but no new jobs should be fetched\n      expect(mockQueue.fetchNextJobAndLock).not.toHaveBeenCalled();\n\n      expect(workerService.activeJobCount).toBe(1); // job1 still processing\n\n      await vi.advanceTimersByTimeAsync(2000); // Allow job1 to complete\n      await closePromise; // Wait for close to fully complete\n\n      expect(mockQueue.markJobAsCompleted).toHaveBeenCalledWith(job1.id, workerService.workerId, {status: `closed_${job1.id.value}`}, job1);\n      expect(workerService.activeJobCount).toBe(0);\n      expect(workerService.isClosed).toBe(true);\n      // Check that internal timers (polling, lock renewal) are cleared\n      // This is hard to check directly without exposing internals, but graceful shutdown implies this.\n    });\n\n    it('should close immediately if no active jobs', async () => {\n      mockQueue.fetchNextJobAndLock.mockResolvedValue(null); // No jobs\n      workerService.run();\n      await vi.advanceTimersByTimeAsync(100);\n\n      const closePromise = workerService.close();\n      await closePromise;\n\n      expect(workerService.isClosed).toBe(true);\n      expect(workerService.activeJobCount).toBe(0);\n      // No jobs were processed\n      expect(mockProcessor).not.toHaveBeenCalled();\n    });\n\n    it('multiple close calls should not cause issues', async () => {\n      workerService.run();\n      await vi.advanceTimersByTimeAsync(100);\n\n      const p1 = workerService.close();\n      const p2 = workerService.close(); // Call close again while already closing\n\n      await Promise.all([p1, p2]);\n      expect(workerService.isClosed).toBe(true);\n    });\n  });\n\n  // TODO: Test for 'worker.error' event if the queue itself throws an error during operations.\n  // This might require making the mockQueue.fetchNextJobAndLock throw an error.\n\n  it('should emit worker.error if queue.fetchNextJobAndLock throws and continues polling', async () => {\n    const fetchError = new Error('Failed to fetch from queue');\n    mockQueue.fetchNextJobAndLock.mockRejectedValueOnce(fetchError);\n\n    // Spy on the poll method to ensure it's called again\n    const pollSpy = vi.spyOn(workerService as any, 'poll');\n\n    workerService.run();\n    // Advance timers enough for the poll to execute and the error to be processed\n    await vi.advanceTimersByTimeAsync(100);\n\n\n    expect(workerService.emit).toHaveBeenCalledWith('worker.error', fetchError);\n    expect(pollSpy).toHaveBeenCalledTimes(1); // Initial call that errored\n\n    // Ensure it continues polling for the next cycle\n    mockQueue.fetchNextJobAndLock.mockResolvedValueOnce(null); // Next attempt finds no job\n    await vi.advanceTimersByTimeAsync(1000 + 50); // Default poll interval + buffer\n\n    expect(mockQueue.fetchNextJobAndLock).toHaveBeenCalledTimes(2); // fetch called again\n    expect(pollSpy.mock.calls.length).toBeGreaterThanOrEqual(2); // poll() itself was called again\n    pollSpy.mockRestore();\n  });\n\n  it('should emit worker.job.interrupted if closed during processing and not call complete/fail on queue', async () => {\n    const job = createMockJob('interrupted', { data: 'interrupt me' });\n    mockQueue.fetchNextJobAndLock.mockResolvedValueOnce(job);\n\n    const processorPromiseCtrl = {\n      resolve: () => {},\n      reject: () => {},\n    };\n    const processorPromise = new Promise<TestResult>((resolve, reject) => {\n      processorPromiseCtrl.resolve = resolve;\n      processorPromiseCtrl.reject = reject;\n    });\n\n    mockProcessor.mockImplementationOnce(() => {\n      // Simulate work is about to start or in progress\n      // Then worker is closed externally before this promise resolves\n      return processorPromise;\n    });\n\n    workerService.run();\n    await vi.advanceTimersByTimeAsync(50); // Job picked up, processor called\n\n    expect(workerService.emit).toHaveBeenCalledWith('worker.job.active', job);\n    expect(mockProcessor).toHaveBeenCalledWith(job);\n\n    // Now, close the worker while the job is notionally \"processing\"\n    // (i.e., processorPromise has not resolved)\n    const closePromise = workerService.close();\n\n    // Since close is called, the worker should not wait for the processorPromise to complete.\n    // Instead, it should proceed with shutdown.\n    // We need to ensure that the internal logic of processJob correctly identifies this scenario.\n\n    // Resolve the processor's promise *after* close has been initiated to simulate job \"finishing\" work\n    // but the worker is already shutting down.\n    processorPromiseCtrl.resolve({ status: 'finished_but_worker_closed' });\n    \n    await vi.runAllTimersAsync(); // Allow all timers (polling, lock renewal, close loop) to run\n    await closePromise; // Ensure close completes\n\n    expect(workerService.isClosed).toBe(true);\n    expect(workerService.emit).toHaveBeenCalledWith('worker.job.interrupted', job);\n    expect(mockQueue.markJobAsCompleted).not.toHaveBeenCalled();\n    expect(mockQueue.markJobAsFailed).not.toHaveBeenCalled();\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/worker/worker.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/application/worker/worker.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/core/domain/job/job.entity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/examples/queue-usage-example.final.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":77,"fix":{"range":[310,310],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@/core/application/worker/worker.service` import should occur before import of `@/infrastructure/persistence/drizzle/drizzle.client`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":74,"fix":{"range":[56,385],"text":"import { WorkerService } from '@/core/application/worker/worker.service';\nimport { db } from '@/infrastructure/persistence/drizzle/drizzle.client';\nimport { DrizzleJobRepository } from '@/infrastructure/persistence/drizzle/job/drizzle-job.repository';\nimport { QueueService } from '@/infrastructure/queue/drizzle/queue.service';\n"}},{"ruleId":"import/order","severity":1,"message":"`@/core/domain/job/job.entity` import should occur before import of `@/infrastructure/persistence/drizzle/drizzle.client`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":58,"fix":{"range":[56,443],"text":"import { JobEntity } from '@/core/domain/job/job.entity';\nimport { db } from '@/infrastructure/persistence/drizzle/drizzle.client';\nimport { DrizzleJobRepository } from '@/infrastructure/persistence/drizzle/job/drizzle-job.repository';\nimport { QueueService } from '@/infrastructure/queue/drizzle/queue.service';\nimport { WorkerService } from '@/core/application/worker/worker.service';\n"}},{"ruleId":"id-length","severity":1,"message":"Identifier name 'i' is too short (< 2).","line":17,"column":14,"nodeType":"Identifier","messageId":"tooShort","endLine":17,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":3,"source":"// src_refactored/examples/queue-usage-example.final.ts\nimport { db } from '@/infrastructure/persistence/drizzle/drizzle.client';\nimport { DrizzleJobRepository } from '@/infrastructure/persistence/drizzle/job/drizzle-job.repository';\nimport { QueueService } from '@/infrastructure/queue/drizzle/queue.service';\nimport { WorkerService } from '@/core/application/worker/worker.service';\nimport { JobEntity } from '@/core/domain/job/job.entity';\n\nasync function main() {\n  const jobRepository = new DrizzleJobRepository(db);\n  const queue = new QueueService('default', jobRepository);\n\n  // Job processor function\n  const processor = async (job: JobEntity<{ email: string }, { status: string }>): Promise<{ status: string }> => {\n    process.stdout.write(`[Worker] Processing job ${job.id.value} (attempt ${job.attemptsMade}) for email: ${job.payload.email}\\n`);\n\n    // Simulate work with progress updates\n    for (let i = 0; i <= 100; i += 25) {\n      await new Promise(resolve => setTimeout(resolve, 500));\n      job.updateProgress(i);\n      job.addLog(`Progress updated to ${i}%`);\n      process.stdout.write(`[Worker] Job ${job.id.value} progress: ${i}%\\n`);\n    }\n\n    // Simulate retry logic: fail twice, then succeed\n    if (job.attemptsMade < 3 && job.payload.email === 'retry@example.com') {\n      job.addLog('Simulating transient failure for retry job.', 'ERROR');\n      process.stdout.write(`[Worker] Job ${job.id.value} (retry job) failed. Attempts made: ${job.attemptsMade}\\n`);\n      throw new Error('Simulated transient error');\n    }\n\n    // Simulate permanent failure for a specific job\n    if (job.payload.email === 'fail@example.com') {\n      job.addLog('Simulating permanent failure.', 'ERROR');\n      process.stdout.write(`[Worker] Job ${job.id.value} (fail job) failed permanently.\\n`);\n      throw new Error('Simulated permanent error');\n    }\n\n    job.addLog('Job completed successfully.', 'INFO');\n    process.stdout.write(`[Worker] Job ${job.id.value} completed successfully.\\n`);\n    return { status: 'Email sent' };\n  };\n\n  const worker = new WorkerService(queue, processor, { concurrency: 2, lockDuration: 15000, lockRenewTimeBuffer: 5000 });\n\n  // Event listeners for queue and worker\n  queue.on('job.added', (job) => process.stdout.write(`[Queue] Job added: ${job.id.value} (Name: ${job.name}, Status: ${job.status})\\n`));\n  queue.on('job.completed', (job) => process.stdout.write(`[Queue] Job completed: ${job.id.value} (Result: ${JSON.stringify(job.returnValue)})\\n`));\n  queue.on('job.failed', (job) => process.stdout.write(`[Queue] Job failed: ${job.id.value} (Reason: ${job.failedReason}, Attempts: ${job.attemptsMade})\\n`));\n  queue.on('job.active', (job) => process.stdout.write(`[Queue] Job ${job.id.value} is now active.\\n`));\n  queue.on('job.stalled', (job) => process.stdout.write(`[Queue] Job ${job.id.value} stalled and re-queued.\\n`));\n  queue.on('job.progress', (job) => process.stdout.write(`[Queue] Job ${job.id.value} progress updated to ${job.progress}\\n`));\n  queue.on('job.log', (job) => process.stdout.write(`[Queue] Job ${job.id.value} log: ${job.logs[job.logs.length - 1].message}\\n`));\n\n  worker.on('worker.job.active', (job) => process.stdout.write(`[Worker] Worker started processing job: ${job.id.value}\\n`));\n  worker.on('worker.job.processed', (job) => process.stdout.write(`[Worker] Worker finished processing job: ${job.id.value}\\n`));\n  worker.on('worker.job.errored', (job, error) => process.stdout.write(`[Worker] Worker encountered error for job ${job.id.value}: ${error.message}\\n`));\n\n  // Add various job scenarios\n  await queue.add('send-email', { email: 'success@example.com' }); // Succeeds on first attempt\n  await queue.add('send-email', { email: 'delayed@example.com' }, { delay: 7000 }); // Delayed job\n  await queue.add('send-email', { email: 'retry@example.com' }, { attempts: 3, backoff: { type: 'exponential', delay: 1000 } }); // Fails then retries\n  await queue.add('send-email', { email: 'fail@example.com' }, { attempts: 1 }); // Fails permanently\n\n  worker.run();\n  queue.startMaintenance();\n\n  process.stdout.write('Queue and Worker started. Waiting for jobs to complete...\\n');\n\n  // Keep the process alive for a while to observe job processing\n  setTimeout(async () => {\n    process.stdout.write('Shutting down worker and queue...\\n');\n    await worker.close();\n    await queue.close();\n    process.stdout.write('Worker and queue closed. Exiting.\\n');\n    process.exit(0);\n  }, 60000); // Run for 60 seconds\n}\n\nmain().catch(console.error);","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/ioc/inversify.config.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":39,"fix":{"range":[122,122],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":74,"fix":{"range":[196,196],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":106,"fix":{"range":[302,302],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@/core/application/ports/job-repository.interface` import should occur before import of `@/infrastructure/persistence/drizzle/drizzle.client`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":106,"fix":{"range":[123,303],"text":"import { IJobRepository, JOB_REPOSITORY_TOKEN } from '@/core/application/ports/job-repository.interface';\nimport { db } from '@/infrastructure/persistence/drizzle/drizzle.client';\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":104,"fix":{"range":[406,406],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":95,"fix":{"range":[501,501],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@/core/application/queue/abstract-queue` import should occur before import of `@/infrastructure/persistence/drizzle/drizzle.client`","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":95,"fix":{"range":[123,502],"text":"import { AbstractQueue, getQueueServiceToken } from '@/core/application/queue/abstract-queue';\nimport { db } from '@/infrastructure/persistence/drizzle/drizzle.client';\nimport { IJobRepository, JOB_REPOSITORY_TOKEN } from '@/core/application/ports/job-repository.interface';\nimport { DrizzleJobRepository } from '@/infrastructure/persistence/drizzle/job/drizzle-job.repository';\n"}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":20,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":20,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1206,1209],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1206,1209],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":20,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":20,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1211,1214],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1211,1214],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'context' is defined but never used. Allowed unused args must match /^_/u.","line":20,"column":93,"nodeType":null,"messageId":"unusedVar","endLine":20,"endColumn":100}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":7,"source":"// src_refactored/infrastructure/ioc/inversify.config.ts\nimport 'reflect-metadata';\nimport { Container } from 'inversify';\nimport { db } from '@/infrastructure/persistence/drizzle/drizzle.client';\nimport { IJobRepository, JOB_REPOSITORY_TOKEN } from '@/core/application/ports/job-repository.interface';\nimport { DrizzleJobRepository } from '@/infrastructure/persistence/drizzle/job/drizzle-job.repository';\nimport { AbstractQueue, getQueueServiceToken } from '@/core/application/queue/abstract-queue';\nimport { QueueService } from '@/infrastructure/queue/drizzle/queue.service';\n\nexport const appContainer = new Container();\n\n// Database Client\n// The 'db' instance from drizzle.client is directly used in repository construction,\n// so explicit binding of 'drizzle' symbol might not be strictly necessary unless used elsewhere.\n// For now, we ensure db is available for DrizzleJobRepository.\n// appContainer.bind('drizzle').toConstantValue(db); // This line can be kept or removed if db is only used for repo instantiation.\n\n// Job Repository and Queue Service bindings\nappContainer.bind<IJobRepository>(JOB_REPOSITORY_TOKEN).toConstantValue(new DrizzleJobRepository(db));\nappContainer.bind<AbstractQueue<any, any>>(getQueueServiceToken('default')).toDynamicValue((context) => {\n  const jobRepository = appContainer.get<IJobRepository>(JOB_REPOSITORY_TOKEN);\n  return new QueueService('default', jobRepository);\n}).inSingletonScope();\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/persistence/drizzle/job/drizzle-job.repository.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@/core/domain/job/value-objects/job-id.vo` import should occur before import of `@/core/domain/job/value-objects/job-options.vo`","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":69,"fix":{"range":[375,544],"text":"import { JobIdVO } from '@/core/domain/job/value-objects/job-id.vo';\nimport { IJobOptions } from '@/core/domain/job/value-objects/job-options.vo'; // Import IJobOptions\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":10,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":55,"fix":{"range":[689,689],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`../schema` import should occur before type import of `../drizzle.client`","line":11,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":37,"fix":{"range":[635,772],"text":"import * as schema from '../schema'; // This imports jobsTable and JobSelect type\nimport type { db as DbType } from '../drizzle.client';\n"}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":56,"column":74,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":56,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3055,3058],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3055,3058],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":56,"column":142,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":56,"endColumn":145,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3123,3126],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3123,3126],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":62,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":62,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3393,3396],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3393,3396],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"// src_refactored/infrastructure/persistence/drizzle/job/drizzle-job.repository.ts\nimport { and, asc as ascDrizzle, desc, eq, inArray, isNull, lt, or } from 'drizzle-orm';\n\nimport { IJobRepository } from '@/core/application/ports/job-repository.interface';\nimport { JobEntity, JobStatus, JobPersistenceData } from '@/core/domain/job/job.entity'; // Import JobPersistenceData\nimport { IJobOptions } from '@/core/domain/job/value-objects/job-options.vo'; // Import IJobOptions\nimport { JobIdVO } from '@/core/domain/job/value-objects/job-id.vo';\n\n// Import 'db' from drizzle.client for the constructor type, but instance will be passed.\nimport type { db as DbType } from '../drizzle.client';\nimport * as schema from '../schema'; // This imports jobsTable and JobSelect type\n\nexport class DrizzleJobRepository implements IJobRepository {\n  constructor(private readonly drizzleDbInstance: typeof DbType) {}\n\n  // Helper to map Drizzle's JobSelect to domain's JobPersistenceData\n  private mapToPersistenceData<P, R>(jobData: schema.JobSelect): JobPersistenceData<P, R> {\n    // Ensure JSON fields are properly cast/parsed if necessary.\n    // Drizzle's db.query often auto-parses JSON, but db.select might not.\n    // For db.query results, direct assignment is usually fine.\n    const options = jobData.options as IJobOptions; // Drizzle query should parse this\n    const logs = (jobData.logs as Array<{ message: string; level: string; timestamp: number }>) || [];\n    const payload = jobData.payload as P;\n    const returnValue = jobData.returnValue as R | null;\n    const progress = jobData.progress as number | object;\n    const stacktrace = jobData.stacktrace as string[] | null;\n\n    return {\n      id: jobData.id,\n      queueName: jobData.queueName,\n      name: jobData.name,\n      payload: payload,\n      options: options,\n      status: jobData.status as JobStatus, // Schema status is string, cast to enum\n      attemptsMade: jobData.attemptsMade,\n      progress: progress,\n      logs: logs, // Logs in schema are already {ts: number} via JobEntity.toPersistence mapping\n      createdAt: jobData.createdAt.getTime(), // Convert Date to number\n      updatedAt: jobData.updatedAt.getTime(), // Convert Date to number\n      processedOn: jobData.processedOn ? jobData.processedOn.getTime() : null,\n      finishedOn: jobData.finishedOn ? jobData.finishedOn.getTime() : null,\n      delayUntil: jobData.delayUntil ? jobData.delayUntil.getTime() : null,\n      lockUntil: jobData.lockUntil ? jobData.lockUntil.getTime() : null,\n      workerId: jobData.workerId,\n      returnValue: returnValue,\n      failedReason: jobData.failedReason,\n      stacktrace: stacktrace,\n      // priority is part of options, not separate here\n      // repeatJobKey and parentId are not in JobPersistenceData yet\n    };\n  }\n\n  async save(job: JobEntity<unknown, unknown>): Promise<void> {\n    const data = job.toPersistence();\n    // Drizzle handles Date -> number for timestamp_ms fields during insert/update\n    await this.drizzleDbInstance.insert(schema.jobsTable).values(data as any).onConflictDoUpdate({ target: schema.jobsTable.id, set: data as any });\n  }\n\n  async update(job: JobEntity<unknown, unknown>): Promise<void> {\n    const data = job.toPersistence();\n    // Drizzle handles Date -> number for timestamp_ms fields during insert/update\n    await this.drizzleDbInstance.update(schema.jobsTable).set(data as any).where(eq(schema.jobsTable.id, data.id));\n  }\n\n  async findById(id: JobIdVO): Promise<JobEntity<unknown, unknown> | null> {\n    const result = await this.drizzleDbInstance.query.jobsTable.findFirst({ where: eq(schema.jobsTable.id, id.value) });\n    if (!result) return null;\n    return JobEntity.fromPersistence(this.mapToPersistenceData(result));\n  }\n\n  async findNextJobsToProcess(queueName: string, limit: number): Promise<Array<JobEntity<unknown, unknown>>> {\n    const now = new Date();\n    const results = await this.drizzleDbInstance.query.jobsTable.findMany({ // Corrected: use this.drizzleDbInstance\n      where: and(\n        eq(schema.jobsTable.queueName, queueName),\n        // Job is either WAITING or it was DELAYED and its time has come\n        or(\n          eq(schema.jobsTable.status, JobStatus.WAITING),\n          and(\n            eq(schema.jobsTable.status, JobStatus.DELAYED),\n            lt(schema.jobsTable.delayUntil, now)\n          )\n        )\n      ),\n      orderBy: [ascDrizzle(schema.jobsTable.priority), ascDrizzle(schema.jobsTable.createdAt)],\n      limit,\n    });\n    return results.map(jobData => JobEntity.fromPersistence(this.mapToPersistenceData(jobData)));\n  }\n\n  async acquireLock(jobId: JobIdVO, workerId: string, lockUntil: Date): Promise<boolean> {\n    const result = await this.drizzleDbInstance.update(schema.jobsTable)\n      .set({ workerId, lockUntil, status: JobStatus.ACTIVE })\n      .where(and(eq(schema.jobsTable.id, jobId.value), or(isNull(schema.jobsTable.workerId), lt(schema.jobsTable.lockUntil, new Date()))))\n    return result.changes > 0;\n  }\n\n  async extendLock(jobId: JobIdVO, workerId: string, lockUntil: Date): Promise<void> {\n    await this.drizzleDbInstance.update(schema.jobsTable)\n      .set({ lockUntil })\n      .where(and(eq(schema.jobsTable.id, jobId.value), eq(schema.jobsTable.workerId, workerId)));\n  }\n\n  async findStalledJobs(queueName: string, olderThan: Date, limit: number): Promise<Array<JobEntity<unknown, unknown>>> {\n    const results = await this.drizzleDbInstance.query.jobsTable.findMany({\n      where: and(\n        eq(schema.jobsTable.queueName, queueName),\n        eq(schema.jobsTable.status, JobStatus.ACTIVE),\n        lt(schema.jobsTable.lockUntil, olderThan)\n      ),\n      limit,\n    });\n    return results.map(jobData => JobEntity.fromPersistence(this.mapToPersistenceData(jobData)));\n  }\n\n  async remove(jobId: JobIdVO): Promise<void> {\n    await this.drizzleDbInstance.delete(schema.jobsTable).where(eq(schema.jobsTable.id, jobId.value));\n  }\n\n  async getJobsByStatus(\n    queueName: string,\n    statuses: JobStatus[],\n    start: number = 0,\n    end: number = 100,\n    asc: boolean = false,\n  ): Promise<Array<JobEntity<unknown, unknown>>> {\n    // Parameter 'end' is used as 'count' or 'limit' based on typical usage patterns and UI calls.\n    const results = await this.drizzleDbInstance.query.jobsTable.findMany({ // Corrected: use this.drizzleDbInstance\n      where: and(eq(schema.jobsTable.queueName, queueName), inArray(schema.jobsTable.status, statuses)),\n      orderBy: [asc ? ascDrizzle(schema.jobsTable.createdAt) : desc(schema.jobsTable.createdAt)],\n      offset: start,\n      limit: end, // 'end' here is the count/limit of items to fetch\n    });\n    return results.map(jobData => JobEntity.fromPersistence(this.mapToPersistenceData(jobData)));\n  }\n\n  async countJobsByStatus(queueName: string, statuses?: JobStatus[]): Promise<Partial<Record<JobStatus, number>>> {\n    const query = this.drizzleDbInstance.select({\n      status: schema.jobsTable.status,\n      count: schema.sql`count(*)`.mapWith(Number),\n    }).from(schema.jobsTable)\n      .where(\n        and(\n          eq(schema.jobsTable.queueName, queueName),\n          statuses ? inArray(schema.jobsTable.status, statuses) : undefined\n        )\n      )\n      .groupBy(schema.jobsTable.status);\n\n    const results = await query;\n    return results.reduce((acc, row) => {\n      acc[row.status as JobStatus] = row.count as number;\n      return acc;\n    }, {} as Partial<Record<JobStatus, number>>);\n  }\n\n  async clean(queueName: string, gracePeriodMs: number, limit: number, status?: JobStatus): Promise<number> {\n    const now = new Date();\n    const finishedOlderThan = new Date(now.getTime() - gracePeriodMs);\n\n    // Step 1: Select IDs of jobs to be deleted, respecting the limit\n    const jobsToDeleteIdsQuery = this.drizzleDbInstance.select({ id: schema.jobsTable.id })\n      .from(schema.jobsTable)\n      .where(and(\n        eq(schema.jobsTable.queueName, queueName),\n        status ? eq(schema.jobsTable.status, status) :\n                 or(eq(schema.jobsTable.status, JobStatus.COMPLETED), eq(schema.jobsTable.status, JobStatus.FAILED)), // Default to completed/failed\n        lt(schema.jobsTable.finishedOn, finishedOlderThan)\n      ))\n      .orderBy(ascDrizzle(schema.jobsTable.finishedOn)) // Delete oldest first\n      .limit(limit);\n\n    const jobsToDelete = await jobsToDeleteIdsQuery;\n\n    if (jobsToDelete.length === 0) {\n      return 0;\n    }\n\n    const ids = jobsToDelete.map(jobEntry => jobEntry.id); // Renamed 'j' to 'jobEntry'\n\n    // Step 2: Delete jobs with the selected IDs\n    const result = await this.drizzleDbInstance.delete(schema.jobsTable)\n      .where(inArray(schema.jobsTable.id, ids));\n\n    return result.changes; // Number of rows deleted\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/persistence/drizzle/schema/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/persistence/drizzle/schema/jobs.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/queue/drizzle/__tests__/queue.service.spec.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":1,"endColumn":49,"fix":{"range":[48,48],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@/core/domain/job/job.entity` import should occur before import of `../queue.service`","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":69,"fix":{"range":[0,118],"text":"import { JobEntity, JobStatus } from '@/core/domain/job/job.entity';\nimport { QueueService } from '../queue.service';\n"}},{"ruleId":"import/order","severity":1,"message":"`@/core/domain/job/value-objects/job-id.vo` import should occur before import of `../queue.service`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":69,"fix":{"range":[0,187],"text":"import { JobIdVO } from '@/core/domain/job/value-objects/job-id.vo';\nimport { QueueService } from '../queue.service';\nimport { JobEntity, JobStatus } from '@/core/domain/job/job.entity';\n"}},{"ruleId":"import/order","severity":1,"message":"`@/core/application/ports/job-repository.interface` import should occur before import of `../queue.service`","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":84,"fix":{"range":[0,271],"text":"import { IJobRepository } from '@/core/application/ports/job-repository.interface';\nimport { QueueService } from '../queue.service';\nimport { JobEntity, JobStatus } from '@/core/domain/job/job.entity';\nimport { JobIdVO } from '@/core/domain/job/value-objects/job-id.vo';\n"}},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":91,"fix":{"range":[361,361],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@/core/domain/job/value-objects/job-options.vo` import should occur before import of `../queue.service`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":91,"fix":{"range":[0,362],"text":"import { IJobOptions, BackoffType } from '@/core/domain/job/value-objects/job-options.vo';\nimport { QueueService } from '../queue.service';\nimport { JobEntity, JobStatus } from '@/core/domain/job/job.entity';\nimport { JobIdVO } from '@/core/domain/job/value-objects/job-id.vo';\nimport { IJobRepository } from '@/core/application/ports/job-repository.interface';\n"}},{"ruleId":"import/order","severity":1,"message":"`vitest` import should occur before import of `../queue.service`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":69,"fix":{"range":[0,431],"text":"import { vi, describe, it, expect, beforeEach, Mock } from 'vitest';\nimport { QueueService } from '../queue.service';\nimport { JobEntity, JobStatus } from '@/core/domain/job/job.entity';\nimport { JobIdVO } from '@/core/domain/job/value-objects/job-id.vo';\nimport { IJobRepository } from '@/core/application/ports/job-repository.interface';\nimport { IJobOptions, BackoffType } from '@/core/domain/job/value-objects/job-options.vo';\n"}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":42,"column":81,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":42,"endColumn":84,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1715,1718],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1715,1718],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":42,"column":85,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":42,"endColumn":88,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1719,1722],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1719,1722],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":61,"column":81,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":61,"endColumn":84,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2591,2594],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2591,2594],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":61,"column":85,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":61,"endColumn":88,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2595,2598],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2595,2598],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":81,"column":81,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":81,"endColumn":84,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3374,3377],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3374,3377],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":81,"column":85,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":81,"endColumn":88,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3378,3381],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3378,3381],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":156,"column":89,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":156,"endColumn":92,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6937,6940],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6937,6940],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":156,"column":93,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":156,"endColumn":96,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6941,6944],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6941,6944],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":184,"column":91,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":184,"endColumn":94,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8164,8167],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8164,8167],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":184,"column":95,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":184,"endColumn":98,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8168,8171],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8168,8171],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":233,"column":91,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":233,"endColumn":94,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10733,10736],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10733,10736],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":233,"column":95,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":233,"endColumn":98,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10737,10740],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10737,10740],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":296,"column":91,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":296,"endColumn":94,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14631,14634],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14631,14634],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":296,"column":95,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":296,"endColumn":98,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14635,14638],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14635,14638],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":346,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":346,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17524,17527],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17524,17527],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":346,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":346,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17528,17531],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17528,17531],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":352,"column":91,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":352,"endColumn":94,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17897,17900],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17897,17900],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":352,"column":95,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":352,"endColumn":98,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17901,17904],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17901,17904],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":372,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":372,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18794,18797],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18794,18797],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":372,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":372,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18798,18801],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18798,18801],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":378,"column":91,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":378,"endColumn":94,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19160,19163],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19160,19163],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":378,"column":95,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":378,"endColumn":98,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19164,19167],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19164,19167],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":418,"column":85,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":418,"endColumn":88,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21339,21342],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21339,21342],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":418,"column":89,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":418,"endColumn":92,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21343,21346],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21343,21346],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":24,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":7,"source":"import { QueueService } from '../queue.service';\nimport { JobEntity, JobStatus } from '@/core/domain/job/job.entity';\nimport { JobIdVO } from '@/core/domain/job/value-objects/job-id.vo';\nimport { IJobRepository } from '@/core/application/ports/job-repository.interface';\nimport { IJobOptions, BackoffType } from '@/core/domain/job/value-objects/job-options.vo';\nimport { vi, describe, it, expect, beforeEach, Mock } from 'vitest';\n\n// Mock JobRepository\nconst mockJobRepository: IJobRepository = {\n  save: vi.fn(),\n  findById: vi.fn(),\n  update: vi.fn(),\n  // delete: vi.fn(), // Corrected name from IJobRepository\n  remove: vi.fn(), // Corrected name from IJobRepository\n  findNextJobsToProcess: vi.fn(),\n  acquireLock: vi.fn(),\n  // releaseLock: vi.fn(), // Not in IJobRepository anymore\n  extendLock: vi.fn(), // Added missing mock\n  findStalledJobs: vi.fn(),\n  getJobsByStatus: vi.fn(),\n  countJobsByStatus: vi.fn(),\n  clean: vi.fn(),\n};\n\ndescribe('QueueService', () => {\n  let queueService: QueueService<{ email: string }, { status: string }>;\n  const queueName = 'test-email-queue';\n  const defaultJobOpts: IJobOptions = { attempts: 1, delay: 0, priority: 0, removeOnComplete: false, removeOnFail: false, maxStalledCount:3 };\n\n  beforeEach(() => {\n    vi.clearAllMocks();\n    queueService = new QueueService(queueName, mockJobRepository, defaultJobOpts);\n    // Spy on event emitter\n    vi.spyOn(queueService, 'emit');\n  });\n\n  describe('add', () => {\n    it('should create a job, save it, and emit job.added event', async () => {\n      const jobData = { email: 'test@example.com' };\n      const jobName = 'send-welcome-email';\n\n      (mockJobRepository.save as Mock).mockImplementation(async (job: JobEntity<any,any>) => job);\n\n      const job = await queueService.add(jobName, jobData);\n\n      expect(job).toBeInstanceOf(JobEntity);\n      expect(job.name).toBe(jobName);\n      expect(job.payload).toEqual(jobData);\n      expect(job.queueName).toBe(queueName);\n      expect(job.options.attempts).toBe(defaultJobOpts.attempts);\n      expect(mockJobRepository.save).toHaveBeenCalledOnce();\n      expect(mockJobRepository.save).toHaveBeenCalledWith(job);\n      expect(queueService.emit).toHaveBeenCalledWith('job.added', job);\n    });\n\n    it('should apply custom options when adding a job', async () => {\n      const jobData = { email: 'custom@example.com' };\n      const jobName = 'custom-options-job';\n      const customOpts: IJobOptions = { attempts: 5, delay: 5000, priority: 1, jobId: 'custom123' };\n\n      (mockJobRepository.save as Mock).mockImplementation(async (job: JobEntity<any,any>) => job);\n\n      const job = await queueService.add(jobName, jobData, customOpts);\n\n      expect(job.id.value).toBe('custom123');\n      expect(job.options.attempts).toBe(5);\n      expect(job.options.delay).toBe(5000);\n      expect(job.options.priority).toBe(1);\n      expect(job.status).toBe(JobStatus.DELAYED); // due to delay\n      expect(mockJobRepository.save).toHaveBeenCalledOnce();\n    });\n  });\n\n  describe('addBulk', () => {\n    it('should add multiple jobs, save them, and emit events', async () => {\n      const jobsToAdd = [\n        { name: 'bulk1', data: { email: 'b1@example.com' } },\n        { name: 'bulk2', data: { email: 'b2@example.com' }, opts: { priority: 1 } },\n      ];\n\n      (mockJobRepository.save as Mock).mockImplementation(async (job: JobEntity<any,any>) => job);\n\n      const addedJobs = await queueService.addBulk(jobsToAdd);\n\n      expect(addedJobs.length).toBe(2);\n      expect(mockJobRepository.save).toHaveBeenCalledTimes(2);\n      expect(queueService.emit).toHaveBeenCalledTimes(2);\n\n      expect(addedJobs[0].name).toBe('bulk1');\n      expect(addedJobs[0].payload).toEqual({ email: 'b1@example.com' });\n      expect(queueService.emit).toHaveBeenCalledWith('job.added', addedJobs[0]);\n\n      expect(addedJobs[1].name).toBe('bulk2');\n      expect(addedJobs[1].options.priority).toBe(1);\n      expect(queueService.emit).toHaveBeenCalledWith('job.added', addedJobs[1]);\n    });\n  });\n\n  describe('getJob', () => {\n    it('should call repository findById and return a job', async () => {\n      const jobId = JobIdVO.create();\n      const mockJob = JobEntity.create({ id: jobId, queueName, name: 'find-me', payload: { email: 'find@me.com' } });\n      (mockJobRepository.findById as Mock).mockResolvedValue(mockJob);\n\n      const foundJob = await queueService.getJob(jobId);\n\n      expect(mockJobRepository.findById).toHaveBeenCalledWith(jobId);\n      expect(foundJob).toBe(mockJob);\n    });\n     it('should accept string id for getJob', async () => {\n      const jobIdStr = 'string-id-123';\n      const mockJob = JobEntity.create({ id: JobIdVO.create(jobIdStr), queueName, name: 'find-me-str', payload: { email: 'find@me.com' } });\n      (mockJobRepository.findById as Mock).mockResolvedValue(mockJob);\n\n      const foundJob = await queueService.getJob(jobIdStr);\n\n      expect(mockJobRepository.findById).toHaveBeenCalledWith(expect.any(JobIdVO));\n      expect((mockJobRepository.findById as Mock).mock.calls[0][0].value).toBe(jobIdStr);\n      expect(foundJob).toBe(mockJob);\n    });\n  });\n\n  describe('fetchNextJobAndLock', () => {\n    const workerId = 'worker-007';\n    const lockDurationMs = 30000;\n\n    it('should return null if no jobs are available', async () => {\n      (mockJobRepository.findNextJobsToProcess as Mock).mockResolvedValue([]);\n      const job = await queueService.fetchNextJobAndLock(workerId, lockDurationMs);\n      expect(job).toBeNull();\n      expect(mockJobRepository.findNextJobsToProcess).toHaveBeenCalledWith(queueName, 1);\n      expect(mockJobRepository.acquireLock).not.toHaveBeenCalled();\n    });\n\n    it('should return null if lock cannot be acquired', async () => {\n      const availableJob = JobEntity.create({ queueName, name: 'job1', payload: {email: 'e1@example.com'} });\n      (mockJobRepository.findNextJobsToProcess as Mock).mockResolvedValue([availableJob]);\n      (mockJobRepository.acquireLock as Mock).mockResolvedValue(false); // Lock acquisition fails\n\n      const job = await queueService.fetchNextJobAndLock(workerId, lockDurationMs);\n\n      expect(job).toBeNull();\n      expect(mockJobRepository.acquireLock).toHaveBeenCalledWith(\n        availableJob.id,\n        workerId,\n        expect.any(Date) // lockUntil\n      );\n      expect(mockJobRepository.update).not.toHaveBeenCalled();\n      expect(queueService.emit).not.toHaveBeenCalledWith('job.active', expect.anything());\n    });\n\n    it('should fetch, lock, update job to active, and emit event', async () => {\n      const availableJob = JobEntity.create({ queueName, name: 'job2', payload: {email: 'e2@example.com'} });\n      (mockJobRepository.findNextJobsToProcess as Mock).mockResolvedValue([availableJob]);\n      (mockJobRepository.acquireLock as Mock).mockResolvedValue(true); // Lock acquisition succeeds\n      (mockJobRepository.update as Mock).mockImplementation(async (jobEntity: JobEntity<any,any>) => jobEntity);\n\n\n      const job = await queueService.fetchNextJobAndLock(workerId, lockDurationMs);\n\n      expect(job).toBe(availableJob);\n      expect(job!.status).toBe(JobStatus.ACTIVE);\n      expect(job!.workerId).toBe(workerId);\n      expect(job!.lockUntil).toBeInstanceOf(Date);\n      expect(job!.lockUntil!.getTime()).toBeGreaterThan(Date.now());\n      expect(job!.processedOn).toBeInstanceOf(Date);\n      expect(job!.attemptsMade).toBe(1);\n\n      expect(mockJobRepository.update).toHaveBeenCalledWith(job);\n      expect(queueService.emit).toHaveBeenCalledWith('job.active', job);\n    });\n  });\n\n  describe('extendJobLock', () => {\n    const jobId = JobIdVO.create('lock-job-id');\n    const workerId = 'worker-extend';\n    const lockDurationMs = 15000;\n    let jobToExtend: JobEntity<{data: string}, {res: string}>;\n\n    beforeEach(() => {\n        jobToExtend = JobEntity.create({ id: jobId, queueName, name: 'extend-me', payload: {data: 'payload'} });\n        jobToExtend.moveToActive(workerId, new Date(Date.now() + 10000)); // Initial lock\n        (mockJobRepository.findById as Mock).mockResolvedValue(jobToExtend);\n        (mockJobRepository.update as Mock).mockImplementation(async (jobEntity: JobEntity<any,any>) => jobEntity);\n    });\n\n    it('should extend lock for an active job owned by the worker', async () => {\n        const originalLockUntil = jobToExtend.lockUntil;\n        await queueService.extendJobLock(jobId, workerId, lockDurationMs);\n\n        expect(mockJobRepository.findById).toHaveBeenCalledWith(jobId);\n        expect(jobToExtend.lockUntil!.getTime()).toBeGreaterThan(originalLockUntil!.getTime());\n        expect(jobToExtend.lockUntil!.getTime()).toBeGreaterThanOrEqual(Date.now() + lockDurationMs - 1000); // Approx\n        expect(mockJobRepository.update).toHaveBeenCalledWith(jobToExtend);\n        expect(queueService.emit).toHaveBeenCalledWith('job.lock.extended', jobToExtend);\n    });\n\n    it('should accept string job ID for extendJobLock', async () => {\n        await queueService.extendJobLock(jobId.value, workerId, lockDurationMs);\n        expect(mockJobRepository.findById).toHaveBeenCalledWith(expect.objectContaining({ value: jobId.value }));\n        expect(mockJobRepository.update).toHaveBeenCalled();\n    });\n\n    it('should not extend lock if job not found', async () => {\n        (mockJobRepository.findById as Mock).mockResolvedValue(null);\n        await queueService.extendJobLock(jobId, workerId, lockDurationMs);\n        expect(mockJobRepository.update).not.toHaveBeenCalled();\n        expect(queueService.emit).not.toHaveBeenCalledWith('job.lock.extended', expect.anything());\n    });\n\n    it('should not extend lock if workerId does not match', async () => {\n        await queueService.extendJobLock(jobId, 'other-worker', lockDurationMs);\n        expect(mockJobRepository.update).not.toHaveBeenCalled();\n    });\n\n    it('should not extend lock if job is not active', async () => {\n        jobToExtend.markAsCompleted({res: 'done'});\n        await queueService.extendJobLock(jobId, workerId, lockDurationMs);\n        expect(mockJobRepository.update).not.toHaveBeenCalled();\n    });\n  });\n\n  describe('markJobAsCompleted', () => {\n    const jobId = JobIdVO.create('complete-job-id');\n    const workerId = 'worker-complete';\n    const result = { status: 'Email Sent!' };\n    let jobToComplete: JobEntity<{email: string}, {status: string}>;\n\n    beforeEach(() => {\n        jobToComplete = JobEntity.create({ id: jobId, queueName, name: 'complete-me', payload: {email: 'c@ex.com'} });\n        jobToComplete.moveToActive(workerId, new Date(Date.now() + 10000));\n        (mockJobRepository.findById as Mock).mockResolvedValue(jobToComplete);\n        (mockJobRepository.update as Mock).mockImplementation(async (jobEntity: JobEntity<any,any>) => jobEntity);\n    });\n\n    it('should mark job as completed, update, and emit event', async () => {\n        // Pass a new instance for jobInstanceWithChanges to simulate worker modifications\n        const jobInstanceFromWorker = JobEntity.fromPersistence({ ...jobToComplete.toPersistence(), logs: [...jobToComplete.logs, { message: 'Worker log', level: 'INFO', timestamp: new Date() }] });\n\n        await queueService.markJobAsCompleted(jobId, workerId, result, jobInstanceFromWorker);\n\n        expect(mockJobRepository.findById).toHaveBeenCalledWith(jobId);\n        expect(jobToComplete.status).toBe(JobStatus.COMPLETED);\n        expect(jobToComplete.returnValue).toEqual(result);\n        expect(jobToComplete.finishedOn).toBeInstanceOf(Date);\n        // expect(jobToComplete.logs.some(log => log.message === 'Worker log')).toBe(true); // This needs JobEntity to merge logs, or QueueService to do it.\n        // For now, the passed instance is not used to update the one fetched by findById\n        // The responsibility for merging logs/progress from jobInstanceWithChanges onto the job fetched from DB (jobToComplete)\n        // is not clearly defined in the current QueueService.markJobAsCompleted.\n        // It currently uses the job fetched from DB and calls markAsCompleted on it.\n        // The example `queue-usage-example.final.ts` shows job.addLog being called on the job instance within the processor,\n        // and then that job instance is passed to markJobAsCompleted/Failed.\n        // This implies that QueueService *should* use the logs/progress from jobInstanceWithChanges.\n        // Let's assume for now the test ensures the *status* and *result* are set on the DB-fetched job.\n\n        expect(mockJobRepository.update).toHaveBeenCalledWith(jobToComplete);\n        expect(queueService.emit).toHaveBeenCalledWith('job.completed', jobToComplete);\n    });\n\n     it('should accept string job ID for markJobAsCompleted', async () => {\n        const jobInstanceFromWorker = JobEntity.fromPersistence(jobToComplete.toPersistence());\n        await queueService.markJobAsCompleted(jobId.value, workerId, result, jobInstanceFromWorker);\n        expect(mockJobRepository.findById).toHaveBeenCalledWith(expect.objectContaining({value: jobId.value}));\n        expect(mockJobRepository.update).toHaveBeenCalled();\n    });\n\n    it('should not complete if job not found or workerId mismatch', async () => {\n        (mockJobRepository.findById as Mock).mockResolvedValue(null);\n        await queueService.markJobAsCompleted(jobId, workerId, result, jobToComplete);\n        expect(mockJobRepository.update).not.toHaveBeenCalled();\n\n        const anotherJob = JobEntity.create({id: jobId, queueName, name: 'x', payload:{email:'y@c.o'}});\n        anotherJob.moveToActive('another-worker', new Date());\n        (mockJobRepository.findById as Mock).mockResolvedValue(anotherJob);\n        await queueService.markJobAsCompleted(jobId, workerId, result, anotherJob); // Original workerId, but job is locked by another-worker\n        expect(mockJobRepository.update).not.toHaveBeenCalled();\n    });\n  });\n\n  describe('markJobAsFailed', () => {\n    const jobId = JobIdVO.create('fail-job-id');\n    const workerId = 'worker-fail';\n    const error = new Error('Test Job Failed');\n    let jobToFail: JobEntity<{email: string}, {status: string}>;\n\n    beforeEach(() => {\n        jobToFail = JobEntity.create({\n            id: jobId,\n            queueName,\n            name: 'fail-me',\n            payload: {email: 'f@ex.com'},\n            options: { attempts: 3, backoff: { type: BackoffType.EXPONENTIAL, delay: 100 } }\n        });\n        jobToFail.moveToActive(workerId, new Date(Date.now() + 10000)); // attemptsMade becomes 1\n        (mockJobRepository.findById as Mock).mockResolvedValue(jobToFail);\n        (mockJobRepository.update as Mock).mockImplementation(async (jobEntity: JobEntity<any,any>) => jobEntity);\n    });\n\n    it('should mark job as FAILED if attempts exhausted, update, and emit event', async () => {\n        jobToFail.options.attempts = 1; // Ensure it fails on this attempt\n        // jobToFail.moveToActive(workerId, new Date()); // already did in beforeEach, attemptsMade is 1\n\n        const jobInstanceFromWorker = JobEntity.fromPersistence(jobToFail.toPersistence());\n\n        await queueService.markJobAsFailed(jobId, workerId, error, jobInstanceFromWorker);\n\n        expect(mockJobRepository.findById).toHaveBeenCalledWith(jobId);\n        expect(jobToFail.status).toBe(JobStatus.FAILED);\n        expect(jobToFail.failedReason).toBe(error.message);\n        expect(jobToFail.finishedOn).toBeInstanceOf(Date);\n        expect(mockJobRepository.update).toHaveBeenCalledWith(jobToFail);\n        expect(queueService.emit).toHaveBeenCalledWith('job.failed', jobToFail);\n    });\n\n    it('should mark job as DELAYED if retries are pending, update, and emit event', async () => {\n        // jobToFail.options.attempts = 3; // Default from its creation\n        // jobToFail.moveToActive(workerId, new Date()); // attemptsMade becomes 1 in beforeEach\n\n        const jobInstanceFromWorker = JobEntity.fromPersistence(jobToFail.toPersistence());\n        await queueService.markJobAsFailed(jobId, workerId, error, jobInstanceFromWorker);\n\n        expect(mockJobRepository.findById).toHaveBeenCalledWith(jobId);\n        expect(jobToFail.status).toBe(JobStatus.DELAYED);\n        expect(jobToFail.failedReason).toBe(error.message); // Previous error\n        expect(jobToFail.delayUntil).toBeInstanceOf(Date);\n        // attemptsMade was 1 from moveToActive. It's not incremented by markJobAsFailed/moveToDelayed itself.\n        // The backoff calculation in QueueService uses job.attemptsMade which is 1. So backoff is 100 * 2^(1-1) = 100ms\n        expect(jobToFail.delayUntil!.getTime()).toBeGreaterThanOrEqual(Date.now() + 90); // Approx 100ms\n        expect(jobToFail.attemptsMade).toBe(1); // Remains 1, as this is the first failure processing\n\n        expect(mockJobRepository.update).toHaveBeenCalledWith(jobToFail);\n        expect(queueService.emit).toHaveBeenCalledWith('job.failed', jobToFail); // Event is still 'job.failed' even if delayed\n    });\n\n    it('should accept string job ID for markJobAsFailed', async () => {\n        const jobInstanceFromWorker = JobEntity.fromPersistence(jobToFail.toPersistence());\n        await queueService.markJobAsFailed(jobId.value, workerId, error, jobInstanceFromWorker);\n        expect(mockJobRepository.findById).toHaveBeenCalledWith(expect.objectContaining({ value: jobId.value }));\n        expect(mockJobRepository.update).toHaveBeenCalled();\n    });\n  });\n\n  describe('updateJobProgress', () => {\n    const jobId = JobIdVO.create('progress-job-id');\n    const workerId = 'worker-progress';\n    let jobToUpdate: JobEntity<any,any>;\n\n    beforeEach(() => {\n        jobToUpdate = JobEntity.create({id: jobId, queueName, name: 'progress-me', payload: {}});\n        jobToUpdate.moveToActive(workerId, new Date(Date.now() + 10000));\n        (mockJobRepository.findById as Mock).mockResolvedValue(jobToUpdate);\n        (mockJobRepository.update as Mock).mockImplementation(async (jobEntity: JobEntity<any,any>) => jobEntity);\n    });\n\n    it('should update progress, save, and emit event', async () => {\n        await queueService.updateJobProgress(jobId, workerId, 50);\n        expect(mockJobRepository.findById).toHaveBeenCalledWith(jobId);\n        expect(jobToUpdate.progress).toBe(50);\n        expect(mockJobRepository.update).toHaveBeenCalledWith(jobToUpdate);\n        expect(queueService.emit).toHaveBeenCalledWith('job.progress', jobToUpdate);\n\n        await queueService.updateJobProgress(jobId, workerId, { stage: 'processing' });\n        expect(jobToUpdate.progress).toEqual({ stage: 'processing' });\n        expect(mockJobRepository.update).toHaveBeenCalledTimes(2);\n        expect(queueService.emit).toHaveBeenCalledTimes(2);\n    });\n  });\n\n  describe('addJobLog', () => {\n    const jobId = JobIdVO.create('log-job-id');\n    const workerId = 'worker-log';\n    let jobToLogTo: JobEntity<any,any>;\n\n     beforeEach(() => {\n        jobToLogTo = JobEntity.create({id: jobId, queueName, name: 'log-me', payload: {}});\n        jobToLogTo.moveToActive(workerId, new Date(Date.now() + 10000));\n        (mockJobRepository.findById as Mock).mockResolvedValue(jobToLogTo);\n        (mockJobRepository.update as Mock).mockImplementation(async (jobEntity: JobEntity<any,any>) => jobEntity);\n    });\n\n    it('should add log, save, and emit event', async () => {\n        await queueService.addJobLog(jobId, workerId, 'Test log message', 'DEBUG');\n        expect(mockJobRepository.findById).toHaveBeenCalledWith(jobId);\n        expect(jobToLogTo.logs.length).toBe(1);\n        expect(jobToLogTo.logs[0].message).toBe('Test log message');\n        expect(jobToLogTo.logs[0].level).toBe('DEBUG');\n        expect(mockJobRepository.update).toHaveBeenCalledWith(jobToLogTo);\n        expect(queueService.emit).toHaveBeenCalledWith('job.log', jobToLogTo);\n    });\n  });\n\n  describe('startMaintenance (Stalled Jobs)', () => {\n    beforeEach(() => {\n        vi.useFakeTimers();\n    });\n    afterEach(() => {\n        vi.useRealTimers();\n    });\n\n    it('should periodically check for stalled jobs and handle them', async () => {\n        // This job should fail permanently after being stalled, as its maxAttempts is 1\n        const stalledJob1 = JobEntity.create({ queueName, name: 'stalled1', payload: {}, options: { attempts: 1 } });\n        stalledJob1.moveToActive('w-stall', new Date(Date.now() - 100000)); // Mark as active, attemptsMade is now 1. Lock already expired.\n        // Manually set status to ACTIVE if moveToActive doesn't persist it for the mock.\n        // In a real scenario, it would be ACTIVE in DB. For this test, ensure entity state is ACTIVE before stall processing.\n        stalledJob1.props.status = JobStatus.ACTIVE;\n\n\n        // This job should be re-queued as WAITING after being stalled, as it has attempts remaining\n        const stalledJob2 = JobEntity.create({ queueName, name: 'stalled2', payload: {}, options: { attempts: 2 } });\n        stalledJob2.moveToActive('w-stall2', new Date(Date.now() - 100000)); // Mark as active, attemptsMade is now 1. Lock expired.\n        stalledJob2.props.status = JobStatus.ACTIVE;\n\n        (mockJobRepository.findStalledJobs as Mock)\n            .mockResolvedValueOnce([stalledJob1, stalledJob2]) // First call to findStalledJobs\n            .mockResolvedValueOnce([]); // Subsequent calls find no more\n\n        (mockJobRepository.update as Mock).mockImplementation(async (job: JobEntity<any,any>) => {\n            // Simulate the update reflecting on the job instance for assertion purposes\n            if (job.id.value === stalledJob1.id.value) Object.assign(stalledJob1.props, job.props);\n            if (job.id.value === stalledJob2.id.value) Object.assign(stalledJob2.props, job.props);\n            return job;\n        });\n\n        queueService.startMaintenance();\n        await vi.advanceTimersByTimeAsync(15000); // Trigger interval for StalledJobsManager\n\n        expect(mockJobRepository.findStalledJobs).toHaveBeenCalledWith(queueName, expect.any(Date), 10);\n\n        // Assertions for stalledJob1\n        // attemptsMade (1) >= maxAttempts (1) is true. job.markAsStalled() returns true and sets status to FAILED.\n        expect(stalledJob1.status).toBe(JobStatus.FAILED);\n        expect(stalledJob1.failedReason).toContain('Job failed after becoming stalled');\n        expect(queueService.emit).toHaveBeenCalledWith('job.stalled', stalledJob1);\n        expect(mockJobRepository.update).toHaveBeenCalledWith(stalledJob1);\n\n        // Assertions for stalledJob2\n        // attemptsMade (1) >= maxAttempts (2) is false. job.markAsStalled() returns false. QueueService calls job.moveToWaiting().\n        expect(stalledJob2.status).toBe(JobStatus.WAITING);\n        expect(queueService.emit).toHaveBeenCalledWith('job.stalled', stalledJob2);\n        expect(mockJobRepository.update).toHaveBeenCalledWith(stalledJob2);\n\n        await vi.advanceTimersByTimeAsync(15000); // Trigger interval again\n        expect(mockJobRepository.findStalledJobs).toHaveBeenCalledTimes(2);\n\n        queueService.close(); // Clears interval\n    });\n  });\n\n  // TODO: Tests for pause, resume, clean, countJobsByStatus, getJobsByStatus\n  // Pause/Resume only emit events, so tests would be simple event checks.\n  // clean, countJobsByStatus, getJobsByStatus directly call repository methods,\n  // so tests would verify the repository method is called with correct args and returns mapped results.\n\n  describe('pause', () => {\n    it('should emit queue.paused event', async () => {\n      await queueService.pause();\n      expect(queueService.emit).toHaveBeenCalledWith('queue.paused');\n    });\n  });\n\n  describe('resume', () => {\n    it('should emit queue.resumed event', async () => {\n      await queueService.resume();\n      expect(queueService.emit).toHaveBeenCalledWith('queue.resumed');\n    });\n  });\n\n  describe('clean', () => {\n    it('should call jobRepository.clean and return the count', async () => {\n      const gracePeriodMs = 60000;\n      const limit = 10;\n      const status = JobStatus.COMPLETED;\n      (mockJobRepository.clean as Mock).mockResolvedValue(5);\n\n      const cleanedCount = await queueService.clean(gracePeriodMs, limit, status);\n\n      expect(mockJobRepository.clean).toHaveBeenCalledWith(queueName, gracePeriodMs, limit, status);\n      expect(cleanedCount).toBe(5);\n    });\n  });\n\n  describe('countJobsByStatus', () => {\n    it('should call jobRepository.countJobsByStatus and return the counts', async () => {\n      const statuses = [JobStatus.WAITING, JobStatus.FAILED];\n      const counts = { [JobStatus.WAITING]: 3, [JobStatus.FAILED]: 2 };\n      (mockJobRepository.countJobsByStatus as Mock).mockResolvedValue(counts);\n\n      const result = await queueService.countJobsByStatus(statuses);\n\n      expect(mockJobRepository.countJobsByStatus).toHaveBeenCalledWith(queueName, statuses);\n      expect(result).toEqual(counts);\n    });\n  });\n\n  describe('getJobsByStatus', () => {\n    it('should call jobRepository.getJobsByStatus and return mapped jobs', async () => {\n      const statuses = [JobStatus.COMPLETED];\n      const mockJobs = [\n        JobEntity.create({ queueName, name: 'job1', payload: {} }),\n        JobEntity.create({ queueName, name: 'job2', payload: {} }),\n      ];\n      (mockJobRepository.getJobsByStatus as Mock).mockResolvedValue(mockJobs);\n\n      const result = await queueService.getJobsByStatus(statuses, 0, 10, true);\n\n      expect(mockJobRepository.getJobsByStatus).toHaveBeenCalledWith(queueName, statuses, 0, 10, true);\n      expect(result).toEqual(mockJobs);\n      expect(result.length).toBe(2);\n    });\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/queue/drizzle/queue.service.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'NodeJS' is not defined.","line":9,"column":31,"nodeType":"Identifier","messageId":"undef","endLine":9,"endColumn":37},{"ruleId":"id-length","severity":1,"message":"Identifier name 'j' is too short (< 2).","line":27,"column":34,"nodeType":"Identifier","messageId":"tooShort","endLine":27,"endColumn":35},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'jobInstanceWithChanges' is defined but never used. Allowed unused args must match /^_/u.","line":105,"column":82,"nodeType":null,"messageId":"unusedVar","endLine":105,"endColumn":104},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'jobInstanceWithChanges' is defined but never used. Allowed unused args must match /^_/u.","line":115,"column":82,"nodeType":null,"messageId":"unusedVar","endLine":115,"endColumn":104}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src_refactored/infrastructure/queue/drizzle/queue.service.ts\nimport { IJobRepository } from '@/core/application/ports/job-repository.interface';\nimport { AbstractQueue } from '@/core/application/queue/abstract-queue';\nimport { JobEntity, JobStatus } from '@/core/domain/job/job.entity';\nimport { JobIdVO } from '@/core/domain/job/value-objects/job-id.vo';\nimport { IJobOptions } from '@/core/domain/job/value-objects/job-options.vo';\n\nexport class QueueService<P, R> extends AbstractQueue<P, R> {\n  private stalledJobsManager: NodeJS.Timeout | null = null;\n\n  constructor(\n    queueName: string,\n    jobRepository: IJobRepository,\n    defaultJobOptions?: IJobOptions,\n  ) {\n    super(queueName, jobRepository, defaultJobOptions);\n  }\n\n  async add(jobName: string, data: P, opts?: IJobOptions): Promise<JobEntity<P, R>> {\n    const job = JobEntity.create<P, R>({ queueName: this.queueName, name: jobName, payload: data, options: { ...this.defaultJobOptions.toPersistence(), ...opts } });\n    await this.jobRepository.save(job);\n    this.emit('job.added', job);\n    return job;\n  }\n\n  async addBulk(jobs: Array<{ name: string; data: P; opts?: IJobOptions }>): Promise<Array<JobEntity<P, R>>> {\n    const jobEntities = jobs.map(j => JobEntity.create<P, R>({ queueName: this.queueName, name: j.name, payload: j.data, options: { ...this.defaultJobOptions.toPersistence(), ...j.opts } }));\n    for (const job of jobEntities) {\n      await this.jobRepository.save(job);\n      this.emit('job.added', job);\n    }\n    return jobEntities;\n  }\n\n  async getJob(jobId: string | JobIdVO): Promise<JobEntity<P, R> | null> {\n    const id = jobId instanceof JobIdVO ? jobId : JobIdVO.create(jobId);\n    return await this.jobRepository.findById(id) as JobEntity<P, R> | null;\n  }\n\n  async getJobsByStatus(statuses: JobStatus[], start?: number, end?: number, asc?: boolean): Promise<Array<JobEntity<P, R>>> {\n    return await this.jobRepository.getJobsByStatus(this.queueName, statuses, start, end, asc) as Array<JobEntity<P, R>>;\n  }\n\n  async countJobsByStatus(statuses?: JobStatus[]): Promise<Partial<Record<JobStatus, number>>> {\n    return await this.jobRepository.countJobsByStatus(this.queueName, statuses);\n  }\n\n  async pause(): Promise<void> {\n    // This should ideally be a state in the queue itself, not on each job.\n    // For now, we'll just stop processing new jobs.\n    this.emit('queue.paused');\n  }\n\n  async resume(): Promise<void> {\n    this.emit('queue.resumed');\n  }\n\n  async clean(gracePeriodMs: number, limit: number, status?: JobStatus): Promise<number> {\n    return await this.jobRepository.clean(this.queueName, gracePeriodMs, limit, status);\n  }\n\n  async close(): Promise<void> {\n    if (this.stalledJobsManager) {\n      clearInterval(this.stalledJobsManager);\n    }\n    this.emit('queue.closed');\n  }\n\n  async fetchNextJobAndLock(workerId: string, lockDurationMs: number): Promise<JobEntity<P, R> | null> {\n    console.log(`[QueueService] Attempting to fetch next job for worker ${workerId}...`);\n    const jobs = await this.jobRepository.findNextJobsToProcess(this.queueName, 1);\n    if (jobs.length === 0) {\n      console.log(`[QueueService] No jobs found for worker ${workerId}.`);\n      return null;\n    }\n\n    const job = jobs[0] as JobEntity<P, R>;\n    console.log(`[QueueService] Found job ${job.id.value}. Attempting to acquire lock...`);\n    const lockUntil = new Date(Date.now() + lockDurationMs);\n    const locked = await this.jobRepository.acquireLock(job.id, workerId, lockUntil);\n\n    if (locked) {\n      console.log(`[QueueService] Lock acquired for job ${job.id.value}. Moving to active.`);\n      job.moveToActive(workerId, lockUntil);\n      await this.jobRepository.update(job);\n      this.emit('job.active', job);\n      return job;\n    }\n      console.log(`[QueueService] Failed to acquire lock for job ${job.id.value}.`);\n      return null;\n\n  }\n\n  async extendJobLock(jobId: string | JobIdVO, workerId: string, lockDurationMs: number): Promise<void> {\n    const id = jobId instanceof JobIdVO ? jobId : JobIdVO.create(jobId);\n    const job = await this.getJob(id);\n    if (job && job.workerId === workerId && job.status === JobStatus.ACTIVE) {\n      const newLockUntil = new Date(Date.now() + lockDurationMs);\n      job.extendLock(newLockUntil, workerId);\n      await this.jobRepository.update(job);\n      this.emit('job.lock.extended', job);\n    }\n  }\n\n  async markJobAsCompleted(jobId: string | JobIdVO, workerId: string, result: R, jobInstanceWithChanges: JobEntity<P, R>): Promise<void> {\n    const id = jobId instanceof JobIdVO ? jobId : JobIdVO.create(jobId);\n    const job = await this.getJob(id);\n    if (job && job.workerId === workerId) {\n      job.markAsCompleted(result);\n      await this.jobRepository.update(job);\n      this.emit('job.completed', job);\n    }\n  }\n\n  async markJobAsFailed(jobId: string | JobIdVO, workerId: string, error: Error, jobInstanceWithChanges: JobEntity<P, R>): Promise<void> {\n    const id = jobId instanceof JobIdVO ? jobId : JobIdVO.create(jobId);\n    const job = await this.getJob(id);\n    if (job && job.workerId === workerId) {\n      if (job.attemptsMade < job.maxAttempts) {\n        const delay = job.options.backoff?.delay || 1000;\n        const backoff = job.options.backoff?.type === 'exponential' ? delay * Math.pow(2, job.attemptsMade - 1) : delay;\n        job.moveToDelayed(new Date(Date.now() + backoff), error);\n      } else {\n        job.markAsFailed(error.message, error.stack?.split('\\n'));\n      }\n      await this.jobRepository.update(job);\n      this.emit('job.failed', job);\n    }\n  }\n\n  async updateJobProgress(jobId: string | JobIdVO, workerId: string, progress: number | object): Promise<void> {\n    const id = jobId instanceof JobIdVO ? jobId : JobIdVO.create(jobId);\n    const job = await this.getJob(id);\n    if (job && job.workerId === workerId) {\n      job.updateProgress(progress);\n      await this.jobRepository.update(job);\n      this.emit('job.progress', job);\n    }\n  }\n\n  async addJobLog(jobId: string | JobIdVO, workerId: string, message: string, level?: string): Promise<void> {\n    const id = jobId instanceof JobIdVO ? jobId : JobIdVO.create(jobId);\n    const job = await this.getJob(id);\n    if (job && job.workerId === workerId) {\n      job.addLog(message, level);\n      await this.jobRepository.update(job);\n      this.emit('job.log', job);\n    }\n  }\n\n  startMaintenance(): void {\n    if (this.stalledJobsManager) return;\n    this.stalledJobsManager = setInterval(async () => {\n      const stalledJobs = await this.jobRepository.findStalledJobs(this.queueName, new Date(), 10);\n      for (const job of stalledJobs) {\n        const shouldFail = job.markAsStalled();\n        if (shouldFail) {\n          job.markAsFailed('Job failed after becoming stalled and exceeding max attempts.');\n        } else {\n          job.moveToWaiting();\n        }\n        await this.jobRepository.update(job);\n        this.emit('job.stalled', job);\n      }\n    }, 15000);\n  }\n}","usedDeprecatedRules":[]}]