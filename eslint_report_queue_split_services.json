[{"filePath":"/app/src_refactored/infrastructure/queue/drizzle/job-processing.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":40,"fix":{"range":[112,112],"text":"\n"}},{"ruleId":"no-inline-comments","severity":2,"message":"Unexpected comment inline with code.","line":12,"column":50,"nodeType":"Line","messageId":"unexpectedInlineComment","endLine":12,"endColumn":83},{"ruleId":"no-inline-comments","severity":2,"message":"Unexpected comment inline with code.","line":13,"column":40,"nodeType":"Line","messageId":"unexpectedInlineComment","endLine":13,"endColumn":102},{"ruleId":"no-inline-comments","severity":2,"message":"Unexpected comment inline with code.","line":22,"column":23,"nodeType":"Line","messageId":"unexpectedInlineComment","endLine":22,"endColumn":73},{"ruleId":"no-inline-comments","severity":2,"message":"Unexpected comment inline with code.","line":69,"column":47,"nodeType":"Line","messageId":"unexpectedInlineComment","endLine":69,"endColumn":103}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"// src_refactored/infrastructure/queue/drizzle/job-processing.service.ts\nimport EventEmitter from 'node:events';\nimport { IJobRepository } from \"@/core/application/ports/job-repository.interface\";\nimport { JobEntity, JobStatus } from \"@/core/domain/job/job.entity\";\nimport { JobIdVO } from \"@/core/domain/job/value-objects/job-id.vo\";\n// IJobOptions might be needed if default options are used from a central place, but likely not for this service.\n\n// This service could implement a more specific interface like IJobProcessorService\nexport class JobProcessingService<P, R> {\n  constructor(\n    private readonly jobRepository: IJobRepository,\n    private readonly eventEmitter: EventEmitter, // Or a dedicated JobEventEmitter\n    private readonly queueName: string // Needed for some repository calls if they are queue-specific\n  ) {}\n\n  // Corresponds to AbstractQueue.fetchNextJobAndLock\n  async fetchNextJobAndLock(\n    workerId: string,\n    lockDurationMs: number\n  ): Promise<JobEntity<P, R> | null> {\n    const jobs = await this.jobRepository.findNextJobsToProcess(\n      this.queueName, // Assumes findNextJobsToProcess is queue-specific\n      1\n    );\n    if (jobs.length === 0) {\n      return null;\n    }\n\n    const job = jobs[0] as JobEntity<P, R>;\n    const jobProps = job.getProps();\n    const lockUntil = new Date(Date.now() + lockDurationMs);\n    const locked = await this.jobRepository.acquireLock(\n      jobProps.id,\n      workerId,\n      lockUntil\n    );\n\n    if (locked) {\n      job.moveToActive(workerId, lockUntil);\n      await this.jobRepository.update(job);\n      this.eventEmitter.emit(\"job.active\", job);\n      return job;\n    }\n    return null;\n  }\n\n  // Corresponds to AbstractQueue.extendJobLock\n  async extendJobLock(\n    jobId: string | JobIdVO,\n    workerId: string,\n    lockDurationMs: number\n  ): Promise<void> {\n    const id = jobId instanceof JobIdVO ? jobId : JobIdVO.create(jobId);\n    // getJob might come from jobRepository or a core service\n    const job = (await this.jobRepository.findById(id)) as JobEntity<P,R> | null; \n    if (job && job.getProps().workerId === workerId && job.getProps().status === JobStatus.ACTIVE) {\n      const newLockUntil = new Date(Date.now() + lockDurationMs);\n      job.extendLock(newLockUntil, workerId);\n      await this.jobRepository.update(job);\n      this.eventEmitter.emit(\"job.lock.extended\", job);\n    }\n  }\n\n  // Corresponds to AbstractQueue.markJobAsCompleted\n  async markJobAsCompleted(\n    jobId: string | JobIdVO,\n    workerId: string,\n    result: R,\n    _jobInstanceWithChanges?: JobEntity<P, R> // This param might be simplified or handled differently\n  ): Promise<void> {\n    const id = jobId instanceof JobIdVO ? jobId : JobIdVO.create(jobId);\n    const job = (await this.jobRepository.findById(id)) as JobEntity<P,R> | null;\n    if (job && job.getProps().workerId === workerId) {\n      job.markAsCompleted(result);\n      await this.jobRepository.update(job);\n      this.eventEmitter.emit(\"job.completed\", job);\n    }\n  }\n\n  // Corresponds to AbstractQueue.markJobAsFailed\n  async markJobAsFailed(\n    jobId: string | JobIdVO,\n    workerId: string,\n    error: Error,\n    _jobInstanceWithChanges?: JobEntity<P, R>\n  ): Promise<void> {\n    const id = jobId instanceof JobIdVO ? jobId : JobIdVO.create(jobId);\n    const job = (await this.jobRepository.findById(id)) as JobEntity<P,R> | null;\n    if (job && job.getProps().workerId === workerId) {\n      this._handleFailedJobRetryOrPermanentFail(job, error);\n      await this.jobRepository.update(job);\n      this.eventEmitter.emit(\"job.failed\", job);\n    }\n  }\n\n  private _handleFailedJobRetryOrPermanentFail(job: JobEntity<P,R>, error: Error): void {\n    const jobProps = job.getProps();\n    if (jobProps.attemptsMade < job.maxAttempts) {\n      const baseDelay = jobProps.options.backoff?.delay || 1000;\n      let backoffDelay = baseDelay;\n      if (jobProps.options.backoff?.type === \"exponential\") {\n        const currentAttempt = Math.max(1, jobProps.attemptsMade);\n        backoffDelay = baseDelay * Math.pow(2, currentAttempt - 1);\n      }\n      const maxBackoff = jobProps.options.backoff?.maxDelay || 3600000;\n      backoffDelay = Math.min(backoffDelay, maxBackoff);\n      job.moveToDelayed(new Date(Date.now() + backoffDelay), error);\n    } else {\n      job.markAsFailed(error.message, error.stack?.split(\"\\n\"));\n    }\n  }\n\n  // Corresponds to AbstractQueue.updateJobProgress\n  async updateJobProgress(\n    jobId: string | JobIdVO,\n    workerId: string,\n    progress: number | object\n  ): Promise<void> {\n    const id = jobId instanceof JobIdVO ? jobId : JobIdVO.create(jobId);\n    const job = (await this.jobRepository.findById(id)) as JobEntity<P,R> | null;\n    if (job && job.getProps().workerId === workerId) {\n      job.updateProgress(progress);\n      await this.jobRepository.update(job);\n      this.eventEmitter.emit(\"job.progress\", job);\n    }\n  }\n\n  // Corresponds to AbstractQueue.addJobLog\n  async addJobLog(\n    jobId: string | JobIdVO,\n    workerId: string,\n    message: string,\n    level?: string\n  ): Promise<void> {\n    const id = jobId instanceof JobIdVO ? jobId : JobIdVO.create(jobId);\n    const job = (await this.jobRepository.findById(id)) as JobEntity<P,R> | null;\n    if (job && job.getProps().workerId === workerId) {\n      job.addLog(message, level);\n      await this.jobRepository.update(job);\n      this.eventEmitter.emit(\"job.log\", job);\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/queue/drizzle/queue-maintenance.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":40,"fix":{"range":[115,115],"text":"\n"}},{"ruleId":"no-inline-comments","severity":2,"message":"Unexpected comment inline with code.","line":4,"column":59,"nodeType":"Line","messageId":"unexpectedInlineComment","endLine":4,"endColumn":96},{"ruleId":"no-inline-comments","severity":2,"message":"Unexpected comment inline with code.","line":10,"column":59,"nodeType":"Line","messageId":"unexpectedInlineComment","endLine":10,"endColumn":95},{"ruleId":"no-inline-comments","severity":2,"message":"Unexpected comment inline with code.","line":14,"column":50,"nodeType":"Line","messageId":"unexpectedInlineComment","endLine":14,"endColumn":83},{"ruleId":"no-inline-comments","severity":2,"message":"Unexpected comment inline with code.","line":54,"column":24,"nodeType":"Line","messageId":"unexpectedInlineComment","endLine":54,"endColumn":77}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"// src_refactored/infrastructure/queue/drizzle/queue-maintenance.service.ts\nimport EventEmitter from 'node:events';\nimport { IJobRepository } from \"@/core/application/ports/job-repository.interface\";\nimport { JobEntity } from \"@/core/domain/job/job.entity\"; // JobStatus not directly needed here\n\n// This service could implement an IQueueMaintenanceService interface\nexport class QueueMaintenanceService<P, R> {\n  private _isMaintenanceRunning: boolean = false;\n  private maintenanceLoopPromise: Promise<void> | null = null;\n  private readonly maintenanceIntervalMs: number = 15000; // Consider making this configurable\n\n  constructor(\n    private readonly jobRepository: IJobRepository,\n    private readonly eventEmitter: EventEmitter, // Or a dedicated JobEventEmitter\n    private readonly queueName: string\n  ) {}\n\n  // Corresponds to AbstractQueue.startMaintenance\n  public startMaintenance(): void {\n    if (this._isMaintenanceRunning) return;\n    this._isMaintenanceRunning = true;\n    this.maintenanceLoopPromise = this.runMaintenanceLoop();\n  }\n\n  // Corresponds to AbstractQueue.stopMaintenance\n  public async stopMaintenance(): Promise<void> {\n    if (!this._isMaintenanceRunning && !this.maintenanceLoopPromise) {\n      return;\n    }\n    this._isMaintenanceRunning = false;\n    if (this.maintenanceLoopPromise) {\n      try {\n        await this.maintenanceLoopPromise;\n      } catch (error) {\n        this.eventEmitter.emit(\"queue.error\", new Error(`Maintenance loop stop error: ${error instanceof Error ? error.message : String(error)}`));\n      }\n    }\n    this.maintenanceLoopPromise = null;\n  }\n\n  private async runMaintenanceLoop(): Promise<void> {\n    while (this._isMaintenanceRunning) {\n      try {\n        // Limit fetching to 10 stalled jobs per cycle\n        const stalledJobs = await this.jobRepository.findStalledJobs(\n          this.queueName,\n          new Date(),\n          10 \n        );\n        for (const job of stalledJobs) {\n          await this._processStalledJob(job as JobEntity<P, R>);\n        }\n      } catch (error) {\n        console.error( // Keep console.error for critical maintenance issues\n          \"[QueueMaintenanceService] Error during stalled job maintenance:\",\n          error\n        );\n        this.eventEmitter.emit(\"queue.error\", new Error(`Stalled job maintenance: ${error instanceof Error ? error.message : String(error)}`));\n      }\n\n      if (this._isMaintenanceRunning) {\n        await new Promise((resolve) =>\n          setTimeout(resolve, this.maintenanceIntervalMs)\n        );\n      }\n    }\n  }\n\n  private async _processStalledJob(jobEntity: JobEntity<P, R>): Promise<void> {\n    const wasAlreadyFailedByStallLogic = jobEntity.markAsStalled();\n\n    if (!wasAlreadyFailedByStallLogic) {\n      jobEntity.moveToWaiting();\n    }\n    await this.jobRepository.update(jobEntity);\n    this.eventEmitter.emit(\"job.stalled\", jobEntity);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/queue/drizzle/queue-service-core.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'JobOptionsVO' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":35}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'workerId' is defined but never used. Allowed unused args must match /^_/u.","line":129,"column":29,"nodeType":null,"messageId":"unusedVar","endLine":129,"endColumn":37,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'lockDurationMs' is defined but never used. Allowed unused args must match /^_/u.","line":129,"column":47,"nodeType":null,"messageId":"unusedVar","endLine":129,"endColumn":61,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'jobId' is defined but never used. Allowed unused args must match /^_/u.","line":132,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":132,"endColumn":28,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'workerId' is defined but never used. Allowed unused args must match /^_/u.","line":132,"column":48,"nodeType":null,"messageId":"unusedVar","endLine":132,"endColumn":56,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'lockDurationMs' is defined but never used. Allowed unused args must match /^_/u.","line":132,"column":66,"nodeType":null,"messageId":"unusedVar","endLine":132,"endColumn":80,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'jobId' is defined but never used. Allowed unused args must match /^_/u.","line":135,"column":28,"nodeType":null,"messageId":"unusedVar","endLine":135,"endColumn":33,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'workerId' is defined but never used. Allowed unused args must match /^_/u.","line":135,"column":53,"nodeType":null,"messageId":"unusedVar","endLine":135,"endColumn":61,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'result' is defined but never used. Allowed unused args must match /^_/u.","line":135,"column":71,"nodeType":null,"messageId":"unusedVar","endLine":135,"endColumn":77,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'jobInstanceWithChanges' is defined but never used. Allowed unused args must match /^_/u.","line":135,"column":82,"nodeType":null,"messageId":"unusedVar","endLine":135,"endColumn":104,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'jobId' is defined but never used. Allowed unused args must match /^_/u.","line":138,"column":25,"nodeType":null,"messageId":"unusedVar","endLine":138,"endColumn":30,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'workerId' is defined but never used. Allowed unused args must match /^_/u.","line":138,"column":50,"nodeType":null,"messageId":"unusedVar","endLine":138,"endColumn":58,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used. Allowed unused args must match /^_/u.","line":138,"column":68,"nodeType":null,"messageId":"unusedVar","endLine":138,"endColumn":73,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'jobInstanceWithChanges' is defined but never used. Allowed unused args must match /^_/u.","line":138,"column":82,"nodeType":null,"messageId":"unusedVar","endLine":138,"endColumn":104,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'jobId' is defined but never used. Allowed unused args must match /^_/u.","line":141,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":141,"endColumn":32,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'workerId' is defined but never used. Allowed unused args must match /^_/u.","line":141,"column":52,"nodeType":null,"messageId":"unusedVar","endLine":141,"endColumn":60,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'progress' is defined but never used. Allowed unused args must match /^_/u.","line":141,"column":70,"nodeType":null,"messageId":"unusedVar","endLine":141,"endColumn":78,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'jobId' is defined but never used. Allowed unused args must match /^_/u.","line":144,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":144,"endColumn":24,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'workerId' is defined but never used. Allowed unused args must match /^_/u.","line":144,"column":44,"nodeType":null,"messageId":"unusedVar","endLine":144,"endColumn":52,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'message' is defined but never used. Allowed unused args must match /^_/u.","line":144,"column":62,"nodeType":null,"messageId":"unusedVar","endLine":144,"endColumn":69,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'level' is defined but never used. Allowed unused args must match /^_/u.","line":144,"column":79,"nodeType":null,"messageId":"unusedVar","endLine":144,"endColumn":84,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src_refactored/infrastructure/queue/drizzle/queue-service-core.ts\nimport { IJobRepository } from \"@/core/application/ports/job-repository.interface\";\nimport { AbstractQueue } from \"@/core/application/queue/abstract-queue\";\nimport { JobEntity, JobStatus } from \"@/core/domain/job/job.entity\";\nimport { JobIdVO } from \"@/core/domain/job/value-objects/job-id.vo\";\nimport { IJobOptions, JobOptionsVO } from \"@/core/domain/job/value-objects/job-options.vo\";\n\n// Forward declaration for IQueueMaintenanceService to break circular dependency if needed for close()\ninterface IQueueMaintenanceService {\n  stopMaintenance(): Promise<void>;\n}\n\nexport class QueueServiceCore<P, R> extends AbstractQueue<P, R> {\n  // Maintenance service can be optional or injected if close needs to call it\n  private maintenanceService?: IQueueMaintenanceService;\n\n  constructor(\n    queueName: string,\n    jobRepository: IJobRepository,\n    defaultJobOptions?: IJobOptions,\n    maintenanceService?: IQueueMaintenanceService\n  ) {\n    super(queueName, jobRepository, defaultJobOptions);\n    this.maintenanceService = maintenanceService;\n  }\n\n  public setMaintenanceService(service: IQueueMaintenanceService): void {\n    this.maintenanceService = service;\n  }\n\n  async add(\n    jobName: string,\n    data: P,\n    opts?: IJobOptions\n  ): Promise<JobEntity<P, R>> {\n    const job = JobEntity.create<P, R>({\n      queueName: this.queueName,\n      name: jobName,\n      payload: data,\n      options: { ...this.defaultJobOptions.toPersistence(), ...opts },\n    });\n    await this.jobRepository.save(job);\n    this.emit(\"job.added\", job);\n    return job;\n  }\n\n  async addBulk(\n    jobs: Array<{ name: string; data: P; opts?: IJobOptions }>\n  ): Promise<Array<JobEntity<P, R>>> {\n    const jobEntities = jobs.map((jobDef) =>\n      JobEntity.create<P, R>({\n        queueName: this.queueName,\n        name: jobDef.name,\n        payload: jobDef.data,\n        options: { ...this.defaultJobOptions.toPersistence(), ...jobDef.opts },\n      })\n    );\n    for (const job of jobEntities) {\n      await this.jobRepository.save(job);\n      this.emit(\"job.added\", job);\n    }\n    return jobEntities;\n  }\n\n  async getJob(jobId: string | JobIdVO): Promise<JobEntity<P, R> | null> {\n    const id = jobId instanceof JobIdVO ? jobId : JobIdVO.create(jobId);\n    return (await this.jobRepository.findById(id)) as JobEntity<P, R> | null;\n  }\n\n  async getJobsByStatus(\n    statuses: JobStatus[],\n    start?: number,\n    end?: number,\n    asc?: boolean\n  ): Promise<Array<JobEntity<P, R>>> {\n    return (await this.jobRepository.getJobsByStatus(\n      this.queueName,\n      statuses,\n      start,\n      end,\n      asc\n    )) as Array<JobEntity<P, R>>;\n  }\n\n  async countJobsByStatus(\n    statuses?: JobStatus[]\n  ): Promise<Partial<Record<JobStatus, number>>> {\n    return await this.jobRepository.countJobsByStatus(this.queueName, statuses);\n  }\n\n  async pause(): Promise<void> {\n    this.emit(\"queue.paused\");\n    // Actual pause logic might involve signaling workers or preventing job fetching\n  }\n\n  async resume(): Promise<void> {\n    this.emit(\"queue.resumed\");\n    // Actual resume logic\n  }\n\n  async clean(\n    gracePeriodMs: number,\n    limit: number,\n    status?: JobStatus\n  ): Promise<number> {\n    return await this.jobRepository.clean(\n      this.queueName,\n      gracePeriodMs,\n      limit,\n      status\n    );\n  }\n\n  public async close(): Promise<void> {\n    if (this.maintenanceService) {\n      await this.maintenanceService.stopMaintenance();\n    }\n    this.emit(\"queue.closed\");\n    // Add any other core cleanup logic here (e.g., database connections if managed directly)\n  }\n\n  // Methods from AbstractQueue that will be implemented by other services\n  // These will need to be handled, possibly by changing AbstractQueue or by composition.\n  // For now, to make QueueServiceCore a valid extension of AbstractQueue (if it were complete),\n  // these would need to be abstract or throw errors.\n  // However, the goal is that QueueServiceCore *won't* be the sole implementer of AbstractQueue.\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  async fetchNextJobAndLock(workerId: string, lockDurationMs: number): Promise<JobEntity<P, R> | null> {\n    throw new Error(\"Method not implemented in QueueServiceCore. See JobProcessingService.\");\n  }\n  async extendJobLock(jobId: string | JobIdVO, workerId: string, lockDurationMs: number): Promise<void> {\n    throw new Error(\"Method not implemented in QueueServiceCore. See JobProcessingService.\");\n  }\n  async markJobAsCompleted(jobId: string | JobIdVO, workerId: string, result: R, jobInstanceWithChanges: JobEntity<P,R>): Promise<void> {\n    throw new Error(\"Method not implemented in QueueServiceCore. See JobProcessingService.\");\n  }\n  async markJobAsFailed(jobId: string | JobIdVO, workerId: string, error: Error, jobInstanceWithChanges: JobEntity<P,R>): Promise<void> {\n    throw new Error(\"Method not implemented in QueueServiceCore. See JobProcessingService.\");\n  }\n  async updateJobProgress(jobId: string | JobIdVO, workerId: string, progress: number | object): Promise<void> {\n    throw new Error(\"Method not implemented in QueueServiceCore. See JobProcessingService.\");\n  }\n  async addJobLog(jobId: string | JobIdVO, workerId: string, message: string, level?: string): Promise<void> {\n    throw new Error(\"Method not implemented in QueueServiceCore. See JobProcessingService.\");\n  }\n  startMaintenance(): void {\n    throw new Error(\"Method not implemented in QueueServiceCore. See QueueMaintenanceService.\");\n  }\n  async stopMaintenance(): Promise<void> {\n    throw new Error(\"Method not implemented in QueueServiceCore. See QueueMaintenanceService.\");\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n}\n","usedDeprecatedRules":[]}]
