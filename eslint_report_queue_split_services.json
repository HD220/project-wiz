[{"filePath":"/app/src_refactored/infrastructure/queue/drizzle/job-processing.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/queue/drizzle/queue-maintenance.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/queue/drizzle/queue-service-core.ts","messages":[{"ruleId":"no-inline-comments","severity":2,"message":"Unexpected comment inline with code.","line":6,"column":79,"nodeType":"Line","messageId":"unexpectedInlineComment","endLine":6,"endColumn":102},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'workerId' is defined but never used. Allowed unused args must match /^_/u.","line":129,"column":29,"nodeType":null,"messageId":"unusedVar","endLine":129,"endColumn":37},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'lockDurationMs' is defined but never used. Allowed unused args must match /^_/u.","line":129,"column":47,"nodeType":null,"messageId":"unusedVar","endLine":129,"endColumn":61},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'jobId' is defined but never used. Allowed unused args must match /^_/u.","line":132,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":132,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'workerId' is defined but never used. Allowed unused args must match /^_/u.","line":132,"column":48,"nodeType":null,"messageId":"unusedVar","endLine":132,"endColumn":56},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'lockDurationMs' is defined but never used. Allowed unused args must match /^_/u.","line":132,"column":66,"nodeType":null,"messageId":"unusedVar","endLine":132,"endColumn":80},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'jobId' is defined but never used. Allowed unused args must match /^_/u.","line":135,"column":28,"nodeType":null,"messageId":"unusedVar","endLine":135,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'workerId' is defined but never used. Allowed unused args must match /^_/u.","line":135,"column":53,"nodeType":null,"messageId":"unusedVar","endLine":135,"endColumn":61},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'result' is defined but never used. Allowed unused args must match /^_/u.","line":135,"column":71,"nodeType":null,"messageId":"unusedVar","endLine":135,"endColumn":77},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'jobInstanceWithChanges' is defined but never used. Allowed unused args must match /^_/u.","line":135,"column":82,"nodeType":null,"messageId":"unusedVar","endLine":135,"endColumn":104},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'jobId' is defined but never used. Allowed unused args must match /^_/u.","line":138,"column":25,"nodeType":null,"messageId":"unusedVar","endLine":138,"endColumn":30},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'workerId' is defined but never used. Allowed unused args must match /^_/u.","line":138,"column":50,"nodeType":null,"messageId":"unusedVar","endLine":138,"endColumn":58},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used. Allowed unused args must match /^_/u.","line":138,"column":68,"nodeType":null,"messageId":"unusedVar","endLine":138,"endColumn":73},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'jobInstanceWithChanges' is defined but never used. Allowed unused args must match /^_/u.","line":138,"column":82,"nodeType":null,"messageId":"unusedVar","endLine":138,"endColumn":104},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'jobId' is defined but never used. Allowed unused args must match /^_/u.","line":141,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":141,"endColumn":32},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'workerId' is defined but never used. Allowed unused args must match /^_/u.","line":141,"column":52,"nodeType":null,"messageId":"unusedVar","endLine":141,"endColumn":60},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'progress' is defined but never used. Allowed unused args must match /^_/u.","line":141,"column":70,"nodeType":null,"messageId":"unusedVar","endLine":141,"endColumn":78},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'jobId' is defined but never used. Allowed unused args must match /^_/u.","line":144,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":144,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'workerId' is defined but never used. Allowed unused args must match /^_/u.","line":144,"column":44,"nodeType":null,"messageId":"unusedVar","endLine":144,"endColumn":52},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'message' is defined but never used. Allowed unused args must match /^_/u.","line":144,"column":62,"nodeType":null,"messageId":"unusedVar","endLine":144,"endColumn":69},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'level' is defined but never used. Allowed unused args must match /^_/u.","line":144,"column":79,"nodeType":null,"messageId":"unusedVar","endLine":144,"endColumn":84}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":20,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src_refactored/infrastructure/queue/drizzle/queue-service-core.ts\nimport { IJobRepository } from \"@/core/application/ports/job-repository.interface\";\nimport { AbstractQueue } from \"@/core/application/queue/abstract-queue\";\nimport { JobEntity, JobStatus } from \"@/core/domain/job/job.entity\";\nimport { JobIdVO } from \"@/core/domain/job/value-objects/job-id.vo\";\nimport { IJobOptions } from \"@/core/domain/job/value-objects/job-options.vo\"; // JobOptionsVO removed\n\n// Forward declaration for IQueueMaintenanceService to break circular dependency if needed for close()\ninterface IQueueMaintenanceService {\n  stopMaintenance(): Promise<void>;\n}\n\nexport class QueueServiceCore<P, R> extends AbstractQueue<P, R> {\n  // Maintenance service can be optional or injected if close needs to call it\n  private maintenanceService?: IQueueMaintenanceService;\n\n  constructor(\n    queueName: string,\n    jobRepository: IJobRepository,\n    defaultJobOptions?: IJobOptions,\n    maintenanceService?: IQueueMaintenanceService\n  ) {\n    super(queueName, jobRepository, defaultJobOptions);\n    this.maintenanceService = maintenanceService;\n  }\n\n  public setMaintenanceService(service: IQueueMaintenanceService): void {\n    this.maintenanceService = service;\n  }\n\n  async add(\n    jobName: string,\n    data: P,\n    opts?: IJobOptions\n  ): Promise<JobEntity<P, R>> {\n    const job = JobEntity.create<P, R>({\n      queueName: this.queueName,\n      name: jobName,\n      payload: data,\n      options: { ...this.defaultJobOptions.toPersistence(), ...opts },\n    });\n    await this.jobRepository.save(job);\n    this.emit(\"job.added\", job);\n    return job;\n  }\n\n  async addBulk(\n    jobs: Array<{ name: string; data: P; opts?: IJobOptions }>\n  ): Promise<Array<JobEntity<P, R>>> {\n    const jobEntities = jobs.map((jobDef) =>\n      JobEntity.create<P, R>({\n        queueName: this.queueName,\n        name: jobDef.name,\n        payload: jobDef.data,\n        options: { ...this.defaultJobOptions.toPersistence(), ...jobDef.opts },\n      })\n    );\n    for (const job of jobEntities) {\n      await this.jobRepository.save(job);\n      this.emit(\"job.added\", job);\n    }\n    return jobEntities;\n  }\n\n  async getJob(jobId: string | JobIdVO): Promise<JobEntity<P, R> | null> {\n    const id = jobId instanceof JobIdVO ? jobId : JobIdVO.create(jobId);\n    return (await this.jobRepository.findById(id)) as JobEntity<P, R> | null;\n  }\n\n  async getJobsByStatus(\n    statuses: JobStatus[],\n    start?: number,\n    end?: number,\n    asc?: boolean\n  ): Promise<Array<JobEntity<P, R>>> {\n    return (await this.jobRepository.getJobsByStatus(\n      this.queueName,\n      statuses,\n      start,\n      end,\n      asc\n    )) as Array<JobEntity<P, R>>;\n  }\n\n  async countJobsByStatus(\n    statuses?: JobStatus[]\n  ): Promise<Partial<Record<JobStatus, number>>> {\n    return await this.jobRepository.countJobsByStatus(this.queueName, statuses);\n  }\n\n  async pause(): Promise<void> {\n    this.emit(\"queue.paused\");\n    // Actual pause logic might involve signaling workers or preventing job fetching\n  }\n\n  async resume(): Promise<void> {\n    this.emit(\"queue.resumed\");\n    // Actual resume logic\n  }\n\n  async clean(\n    gracePeriodMs: number,\n    limit: number,\n    status?: JobStatus\n  ): Promise<number> {\n    return await this.jobRepository.clean(\n      this.queueName,\n      gracePeriodMs,\n      limit,\n      status\n    );\n  }\n\n  public async close(): Promise<void> {\n    if (this.maintenanceService) {\n      await this.maintenanceService.stopMaintenance();\n    }\n    this.emit(\"queue.closed\");\n    // Add any other core cleanup logic here (e.g., database connections if managed directly)\n  }\n\n  // Methods from AbstractQueue that will be implemented by other services\n  // These will need to be handled, possibly by changing AbstractQueue or by composition.\n  // For now, to make QueueServiceCore a valid extension of AbstractQueue (if it were complete),\n  // these would need to be abstract or throw errors.\n  // However, the goal is that QueueServiceCore *won't* be the sole implementer of AbstractQueue.\n\n  // These parameters will be flagged as unused by ESLint. This is acceptable for these stubs.\n  async fetchNextJobAndLock(workerId: string, lockDurationMs: number): Promise<JobEntity<P, R> | null> {\n    throw new Error(\"Method not implemented in QueueServiceCore. See JobProcessingService.\");\n  }\n  async extendJobLock(jobId: string | JobIdVO, workerId: string, lockDurationMs: number): Promise<void> {\n    throw new Error(\"Method not implemented in QueueServiceCore. See JobProcessingService.\");\n  }\n  async markJobAsCompleted(jobId: string | JobIdVO, workerId: string, result: R, jobInstanceWithChanges: JobEntity<P,R>): Promise<void> {\n    throw new Error(\"Method not implemented in QueueServiceCore. See JobProcessingService.\");\n  }\n  async markJobAsFailed(jobId: string | JobIdVO, workerId: string, error: Error, jobInstanceWithChanges: JobEntity<P,R>): Promise<void> {\n    throw new Error(\"Method not implemented in QueueServiceCore. See JobProcessingService.\");\n  }\n  async updateJobProgress(jobId: string | JobIdVO, workerId: string, progress: number | object): Promise<void> {\n    throw new Error(\"Method not implemented in QueueServiceCore. See JobProcessingService.\");\n  }\n  async addJobLog(jobId: string | JobIdVO, workerId: string, message: string, level?: string): Promise<void> {\n    throw new Error(\"Method not implemented in QueueServiceCore. See JobProcessingService.\");\n  }\n  startMaintenance(): void {\n    throw new Error(\"Method not implemented in QueueServiceCore. See QueueMaintenanceService.\");\n  }\n  async stopMaintenance(): Promise<void> {\n    throw new Error(\"Method not implemented in QueueServiceCore. See QueueMaintenanceService.\");\n  }\n}\n","usedDeprecatedRules":[]}]
