import { Identity } from "@/core/common/identity";
import { v4 as uuidv4 } from 'uuid'; // Import UUID generator
import { z } from 'zod'; // For potential specific validation if needed
import { DomainError } from "@/core/common/errors";

// The base Identity class already validates for UUID if it's a string.
const agentIdSchema = z.string().uuid({ message: "AgentId must be a valid UUID if provided." });

export class AgentId extends Identity<string> {
  private constructor(value: string) {
    // The `super(value)` call will use Identity's constructor,
    // which should already perform z.string().uuid() validation.
    super(value);
  }

  public static create(id?: string): AgentId {
    const newId = id || uuidv4();
    try {
      // Although super(newId) will validate, parsing here allows for specific errors
      // or if AgentId had rules stricter than general Identity<string>.
      // For now, Identity's validation for UUID is sufficient if id is provided.
      // If id is generated by uuidv4, it's already a valid UUID.
      // agentIdSchema.parse(newId); // Optional: if specific error needed for provided invalid id
      return new AgentId(newId);
    } catch (error) {
      if (error instanceof z.ZodError) {
        throw new DomainError(`Invalid AgentId format: ${error.errors.map(e => e.message).join(', ')}`);
      }
      if (error instanceof DomainError) { // Catch errors from Identity constructor
          throw new DomainError(`Cannot create AgentId: ${error.message}`);
      }
      throw error;
    }
  }

  // Equals method is inherited from Identity and should work correctly.
}
