// src_refactored/core/application/use-cases/job/create-job.use-case.ts
import { ZodError } from 'zod';
import { Executable } from '../../../common/executable';
import {
  CreateJobUseCaseInput,
  CreateJobUseCaseInputSchema,
  CreateJobUseCaseOutput,
} from './create-job.schema';
import { IJobRepository } from '../../../../domain/job/ports/job-repository.interface';
import { IJobQueue } from '../../../../core/ports/adapters/job-queue.interface';
import { Job } from '../../../../domain/job/job.entity';
import { JobId } from '../../../../domain/job/value-objects/job-id.vo';
import { JobName } from '../../../../domain/job/value-objects/job-name.vo';
import { TargetAgentRole } from '../../../../domain/job/value-objects/target-agent-role.vo';
import { JobPriority } from '../../../../domain/job/value-objects/job-priority.vo';
import { JobStatusType } from '../../../../domain/job/value-objects/job-status.vo';
import { JobTimestamp } from '../../../../domain/job/value-objects/job-timestamp.vo';
import { JobDependsOn } from '../../../../domain/job/value-objects/job-depends-on.vo';
import {
  RetryPolicy,
  NoRetryPolicy,
  BackoffType,
  RetryDelay // Only for type, creation via RetryPolicy.create
} from '../../../../domain/job/value-objects/retry-policy.vo';
import { MaxAttempts } from '../../../../domain/job/value-objects/attempt-count.vo';
// ActivityContext is initialized by Job.create internally within job.data.agentState
import { Result, ok, error } from '../../../../../shared/result';
import { DomainError, ValueError } from '../../../../common/errors';

export class CreateJobUseCase
  implements
    Executable<
      CreateJobUseCaseInput,
      CreateJobUseCaseOutput, // Temporarily, this might change for part 1
      DomainError | ZodError | ValueError
    >
{
  private jobRepository: IJobRepository;
  private jobQueue: IJobQueue;

  constructor(
    jobRepository: IJobRepository,
    jobQueue: IJobQueue,
  ) {
    this.jobRepository = jobRepository;
    this.jobQueue = jobQueue;
  }

  async execute(
    input: CreateJobUseCaseInput,
  ): Promise<Result<CreateJobUseCaseOutput, DomainError | ZodError | ValueError>> {
    // 1. Validate Input Schema
    const validationResult = CreateJobUseCaseInputSchema.safeParse(input);
    if (!validationResult.success) {
      return error(validationResult.error);
    }
    const validInput = validationResult.data;

    try {
      // 2. Create Value Objects
      const nameVo = JobName.create(validInput.name);
      const targetAgentRoleVo = validInput.targetAgentRole
        ? TargetAgentRole.create(validInput.targetAgentRole)
        : undefined; // Entity handles undefined targetAgentRole

      const priorityVo = validInput.priority !== undefined
        ? JobPriority.create(validInput.priority)
        : JobPriority.default();

      const dependsOnJobIdsVo = validInput.dependsOnJobIds
        ? JobDependsOn.create(validInput.dependsOnJobIds.map(id => JobId.fromString(id)))
        : JobDependsOn.create([]); // Default to empty if not provided

      let retryPolicyVo: RetryPolicy;
      if (!validInput.retryPolicy || validInput.retryPolicy.maxAttempts === undefined || validInput.retryPolicy.maxAttempts <= 1) {
        // Consider maxAttempts: 0 or 1 as NoRetryPolicy
        // MaxAttempts.create(0) might be an issue if it expects >=1.
        // NoRetryPolicy sets maxAttempts to 1 internally.
        retryPolicyVo = NoRetryPolicy.create();
      } else {
        const maxAttemptsVo = MaxAttempts.create(validInput.retryPolicy.maxAttempts);
        const initialDelayMs = (validInput.retryPolicy.initialDelaySeconds || 0) * 1000;
        const backoffType = validInput.retryPolicy.backoffType || BackoffType.FIXED; // Default if not specified
        const maxDelayMs = validInput.retryPolicy.maxDelaySeconds !== undefined
          ? validInput.retryPolicy.maxDelaySeconds * 1000
          : undefined;

        retryPolicyVo = RetryPolicy.create({
          maxAttempts: maxAttemptsVo,
          backoffType: backoffType,
          initialDelayMs: initialDelayMs,
          maxDelayMs: maxDelayMs,
        });
      }

      // JobId is generated by Job.create if not provided
      // Timestamps (createdAt, updatedAt) are handled by Job.create
      // Status is handled by Job.create (defaults to PENDING)
      // ActivityContext (within job.data.agentState) is initialized by Job.create

      // 3. Create Job Entity
      const jobEntity = Job.create({
        name: nameVo,
        payload: validInput.payload || {}, // Default to empty object if null/undefined
        targetAgentRole: targetAgentRoleVo,
        priority: priorityVo,
        dependsOn: dependsOnJobIdsVo,
        retryPolicy: retryPolicyVo,
        // maxAttempts can be passed if it's a direct prop of JobConstructionProps,
        // but it's also part of RetryPolicy. Job.create prefers it via RetryPolicy.
      });

      // For this sub-task (APP-JOB-001.2), we are only creating the entity.
      // Saving and enqueuing will be in APP-JOB-001.3.
      // We return the jobId for now to confirm creation.
      // ---- Start of APP-JOB-001.3 logic ----
      // 4. Save Job Entity
      const saveResult = await this.jobRepository.save(jobEntity);
      if (saveResult.isError()) {
        return error(new DomainError(`Failed to save job: ${saveResult.value.message}`, saveResult.value));
      }

      // 5. Add Job to Queue
      const enqueueResult = await this.jobQueue.add(jobEntity);
      if (enqueueResult.isError()) {
        // Consider compensating action: delete the saved job if enqueuing fails critically.
        // For now, just returning the error. The job exists but won't be processed.
        // This might require the job to have a status that reflects this state, or a cleanup mechanism.
        return error(new DomainError(`Failed to enqueue job after saving: ${enqueueResult.value.message}`, enqueueResult.value));
      }
      // ---- End of APP-JOB-001.3 logic ----

      return ok({ jobId: jobEntity.id().value() });

    } catch (err: any) {
      if (err instanceof ZodError) {
        return error(err);
      }
      if (err instanceof DomainError || err instanceof ValueError) {
        return error(err);
      }
      console.error('[CreateJobUseCase-Part1] Unexpected error:', err);
      return error(
        new DomainError(
          `An unexpected error occurred while preparing the job: ${err.message || err}`,
        ),
      );
    }
  }
}
