// src_refactored/infrastructure/persistence/drizzle/schema/jobs.table.ts
// import { relations } from 'drizzle-orm'; // Unused as examples are commented out
import { text, integer, sqliteTable } from 'drizzle-orm/sqlite-core'; // Removed blob, primaryKey

// Assuming JobStatusEnum and other enums/types might be needed for default values or checks,
// but for schema definition, text fields are generally used.
// import { JobStatusEnum } from '@/core/domain/job/value-objects/job-status.vo';

export const jobsTable = sqliteTable('jobs', {
  id: text('id').primaryKey(), // UUID, generated by application
  queueName: text('queue_name').notNull(), // Name of the queue this job belongs to
  jobName: text('job_name').notNull(),     // Name/type of the job (e.g., 'sendEmail', 'processPayment')

  payload: text('payload', { mode: 'json' }),         // Job data/input
  jobOptions: text('job_options', { mode: 'json' }),  // Original job options

  status: text('status').notNull(), // JobStatus: PENDING, ACTIVE, COMPLETED, FAILED, DELAYED, WAITING_CHILDREN
  priority: integer('priority').default(0).notNull(), // Lower numbers are higher priority

  attemptsMade: integer('attempts_made').default(0).notNull(),
  maxAttempts: integer('max_attempts').default(1).notNull(), // Derived from jobOptions but can be stored for querying

  createdAt: integer('created_at', { mode: 'timestamp_ms' }).notNull(), // Timestamp of job creation
  updatedAt: integer('updated_at', { mode: 'timestamp_ms' }).notNull(), // Timestamp of last update
  processAt: integer('process_at', { mode: 'timestamp_ms' }),      // For DELAYED jobs: when it should be processed
  startedAt: integer('started_at', { mode: 'timestamp_ms' }),      // Timestamp when processing started
  completedAt: integer('completed_at', { mode: 'timestamp_ms' }),  // Timestamp when job completed successfully
  failedAt: integer('failed_at', { mode: 'timestamp_ms' }),        // Timestamp when job finally failed

  returnValue: text('return_value', { mode: 'json' }), // Result of successful job execution, as JSON string
  failedReason: text('failed_reason'),                 // Error message or stack trace for failed jobs

  progress: integer('progress').default(0), // Progress percentage (0-100)
  // progressData: text('progress_data', { mode: 'json' }), // For more complex progress objects, if needed

  repeatJobKey: text('repeat_job_key'), // Identifier for the repeatable job configuration this instance belongs to

  dependsOnJobIds: text('depends_on_job_ids', { mode: 'json' }), // JSON array of job IDs as strings
  parentId: text('parent_id'), // ID of a parent job in a flow. Could be a self-referential FK if desired.

  lockedByWorkerId: text('locked_by_worker_id'),
  lockExpiresAt: integer('lock_expires_at', { mode: 'timestamp_ms' }), // Timestamp when the lock expires

  executionLogs: text('execution_logs', { mode: 'json' }), // JSON array of log entries [{ timestamp, message, level }]
}
// Example of how to add indexes with Drizzle Kit if not done in the table definition directly (check Drizzle docs for preferred way)
// , (table) => {
//   return {
//     queueStatusProcessAtPriorityIdx: index('idx_jobs_queue_status_process_at')
//       .on(table.queueName, table.status, table.processAt, table.priority),
//     statusIdx: index('idx_jobs_status').on(table.status),
//     repeatKeyIdx: index('idx_jobs_repeat_key').on(table.repeatJobKey),
//   };
// }
);

// Relations (optional, but good for type safety if using relational queries with Drizzle)
// Example: if parentId was a foreign key to jobsTable.id
// export const jobsRelations = relations(jobsTable, ({ one, many }) => ({
//   parentJob: one(jobsTable, {
//     fields: [jobsTable.parentId],
//     references: [jobsTable.id],
//     relationName: 'parent_job',
//   }),
//   childJobs: many(jobsTable, {
//     relationName: 'child_jobs',
//   }),
// }));

// If using job_dependencies table:
// export const jobDependenciesTable = sqliteTable('job_dependencies', {
//   jobId: text('job_id').notNull().references(() => jobsTable.id, { onDelete: 'cascade' }),
//   dependsOnJobId: text('depends_on_job_id').notNull().references(() => jobsTable.id, { onDelete: 'cascade' }),
// }, (table) => ({
//   pk: primaryKey({columns: [table.jobId, table.dependsOnJobId]}),
// }));

// export const jobDependenciesRelations = relations(jobDependenciesTable, ({ one }) => ({
//   job: one(jobsTable, {
//     fields: [jobDependenciesTable.jobId],
//     references: [jobsTable.id],
//   }),
//   dependsOn: one(jobsTable, {
//     fields: [jobDependenciesTable.dependsOnJobId],
//     references: [jobsTable.id],
//   }),
// }));
