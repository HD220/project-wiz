# Princípios Operacionais e de Design (Memória do Agente Gemini)

Este documento consolida os princípios de alto nível que guiam as ações do agente Gemini, independentemente do projeto em que está trabalhando.

## Meta-Diretriz de Aprendizagem Contínua

*   **Diretriz de Processo Crítico (Não-Negociável):** O ciclo de aprendizado (`ação -> reflexão -> registro de memória`) é a etapa de maior prioridade após qualquer ação. É mandatório e incondicional que a ferramenta `save_memory` seja usada para registrar o aprendizado generalizado *antes* de iniciar qualquer nova ação subsequente (seja ler um arquivo, executar um comando ou escrever código). A falha em seguir este ciclo representa uma falha operacional crítica e deve ser evitada a todo custo.

## Princípios de Boas Práticas de Programação (Independentes de Projeto)

*   **DRY (Don't Repeat Yourself):** Evitar a duplicação de código. Abstrair lógica comum em funções, classes ou módulos reutilizáveis para melhorar a manutenibilidade.
*   **KISS (Keep It Simple, Stupid):** Manter as soluções o mais simples possível, evitando complexidade desnecessária. Código simples é mais fácil de entender, testar e manter.
*   **YAGNI (You Aren't Gonna Need It):** Implementar apenas o que é estritamente necessário com base nos requisitos atuais. Evitar adicionar funcionalidades ou abstrações especulativas.
*   **Nomenclatura Descritiva:** Usar nomes claros, inequívocos e em inglês para variáveis, funções, classes, arquivos e pastas. Os nomes devem revelar a intenção e o propósito.
*   **Fail Fast (Falhar Rápido):** Detectar e reportar erros ou condições inválidas o mais cedo possível no ciclo de vida de uma operação para prevenir a propagação de estados inválidos.
*   **Single Responsibility Principle (SRP):** Uma classe ou módulo deve ter apenas uma única razão para mudar, ou seja, uma única responsabilidade. Isso torna as classes mais focadas, coesas e fáceis de manter.

## Princípios de Atuação e Depuração do Agente

*   **Princípio de Atuação (Configurações de Projeto):** Antes de alterar configurações de um projeto (ex: tipo de módulo, flags de compilador), é mandatório verificar a documentação e as práticas recomendadas dos frameworks e tecnologias principais (ex: Node.js, Electron, React). Isso previne a introdução de incompatibilidades que podem quebrar o build ou o runtime da aplicação.
*   **Princípio de Ferramentas (Substituição de Texto):** Ao usar ferramentas para substituição de texto em código-fonte, a string de busca (`old_string`) deve ser única e precisa. Para garantir a precisão, é uma prática robusta fornecer um bloco de contexto amplo (múltiplas linhas, com indentação exata) ao redor do texto a ser alterado, minimizando o risco de substituições incorretas ou ambíguas.
*   **Princípio de Ferramentas (Substituição de Múltiplas Ocorrências):** Ao usar ferramentas de substituição de texto, se a intenção é substituir múltiplas ocorrências de uma `old_string`, é mandatório especificar o parâmetro `expected_replacements` com o número exato de ocorrências. Caso contrário, a ferramenta pode falhar ou substituir apenas a primeira ocorrência.
*   **Princípio de Eficiência Operacional (Domínio de Ferramentas):** Para atuar de forma eficiente e evitar erros operacionais, um agente deve ter um domínio profundo das ferramentas disponíveis. Isso inclui conhecer seus parâmetros, comportamentos padrão e como utilizá-las para cenários específicos.
*   **Princípio de Design (Consistência de API):** Não se deve assumir que componentes ou classes com propósitos semelhantes (ex: Value Objects, Repositórios) possuem uma API idêntica. É obrigatório verificar a definição de cada abstração para usar seus métodos corretamente (ex: `create`, `fromString`, `generate`), evitando erros de tempo de compilação e de lógica.
*   **Princípio de Design (Criação de Entidades):** Para modelar entidades de forma robusta, separe as propriedades necessárias para sua *criação* daquelas que representam seu *estado* completo. Crie um tipo específico para a criação (ex: `EntityCreationProps`) que omita campos gerenciados internamente (como `id`, `createdAt`). O método de fábrica (`create`) da entidade deve receber esse tipo e ser o único responsável por gerar a identidade e os timestamps, garantindo encapsulamento e consistência.
*   **Princípio de Depuração de Tipos (Incompatibilidade de Propriedade):** Ao encontrar um erro de tipo indicando que uma propriedade de objeto está ausente ou incorreta, a primeira etapa de diagnóstico é sempre comparar a estrutura do objeto sendo criado no código com sua definição de tipo explícita (interface, type, schema). A sincronia entre a implementação do objeto e seu contrato de tipo deve ser rigorosamente mantida.
*   **Princípio de Codificação Defensiva (Tratamento de Nulos/Indefinidos):** Ao encontrar um erro do compilador sobre um objeto possivelmente nulo ou indefinido (ex: TS2532), é mandatório tratar essa possibilidade explicitamente. As estratégias incluem: 1) Fornecer um valor padrão com o operador `??`. 2) Interromper o fluxo com uma verificação de existência (guard clause). 3) Usar encadeamento opcional (`?.`) para acesso seguro. A escolha depende da lógica de negócios requerida.
*   **Princípio de Nomenclatura (Consistência):** Manter a consistência na nomenclatura de propriedades e métodos em todo o codebase é crucial para a manutenibilidade e para evitar erros de tipo. Utilize as sugestões do compilador (`Did you mean...`) como um alerta para corrigir essas inconsistências.
*   **Princípio de Refatoração de Tipos (Genéricos com Restrições):** Ao trabalhar com tipos genéricos em TypeScript, refatore-os para incluir restrições (`extends`) sempre que o código interno depender de propriedades ou métodos específicos do tipo genérico. Isso aprimora a segurança de tipo, permite verificações mais rigorosas pelo compilador e reduz a probabilidade de erros em tempo de execução.
*   **Princípio de Integridade de Dados (Mapeamento Explícito):** Em arquiteturas multicamadas, onde os dados podem ter representações diferentes (entidades, DTOs, modelos de persistência), o mapeamento entre essas representações deve ser explícito e preciso. Garanta que cada propriedade em uma camada seja corretamente mapeada para sua contraparte na outra, mesmo que os nomes sejam diferentes.
*   **Princípio de Propagação de Restrições de Tipos Genéricos:** Ao usar tipos genéricos com restrições (`extends`), é crucial propagar essas restrições consistentemente por toda a cadeia de uso do tipo. Isso inclui a declaração da classe, métodos estáticos, construtores e quaisquer outras funções que manipulem instâncias desse tipo genérico.
*   **Princípio de Compatibilidade de Tipos Genéricos (Concretização):** Ao usar tipos genéricos com restrições, os tipos concretos que são passados para preencher esses genéricos devem satisfazer integralmente as restrições definidas.
*   **Princípio de Uso de Asserções de Tipo:** Asserções de tipo (`as Type`) devem ser usadas com parcimônia e apenas quando o desenvolvedor tem certeza absoluta da compatibilidade de tipos. Elas não corrigem a causa raiz da incompatibilidade e devem ser tratadas como débito técnico.
*   **Princípio de Robustez de Tipos (Nullability e Undefined):** Ao modelar dados, sempre considere se uma propriedade pode ser `null` ou `undefined`. Tipar essas propriedades de forma explícita garante que o compilador enforce o tratamento adequado desses estados.
*   **Princípio de Análise de Erros de Tipo (Mapeamento):** Ao depurar erros de tipo em mapeamentos de dados, é fundamental analisar cuidadosamente tanto o tipo de origem quanto o tipo de destino. Mensagens de erro como 'Did you mean...' podem ser úteis, mas não devem substituir uma compreensão completa das propriedades e seus significados em ambos os tipos.
*   **Princípio de Refatoração Abrangente (Nomes de Propriedades):** Ao refatorar nomes de propriedades em definições de tipo, é imperativo realizar uma busca abrangente por todas as ocorrências desse nome no codebase. A correção deve ser aplicada consistentemente em todos os locais onde a propriedade é declarada, lida ou escrita.
*   **Princípio Operacional Fundamental (Adesão ao Processo):** A confiabilidade de um agente autônomo é diretamente proporcional à sua disciplina em seguir seus protocolos operacionais. A omissão de qualquer etapa de um processo definido (especialmente verificação e aprendizado) em favor da velocidade ou de um atalho é uma falha crítica que compromete a qualidade e a segurança. O processo deve ser seguido de forma sequential e completa, sempre.
*   **Princípio de Integridade de Código (Proibição de Placeholders em Modificações):** É uma regra ABSOLUTA e INQUEBRÁVEL: NUNCA usar comentários como placeholders (ex: `// ...`) em argumentos `new_string` de ferramentas de modificação de código (`replace`, `write_file`). O `new_string` deve ser sempre o código COMPLETO, CORRETO, SINTATICAMENTE VÁLIDO e SEM COMENTÁRIOS DESNECESSÁRIOS que substituirá o `old_string`. A falha nesta regra compromete a integridade do código e é uma falha operacional crítica.