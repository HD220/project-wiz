[{"filePath":"/app/src_refactored/infrastructure/queue/drizzle/__tests__/queue.service.extendJobLock.spec.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'JobEntity' is defined but never used. Allowed unused vars must match /^_/u.","line":12,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src_refactored/infrastructure/queue/drizzle/__tests__/queue.service.extendJobLock.spec.ts\nimport {\n  vi,\n  describe,\n  it,\n  expect,\n  beforeEach,\n  beforeAll,\n  afterEach,\n} from \"vitest\";\n\nimport { JobEntity } from \"../../../../core/domain/job/job.entity\"; // JobStatus removed\nimport { JobIdVO } from \"../../../../core/domain/job/value-objects/job-id.vo\";\nimport { type IJobOptions } from \"../../../../core/domain/job/value-objects/job-options.vo\";\nimport { DrizzleJobRepository } from \"../../../persistence/drizzle/job/drizzle-job.repository\";\nimport { QueueService } from \"../queue.service\";\n\nimport {\n  TestDb,\n  createTestDbClient,\n  runMigrations,\n  clearDatabaseTables,\n} from \"./test-db.helper\";\n\n// Top-level variables for test context\nlet db: TestDb;\nlet jobRepository: DrizzleJobRepository;\nlet queueService: QueueService<{ email: string }, { status: string }>;\nconst queueName = \"test-email-queue\";\nconst defaultJobOpts: IJobOptions = {\n  attempts: 1,\n  delay: 0,\n  priority: 0,\n  removeOnComplete: false,\n  removeOnFail: false,\n  maxStalledCount: 3,\n};\n\nbeforeAll(async () => {\n  db = createTestDbClient({ memory: true });\n  await runMigrations(db);\n});\n\nbeforeEach(async () => {\n  vi.clearAllMocks();\n  await clearDatabaseTables(db);\n\n  jobRepository = new DrizzleJobRepository(db);\n  queueService = new QueueService(queueName, jobRepository, defaultJobOpts);\n  vi.spyOn(queueService, \"emit\");\n});\n\nafterEach(async () => {\n  if (queueService) {\n    await queueService.close();\n  }\n  vi.restoreAllMocks();\n});\n\ndescribe(\"QueueService - extendJobLock\", () => {\n  let jobId: JobIdVO;\n  const workerId = \"worker-extend\";\n  const lockDurationMs = 15000;\n\n  beforeEach(async () => { // This beforeEach is specific to this describe block\n    jobId = JobIdVO.create();\n    const jobOptions: IJobOptions = { jobId: jobId.value };\n    await queueService.add(\n      \"extend-me\",\n      { email: \"extend@example.com\" },\n      jobOptions\n    );\n    const activeJob = await queueService.fetchNextJobAndLock(workerId, 10000);\n    expect(activeJob).not.toBeNull();\n    expect(activeJob!.getProps().id.value).toBe(jobId.value);\n  });\n\n  it(\"should extend lock for an active job owned by the worker\", async () => {\n    const jobBeforeExtend = await jobRepository.findById(jobId);\n    expect(jobBeforeExtend).not.toBeNull();\n    const originalLockUntil = jobBeforeExtend!.getProps().lockUntil;\n\n    await queueService.extendJobLock(jobId, workerId, lockDurationMs);\n\n    const jobAfterExtend = await jobRepository.findById(jobId);\n    expect(jobAfterExtend).not.toBeNull();\n    const jobAfterExtendProps = jobAfterExtend!.getProps();\n    expect(jobAfterExtendProps.lockUntil!.getTime()).toBeGreaterThan(\n      originalLockUntil!.getTime()\n    );\n    expect(jobAfterExtendProps.lockUntil!.getTime()).toBeGreaterThanOrEqual(\n      Date.now() + lockDurationMs - 2000\n    );\n    expect(queueService.emit).toHaveBeenCalledWith(\n      \"job.lock.extended\",\n      expect.objectContaining({ id: jobId }) \n    );\n  });\n\n  it(\"should accept string job ID for extendJobLock\", async () => {\n    await queueService.extendJobLock(jobId.value, workerId, lockDurationMs);\n    const jobAfterExtend = await jobRepository.findById(jobId);\n    expect(jobAfterExtend).not.toBeNull();\n    expect(jobAfterExtend!.getProps().lockUntil!.getTime()).toBeGreaterThanOrEqual(\n      Date.now() + lockDurationMs - 2000\n    );\n  });\n\n  it(\"should not extend lock if job not found\", async () => {\n    const nonExistentJobId = JobIdVO.create();\n    await queueService.extendJobLock(\n      nonExistentJobId,\n      workerId,\n      lockDurationMs\n    );\n    expect(queueService.emit).not.toHaveBeenCalledWith(\n      \"job.lock.extended\",\n      expect.anything()\n    );\n  });\n\n  it(\"should not extend lock if workerId does not match\", async () => {\n    const jobBeforeExtend = await jobRepository.findById(jobId);\n    expect(jobBeforeExtend).not.toBeNull(); \n    const originalLockTime = jobBeforeExtend!.getProps().lockUntil!.getTime();\n\n    await queueService.extendJobLock(jobId, \"other-worker\", lockDurationMs);\n    const jobAfterExtend = await jobRepository.findById(jobId);\n    expect(jobAfterExtend!.getProps().lockUntil!.getTime()).toEqual(originalLockTime);\n  });\n\n  it(\"should not extend lock if job is not active\", async () => {\n    await queueService.markJobAsCompleted(jobId, workerId, {\n      status: \"done\",\n    });\n    const jobCompleted = await jobRepository.findById(jobId);\n    expect(jobCompleted).not.toBeNull();\n    const lockTimeBefore = jobCompleted!.getProps().lockUntil;\n\n    await queueService.extendJobLock(jobId, workerId, lockDurationMs);\n    const jobAfterAttemptedExtend = await jobRepository.findById(jobId);\n    expect(jobAfterAttemptedExtend).not.toBeNull();\n    if (lockTimeBefore) {\n      expect(jobAfterAttemptedExtend!.getProps().lockUntil!.getTime()).toEqual(\n        lockTimeBefore.getTime()\n      );\n    } else {\n      expect(jobAfterAttemptedExtend!.getProps().lockUntil).toBeNull();\n    }\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/queue/drizzle/__tests__/queue.service.fetchNextJobAndLock.spec.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'JobEntity' is defined but never used. Allowed unused vars must match /^_/u.","line":14,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src_refactored/infrastructure/queue/drizzle/__tests__/queue.service.fetchNextJobAndLock.spec.ts\n// import { randomUUID } from \"node:crypto\"; // Not needed in this specific file\n\nimport {\n  vi,\n  describe,\n  it,\n  expect,\n  beforeEach,\n  beforeAll,\n  // afterAll, // Removed as unused\n} from \"vitest\";\n\nimport { JobEntity, JobStatus } from \"../../../../core/domain/job/job.entity\";\n// import { JobIdVO } from \"../../../../core/domain/job/value-objects/job-id.vo\"; // Removed as unused\nimport { type IJobOptions } from \"../../../../core/domain/job/value-objects/job-options.vo\";\nimport { DrizzleJobRepository } from \"../../../persistence/drizzle/job/drizzle-job.repository\";\nimport { QueueService } from \"../queue.service\";\n\n// Newline for import group separation\nimport {\n  TestDb,\n  createTestDbClient,\n  runMigrations,\n  clearDatabaseTables,\n} from \"./test-db.helper\";\n\n// Top-level variables for test context\nlet db: TestDb;\nlet jobRepository: DrizzleJobRepository;\nlet queueService: QueueService<{ email: string }, { status: string }>;\nconst queueName = \"test-email-queue\";\nconst defaultJobOpts: IJobOptions = {\n  attempts: 1,\n  delay: 0,\n  priority: 0,\n  removeOnComplete: false,\n  removeOnFail: false,\n  maxStalledCount: 3,\n};\n\nbeforeAll(async () => {\n  db = createTestDbClient({ memory: true });\n  await runMigrations(db);\n});\n\nbeforeEach(async () => {\n  vi.clearAllMocks();\n  await clearDatabaseTables(db);\n\n  jobRepository = new DrizzleJobRepository(db);\n  queueService = new QueueService(queueName, jobRepository, defaultJobOpts);\n  vi.spyOn(queueService, \"emit\");\n});\n\nafterEach(async () => {\n  if (queueService) {\n    await queueService.close();\n  }\n  vi.restoreAllMocks();\n});\n\ndescribe(\"QueueService - fetchNextJobAndLock\", () => {\n  const workerId = \"worker-007\";\n  const lockDurationMs = 30000;\n\n  it(\"should return null if no jobs are available in DB\", async () => {\n    const job = await queueService.fetchNextJobAndLock(\n      workerId,\n      lockDurationMs\n    );\n    expect(job).toBeNull();\n  });\n\n  it(\"should return null if lock cannot be acquired (e.g. another worker got it)\", async () => {\n    await queueService.add(\"job1\", {\n      email: \"e1@example.com\",\n    });\n\n    const fetchedAndLockedJob = await queueService.fetchNextJobAndLock(\n      workerId,\n      lockDurationMs\n    );\n    expect(fetchedAndLockedJob).not.toBeNull();\n\n    const anotherAttempt = await queueService.fetchNextJobAndLock(\n      \"worker-008\",\n      lockDurationMs\n    );\n    expect(anotherAttempt).toBeNull();\n  });\n\n  it(\"should fetch, lock, update job to active in DB, and emit event\", async () => {\n    const addedJob = await queueService.add(\"job2\", {\n      email: \"e2@example.com\",\n    });\n\n    const fetchedJob = await queueService.fetchNextJobAndLock(\n      workerId,\n      lockDurationMs\n    );\n\n    expect(fetchedJob).not.toBeNull();\n    const fetchedJobProps = fetchedJob!.getProps();\n    const addedJobProps = addedJob.getProps();\n    expect(fetchedJobProps.id.value).toBe(addedJobProps.id.value);\n    expect(fetchedJobProps.status).toBe(JobStatus.ACTIVE);\n    expect(fetchedJobProps.workerId).toBe(workerId);\n    expect(fetchedJobProps.lockUntil).toBeInstanceOf(Date);\n    expect(fetchedJobProps.lockUntil!.getTime()).toBeGreaterThan(Date.now());\n    expect(fetchedJobProps.processedOn).toBeInstanceOf(Date);\n    expect(fetchedJobProps.attemptsMade).toBe(1);\n    expect(queueService.emit).toHaveBeenCalledWith(\"job.active\", fetchedJob);\n\n    const jobFromDb = await jobRepository.findById(addedJobProps.id);\n    expect(jobFromDb).not.toBeNull();\n    const jobFromDbProps = jobFromDb!.getProps();\n    expect(jobFromDbProps.status).toBe(JobStatus.ACTIVE);\n    expect(jobFromDbProps.workerId).toBe(workerId);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/queue/drizzle/__tests__/queue.service.markJobAsCompleted.spec.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'JobEntity' is defined but never used. Allowed unused vars must match /^_/u.","line":12,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src_refactored/infrastructure/queue/drizzle/__tests__/queue.service.markJobAsCompleted.spec.ts\nimport {\n  vi,\n  describe,\n  it,\n  expect,\n  beforeEach,\n  beforeAll,\n  afterEach,\n} from \"vitest\";\n\nimport { JobEntity, JobStatus } from \"../../../../core/domain/job/job.entity\";\nimport { JobIdVO } from \"../../../../core/domain/job/value-objects/job-id.vo\";\nimport { type IJobOptions } from \"../../../../core/domain/job/value-objects/job-options.vo\";\nimport { DrizzleJobRepository } from \"../../../persistence/drizzle/job/drizzle-job.repository\";\nimport { QueueService } from \"../queue.service\";\n\nimport {\n  TestDb,\n  createTestDbClient,\n  runMigrations,\n  clearDatabaseTables,\n} from \"./test-db.helper\";\n\n// Top-level variables for test context\nlet db: TestDb;\nlet jobRepository: DrizzleJobRepository;\nlet queueService: QueueService<{ email: string }, { status: string }>; // Payload type for add\nconst queueName = \"test-email-queue\";\nconst defaultJobOpts: IJobOptions = {\n  attempts: 1,\n  delay: 0,\n  priority: 0,\n  removeOnComplete: false,\n  removeOnFail: false,\n  maxStalledCount: 3,\n};\n\nbeforeAll(async () => {\n  db = createTestDbClient({ memory: true });\n  await runMigrations(db);\n});\n\nbeforeEach(async () => {\n  vi.clearAllMocks();\n  await clearDatabaseTables(db);\n\n  jobRepository = new DrizzleJobRepository(db);\n  // Provide payload type for QueueService instantiation\n  queueService = new QueueService<{ email: string }, { status: string }>(\n    queueName, \n    jobRepository, \n    defaultJobOpts\n  );\n  vi.spyOn(queueService, \"emit\");\n});\n\nafterEach(async () => {\n  if (queueService) {\n    await queueService.close();\n  }\n  vi.restoreAllMocks();\n});\n\ndescribe(\"QueueService - markJobAsCompleted\", () => {\n  let jobIdForCompleteTest: JobIdVO;\n  const workerIdForCompleteTest = \"worker-complete\";\n  const resultForCompleteTest = { status: \"Email Sent!\" };\n\n  beforeEach(async () => { // This beforeEach is specific to this describe block\n    jobIdForCompleteTest = JobIdVO.create();\n    await queueService.add(\n      \"complete-me\",\n      { email: \"c@ex.com\" }, // Payload matches QueueService type\n      { jobId: jobIdForCompleteTest.value }\n    );\n    const activeJob = await queueService.fetchNextJobAndLock(\n      workerIdForCompleteTest,\n      10000\n    );\n    if (!activeJob || activeJob.getProps().id.value !== jobIdForCompleteTest.value)\n      throw new Error(\"Setup failed for markJobAsCompleted\");\n  });\n\n  it(\"should mark job as completed, update DB, and emit event\", async () => {\n    const jobInstanceFromWorker =\n      await jobRepository.findById(jobIdForCompleteTest);\n    expect(jobInstanceFromWorker).not.toBeNull();\n    jobInstanceFromWorker!.addLog( \n      \"Log from worker before completion\",\n      \"INFO\"\n    );\n\n    await queueService.markJobAsCompleted(\n      jobIdForCompleteTest,\n      workerIdForCompleteTest,\n      resultForCompleteTest,\n      jobInstanceFromWorker! \n    );\n\n    const jobFromDb = await jobRepository.findById(jobIdForCompleteTest);\n    expect(jobFromDb).not.toBeNull();\n    const jobFromDbProps = jobFromDb!.getProps();\n    expect(jobFromDbProps.status).toBe(JobStatus.COMPLETED);\n    expect(jobFromDbProps.returnValue).toEqual(resultForCompleteTest);\n    expect(jobFromDbProps.finishedOn).toBeInstanceOf(Date);\n    expect(\n      jobFromDbProps.logs.some(\n        (log) => log.message === \"Log from worker before completion\"\n      )\n    ).toBe(false); \n\n    expect(queueService.emit).toHaveBeenCalledWith(\n      \"job.completed\",\n      expect.objectContaining({\n        id: jobIdForCompleteTest, \n        status: JobStatus.COMPLETED,\n      })\n    );\n  });\n\n  it(\"should accept string job ID for markJobAsCompleted\", async () => {\n    await queueService.markJobAsCompleted(\n      jobIdForCompleteTest.value,\n      workerIdForCompleteTest,\n      resultForCompleteTest\n    );\n    const jobFromDb = await jobRepository.findById(jobIdForCompleteTest);\n    expect(jobFromDb).not.toBeNull();\n    expect(jobFromDb!.getProps().status).toBe(JobStatus.COMPLETED);\n  });\n\n  it(\"should not complete if job not found in DB\", async () => {\n    const nonExistentJobId = JobIdVO.create();\n    await queueService.markJobAsCompleted(\n      nonExistentJobId,\n      workerIdForCompleteTest,\n      resultForCompleteTest\n    );\n    expect(queueService.emit).not.toHaveBeenCalledWith(\n      \"job.completed\",\n      expect.objectContaining({ id: nonExistentJobId })\n    );\n  });\n\n  it(\"should not complete if workerId does not match job in DB\", async () => {\n    await queueService.markJobAsCompleted(\n      jobIdForCompleteTest,\n      \"another-worker\",\n      resultForCompleteTest\n    );\n    const jobFromDb = await jobRepository.findById(jobIdForCompleteTest);\n    expect(jobFromDb).not.toBeNull();\n    expect(jobFromDb!.getProps().status).toBe(JobStatus.ACTIVE); \n    expect(queueService.emit).not.toHaveBeenCalledWith(\n      \"job.completed\",\n      expect.anything()\n    );\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/queue/drizzle/__tests__/queue.service.markJobAsFailed.spec.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'JobEntity' is defined but never used. Allowed unused vars must match /^_/u.","line":12,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src_refactored/infrastructure/queue/drizzle/__tests__/queue.service.markJobAsFailed.spec.ts\nimport {\n  vi,\n  describe,\n  it,\n  expect,\n  beforeEach,\n  beforeAll,\n  afterEach,\n} from \"vitest\";\n\nimport { JobEntity, JobStatus } from \"../../../../core/domain/job/job.entity\";\nimport { JobIdVO } from \"../../../../core/domain/job/value-objects/job-id.vo\";\nimport { type IJobOptions } from \"../../../../core/domain/job/value-objects/job-options.vo\";\nimport { DrizzleJobRepository } from \"../../../persistence/drizzle/job/drizzle-job.repository\";\nimport { QueueService } from \"../queue.service\";\n\nimport {\n  TestDb,\n  createTestDbClient,\n  runMigrations,\n  clearDatabaseTables,\n} from \"./test-db.helper\";\n\n// Top-level variables for test context\nlet db: TestDb;\nlet jobRepository: DrizzleJobRepository;\nlet queueService: QueueService<{ email: string }, { status: string }>; // Payload type for add\nconst queueName = \"test-email-queue\";\nconst defaultJobOpts: IJobOptions = {\n  attempts: 1,\n  delay: 0,\n  priority: 0,\n  removeOnComplete: false,\n  removeOnFail: false,\n  maxStalledCount: 3,\n};\n\nbeforeAll(async () => {\n  db = createTestDbClient({ memory: true });\n  await runMigrations(db);\n});\n\nbeforeEach(async () => {\n  vi.clearAllMocks();\n  await clearDatabaseTables(db);\n\n  jobRepository = new DrizzleJobRepository(db);\n  queueService = new QueueService<{ email: string }, { status: string }>(\n    queueName, \n    jobRepository, \n    defaultJobOpts\n  );\n  vi.spyOn(queueService, \"emit\");\n});\n\nafterEach(async () => {\n  if (queueService) {\n    await queueService.close();\n  }\n  vi.restoreAllMocks();\n});\n\ndescribe(\"QueueService - markJobAsFailed\", () => {\n  let jobToFailPermanentlyId: JobIdVO;\n  let jobToRetryId: JobIdVO;\n  const workerIdForFailTest = \"worker-fail\";\n  const errorForFailTest = new Error(\"Test Job Failed\");\n\n  beforeEach(async () => { // This beforeEach is specific to this describe block\n    jobToFailPermanentlyId = JobIdVO.create();\n    await queueService.add(\n      \"fail-me-permanently\",\n      { email: \"f-perm@ex.com\" },\n      { jobId: jobToFailPermanentlyId.value, attempts: 1 }\n    );\n    const activeJobPerm = await queueService.fetchNextJobAndLock(\n      workerIdForFailTest,\n      10000\n    );\n    if (\n      !activeJobPerm ||\n      activeJobPerm.getProps().id.value !== jobToFailPermanentlyId.value\n    )\n      throw new Error(\"Setup failed for jobToFailPermanently\");\n\n    jobToRetryId = JobIdVO.create();\n    await queueService.add(\n      \"fail-me-with-retries\",\n      { email: \"f-retry@ex.com\" },\n      {\n        jobId: jobToRetryId.value,\n        attempts: 3,\n        backoff: { type: \"exponential\", delay: 100 },\n      }\n    );\n    const activeJobRetry = await queueService.fetchNextJobAndLock(\n      workerIdForFailTest,\n      10000\n    );\n    if (!activeJobRetry || activeJobRetry.getProps().id.value !== jobToRetryId.value)\n      throw new Error(\"Setup failed for jobToRetry\");\n  });\n\n  it(\"should mark job as FAILED if attempts exhausted, update DB, and emit event\", async () => {\n    await queueService.markJobAsFailed(\n      jobToFailPermanentlyId,\n      workerIdForFailTest,\n      errorForFailTest\n    );\n\n    const jobFromDb = await jobRepository.findById(jobToFailPermanentlyId);\n    expect(jobFromDb).not.toBeNull();\n    const jobFromDbProps = jobFromDb!.getProps();\n    expect(jobFromDbProps.status).toBe(JobStatus.FAILED);\n    expect(jobFromDbProps.failedReason).toBe(errorForFailTest.message);\n    expect(jobFromDbProps.finishedOn).toBeInstanceOf(Date);\n    expect(queueService.emit).toHaveBeenCalledWith(\n      \"job.failed\",\n      expect.objectContaining({\n        id: jobToFailPermanentlyId, \n        status: JobStatus.FAILED,\n      })\n    );\n  });\n\n  it(\"should mark job as DELAYED if retries are pending, update DB, and emit event\", async () => {\n    await queueService.markJobAsFailed(\n      jobToRetryId,\n      workerIdForFailTest,\n      errorForFailTest\n    );\n\n    const jobFromDb = await jobRepository.findById(jobToRetryId);\n    expect(jobFromDb).not.toBeNull();\n    const jobFromDbProps = jobFromDb!.getProps();\n    expect(jobFromDbProps.status).toBe(JobStatus.DELAYED);\n    expect(jobFromDbProps.failedReason).toBe(errorForFailTest.message);\n    expect(jobFromDbProps.delayUntil).toBeInstanceOf(Date);\n    expect(jobFromDbProps.delayUntil!.getTime()).toBeGreaterThanOrEqual(\n      Date.now() + 90 \n    );\n    expect(jobFromDbProps.attemptsMade).toBe(1); \n    expect(queueService.emit).toHaveBeenCalledWith(\n      \"job.failed\",\n      expect.objectContaining({ id: jobToRetryId, status: JobStatus.DELAYED }) \n    );\n  });\n\n  it(\"should accept string job ID for markJobAsFailed\", async () => {\n    await queueService.markJobAsFailed(\n      jobToFailPermanentlyId.value,\n      workerIdForFailTest,\n      errorForFailTest\n    );\n    const jobFromDb = await jobRepository.findById(jobToFailPermanentlyId);\n    expect(jobFromDb).not.toBeNull();\n    expect(jobFromDb!.getProps().status).toBe(JobStatus.FAILED);\n  });\n});\n","usedDeprecatedRules":[]}]
