[{"filePath":"/app/src_refactored/core/application/worker/__tests__/worker.service.spec.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":42,"fix":{"range":[102,102],"text":"\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'randomUUID' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":20},{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":9,"column":1,"nodeType":"ImportDeclaration","endLine":9,"endColumn":78,"fix":{"range":[590,590],"text":"\n"}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":346,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":346,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16118,16121],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16118,16121],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import EventEmitter from 'events';\nimport { randomUUID } from 'node:crypto'; // Moved native import up\nimport { vi, describe, it, expect, beforeEach, Mock, afterEach } from 'vitest';\n\nimport { IJobRepository } from '@/core/application/ports/job-repository.interface'; // For MockQueue\nimport { AbstractQueue } from '@/core/application/queue/abstract-queue';\nimport { JobEntity, JobStatus } from '@/core/domain/job/job.entity';\nimport { JobIdVO } from '@/core/domain/job/value-objects/job-id.vo';\nimport { IJobOptions } from '@/core/domain/job/value-objects/job-options.vo'; // For MockQueue\n// ProcessorFunction was unused\nimport { WorkerService, WorkerOptions } from '../worker.service';\n\n// Mock AbstractQueue\nclass MockQueue<P, R> extends EventEmitter implements AbstractQueue<P, R> {\n  queueName: string;\n  jobRepository: Partial<IJobRepository>; // Use Partial if not all methods are needed/mocked\n  defaultJobOptions: Partial<IJobOptions>; // Use Partial\n\n  constructor(name: string) {\n    super();\n    this.queueName = name;\n    this.jobRepository = {}; // Initialize with empty object or specific mocks if needed\n    this.defaultJobOptions = {};\n  }\n\n  add = vi.fn() as Mock<[string, P, IJobOptions?], Promise<JobEntity<P, R>>>;\n  addBulk = vi.fn() as Mock<[Array<{ name: string; data: P; opts?: IJobOptions; }>], Promise<Array<JobEntity<P, R>>>>;\n  getJob = vi.fn() as Mock<[string | JobIdVO], Promise<JobEntity<P, R> | null>>;\n  getJobsByStatus = vi.fn() as Mock<[JobStatus[], number?, number?, boolean?], Promise<Array<JobEntity<P, R>>>>;\n  countJobsByStatus = vi.fn() as Mock<[JobStatus[]?], Promise<Partial<Record<JobStatus, number>>>>;\n  pause = vi.fn() as Mock<[], Promise<void>>;\n  resume = vi.fn() as Mock<[], Promise<void>>;\n  clean = vi.fn() as Mock<[number, number, JobStatus?], Promise<number>>;\n  close = vi.fn() as Mock<[], Promise<void>>;\n\n  fetchNextJobAndLock = vi.fn() as Mock<[string, number], Promise<JobEntity<P, R> | null>>;\n  extendJobLock = vi.fn() as Mock<[string | JobIdVO, string, number], Promise<void>>;\n  markJobAsCompleted = vi.fn() as Mock<[string | JobIdVO, string, R, JobEntity<P,R>], Promise<void>>;\n  markJobAsFailed = vi.fn() as Mock<[string | JobIdVO, string, Error, JobEntity<P,R>], Promise<void>>;\n  updateJobProgress = vi.fn() as Mock<[string | JobIdVO, string, number | object], Promise<void>>;\n  addJobLog = vi.fn() as Mock<[string | JobIdVO, string, string, string?], Promise<void>>;\n  startMaintenance = vi.fn() as Mock<[], void>;\n}\n\ntype TestPayload = { data: string };\ntype TestResult = { status: string };\n\ndescribe('WorkerService', () => {\n  let workerService: WorkerService<TestPayload, TestResult>;\n  let mockQueue: MockQueue<TestPayload, TestResult>;\n  let mockProcessor: Mock<[JobEntity<TestPayload, TestResult>], Promise<TestResult>>;\n\n  const workerOptions: WorkerOptions = {\n    concurrency: 1,\n    lockDuration: 10000, // 10s\n    lockRenewTimeBuffer: 2000, // Renew 2s before lock expires\n  };\n\n  beforeEach(() => {\n    vi.useFakeTimers();\n    mockQueue = new MockQueue('test-queue');\n    mockProcessor = vi.fn();\n    workerService = new WorkerService(mockQueue, mockProcessor, workerOptions);\n    vi.spyOn(workerService, 'emit');\n  });\n\n  afterEach(async () => {\n    await workerService.close(); // Ensure worker is closed and timers are cleared\n    vi.clearAllMocks();\n    vi.restoreAllMocks();\n    vi.useRealTimers();\n  });\n\nimport { randomUUID } from 'node:crypto';\n\n// ... (other imports)\n\n  const createMockJob = (idSuffix: string, payload: TestPayload, status = JobStatus.WAITING): JobEntity<TestPayload, TestResult> => {\n    // Use a passed suffix for easier debugging if needed, but generate a valid UUID for the ID itself.\n    // Or, just use randomUUID directly if the suffix isn't strictly for ID.\n    // For this case, let's make the ID a valid UUID. The suffix can be for logging/tracking in tests.\n    const job = JobEntity.create<TestPayload, TestResult>({\n      id: JobIdVO.create(randomUUID()), // Generate valid UUID\n      queueName: mockQueue.queueName,\n      name: `test-job-${idSuffix}`, // Keep suffix in name for easier test identification\n      payload,\n    });\n    job.status = status; // manually set for testing different scenarios\n    if (status === JobStatus.ACTIVE) {\n        job.moveToActive(`worker-${idSuffix}`, new Date(Date.now() + workerOptions.lockDuration));\n    }\n    return job;\n  };\n\n  it('should create a worker instance', () => {\n    expect(workerService).toBeInstanceOf(WorkerService);\n    expect(workerService.isClosed).toBe(false);\n    expect(workerService.isRunning).toBe(false);\n  });\n\n  describe('run and job processing', () => {\n    it('should fetch and process a job successfully', async () => {\n      const job = createMockJob('success', { data: 'process me' });\n      const expectedResult = { status: 'processed' };\n\n      mockQueue.fetchNextJobAndLock.mockResolvedValueOnce(job);\n      mockProcessor.mockResolvedValueOnce(expectedResult);\n\n      workerService.run();\n      await vi.advanceTimersByTimeAsync(100); // Allow polling and processing\n\n      expect(mockQueue.fetchNextJobAndLock).toHaveBeenCalledWith(workerService.workerId, workerOptions.lockDuration);\n      expect(mockProcessor).toHaveBeenCalledWith(job);\n      expect(mockQueue.markJobAsCompleted).toHaveBeenCalledWith(job.id, workerService.workerId, expectedResult, job);\n      expect(workerService.emit).toHaveBeenCalledWith('worker.job.active', job);\n      expect(workerService.emit).toHaveBeenCalledWith('worker.job.processed', job, expectedResult);\n      expect(workerService.isRunning).toBe(true);\n    });\n\n    it('should handle job processing failure', async () => {\n      const job = createMockJob('fail', { data: 'fail me' });\n      const error = new Error('Processing failed');\n\n      mockQueue.fetchNextJobAndLock.mockResolvedValueOnce(job);\n      mockProcessor.mockRejectedValueOnce(error);\n\n      workerService.run();\n      await vi.advanceTimersByTimeAsync(100);\n\n      expect(mockProcessor).toHaveBeenCalledWith(job);\n      expect(mockQueue.markJobAsFailed).toHaveBeenCalledWith(job.id, workerService.workerId, error, job);\n      expect(workerService.emit).toHaveBeenCalledWith('worker.job.active', job);\n      expect(workerService.emit).toHaveBeenCalledWith('worker.job.errored', job, error);\n    });\n\n    it('should not fetch new jobs if concurrency limit is reached', async () => {\n      const job1 = createMockJob('c1', { data: 'c_data1' });\n      // Simulate job1 is being processed and takes time\n      mockQueue.fetchNextJobAndLock.mockResolvedValueOnce(job1);\n      mockProcessor.mockImplementationOnce(() => new Promise(resolve => setTimeout(() => resolve({status: 'done_c1'}), 5000)));\n\n      workerService.run(); // Starts processing job1\n      await vi.advanceTimersByTimeAsync(100); // job1 picked up\n\n      expect(mockQueue.fetchNextJobAndLock).toHaveBeenCalledTimes(1);\n      expect(workerService.activeJobCount).toBe(1);\n\n      // Try to advance time, but since concurrency is 1, no new job should be fetched yet\n      await vi.advanceTimersByTimeAsync(1000);\n      expect(mockQueue.fetchNextJobAndLock).toHaveBeenCalledTimes(1); // Still 1, as job1 is active\n\n      await vi.advanceTimersByTimeAsync(5000); // job1 finishes\n      await vi.advanceTimersByTimeAsync(100); // Polling for next\n\n      expect(mockQueue.markJobAsCompleted).toHaveBeenCalledWith(job1.id, workerService.workerId, {status: 'done_c1'}, job1);\n      expect(workerService.activeJobCount).toBe(0);\n      // Now it should poll again\n      expect(mockQueue.fetchNextJobAndLock).toHaveBeenCalledTimes(2);\n    });\n\n    it('should respect concurrency > 1', async () => {\n      workerService.close(); // close default worker\n      const multiConcurrencyOptions = { ...workerOptions, concurrency: 2 };\n      workerService = new WorkerService(mockQueue, mockProcessor, multiConcurrencyOptions);\n      vi.spyOn(workerService, 'emit');\n\n\n      const job1 = createMockJob('mc1', { data: 'mc_data1' });\n      const job2 = createMockJob('mc2', { data: 'mc_data2' });\n\n      mockQueue.fetchNextJobAndLock\n        .mockResolvedValueOnce(job1)\n        .mockResolvedValueOnce(job2)\n        .mockResolvedValue(null); // No more jobs after these two\n\n      mockProcessor.mockImplementation(async (job) => {\n        await new Promise(resolve => setTimeout(resolve, 1000)); // Simulate work\n        return { status: `done_${job.id.value}` };\n      });\n\n      workerService.run();\n      await vi.advanceTimersByTimeAsync(100); // Poll and pick up job1 & job2\n\n      expect(mockQueue.fetchNextJobAndLock).toHaveBeenCalledTimes(2); // Fetched two jobs due to concurrency\n      expect(workerService.activeJobCount).toBe(2);\n      expect(mockProcessor).toHaveBeenCalledWith(job1);\n      expect(mockProcessor).toHaveBeenCalledWith(job2);\n\n      await vi.advanceTimersByTimeAsync(1500); // Allow jobs to finish\n\n      expect(mockQueue.markJobAsCompleted).toHaveBeenCalledWith(job1.id, workerService.workerId, {status: `done_${job1.id.value}`}, job1);\n      expect(mockQueue.markJobAsCompleted).toHaveBeenCalledWith(job2.id, workerService.workerId, {status: `done_${job2.id.value}`}, job2);\n      expect(workerService.activeJobCount).toBe(0);\n    });\n\n\n    it('should handle job.updateProgress and job.addLog from processor', async () => {\n      const job = createMockJob('progress', { data: 'progress data' });\n      mockQueue.fetchNextJobAndLock.mockResolvedValueOnce(job);\n\n      mockProcessor.mockImplementationOnce(async (jobCtx) => { // Renamed j to jobCtx\n        jobCtx.updateProgress(50); // This should call queue.updateJobProgress via the bound method\n        jobCtx.addLog('Processor log 1', 'INFO'); // This should call queue.addLog\n        return { status: 'progress_done' };\n      });\n\n      workerService.run();\n      await vi.advanceTimersByTimeAsync(100);\n\n      expect(mockProcessor).toHaveBeenCalledWith(job);\n      // The actual call to queue methods happens because JobEntity methods are bound by WorkerService\n      // before passing the job to the processor.\n      expect(mockQueue.updateJobProgress).toHaveBeenCalledWith(job.id, workerService.workerId, 50);\n      expect(mockQueue.addJobLog).toHaveBeenCalledWith(job.id, workerService.workerId, 'Processor log 1', 'INFO');\n      expect(mockQueue.markJobAsCompleted).toHaveBeenCalled();\n    });\n  });\n\n  describe('lock renewal', () => {\n    it('should renew lock periodically for an active job', async () => {\n      const job = createMockJob('lockrenew', { data: 'renew me' });\n      mockQueue.fetchNextJobAndLock.mockResolvedValueOnce(job);\n\n      // Simulate a long-running job\n      mockProcessor.mockImplementationOnce(async () => {\n        await vi.advanceTimersByTimeAsync(workerOptions.lockDuration * 2); // Process longer than lock duration\n        return { status: 'renewed_done' };\n      });\n\n      workerService.run();\n      await vi.advanceTimersByTimeAsync(100); // Job picked up\n\n      expect(mockQueue.fetchNextJobAndLock).toHaveBeenCalledTimes(1);\n      expect(workerService.activeJobCount).toBe(1);\n\n      // Advance time to just before the first lock renewal should happen\n      // lockDuration = 10000, lockRenewTimeBuffer = 2000. So, renew at 8000ms.\n      await vi.advanceTimersByTimeAsync(workerOptions.lockDuration - workerOptions.lockRenewTimeBuffer - 100); // e.g., 7900ms\n      expect(mockQueue.extendJobLock).not.toHaveBeenCalled();\n\n      await vi.advanceTimersByTimeAsync(200); // e.g., total 8100ms, past renewal point\n      expect(mockQueue.extendJobLock).toHaveBeenCalledWith(job.id, workerService.workerId, workerOptions.lockDuration);\n\n      // Advance time for another renewal cycle\n      await vi.advanceTimersByTimeAsync(workerOptions.lockDuration - workerOptions.lockRenewTimeBuffer + 100);\n      expect(mockQueue.extendJobLock).toHaveBeenCalledTimes(2);\n\n      // Allow job to finish\n      await vi.runOnlyPendingTimersAsync();\n      await vi.runOnlyPendingTimersAsync(); // one more for safety for all promises to resolve\n\n      expect(mockQueue.markJobAsCompleted).toHaveBeenCalled();\n      expect(workerService.activeJobCount).toBe(0);\n    });\n\n    it('should stop renewing lock if job finishes', async () => {\n      const job = createMockJob('lockstop', { data: 'stop renew' });\n      mockQueue.fetchNextJobAndLock.mockResolvedValueOnce(job);\n\n      // Job finishes quickly, before first lock renewal\n      mockProcessor.mockResolvedValueOnce({ status: 'stopped_done' });\n\n      workerService.run();\n      await vi.advanceTimersByTimeAsync(100); // Job picked up and processed\n\n      expect(mockQueue.markJobAsCompleted).toHaveBeenCalled();\n\n      // Advance time past where a renewal would have happened\n      await vi.advanceTimersByTimeAsync(workerOptions.lockDuration);\n      expect(mockQueue.extendJobLock).not.toHaveBeenCalled();\n    });\n  });\n\n  describe('close', () => {\n    it('should stop polling for new jobs and wait for active jobs to complete (graceful shutdown)', async () => {\n      const job1 = createMockJob('close1', { data: 'closing job 1' });\n      mockQueue.fetchNextJobAndLock.mockResolvedValueOnce(job1);\n\n      // job1 takes 2 seconds to process\n      mockProcessor.mockImplementationOnce(async (jobCtx) => { // Renamed j to jobCtx\n        await new Promise(resolve => setTimeout(resolve, 2000));\n        return { status: `closed_${jobCtx.id.value}` };\n      });\n\n      workerService.run();\n      await vi.advanceTimersByTimeAsync(100); // job1 is picked up\n\n      expect(workerService.activeJobCount).toBe(1);\n      expect(workerService.isRunning).toBe(true);\n\n      const closePromise = workerService.close(); // Initiate close\n      expect(workerService.isClosing).toBe(true);\n      expect(workerService.isRunning).toBe(false); // Should stop polling loop immediately\n\n      // At this point, fetchNextJobAndLock should not be called again even if polling interval hits\n      mockQueue.fetchNextJobAndLock.mockClear(); // Clear previous calls\n      await vi.advanceTimersByTimeAsync(500); // Advance, but no new jobs should be fetched\n      expect(mockQueue.fetchNextJobAndLock).not.toHaveBeenCalled();\n\n      expect(workerService.activeJobCount).toBe(1); // job1 still processing\n\n      await vi.advanceTimersByTimeAsync(2000); // Allow job1 to complete\n      await closePromise; // Wait for close to fully complete\n\n      expect(mockQueue.markJobAsCompleted).toHaveBeenCalledWith(job1.id, workerService.workerId, {status: `closed_${job1.id.value}`}, job1);\n      expect(workerService.activeJobCount).toBe(0);\n      expect(workerService.isClosed).toBe(true);\n      // Check that internal timers (polling, lock renewal) are cleared\n      // This is hard to check directly without exposing internals, but graceful shutdown implies this.\n    });\n\n    it('should close immediately if no active jobs', async () => {\n      mockQueue.fetchNextJobAndLock.mockResolvedValue(null); // No jobs\n      workerService.run();\n      await vi.advanceTimersByTimeAsync(100);\n\n      const closePromise = workerService.close();\n      await closePromise;\n\n      expect(workerService.isClosed).toBe(true);\n      expect(workerService.activeJobCount).toBe(0);\n      // No jobs were processed\n      expect(mockProcessor).not.toHaveBeenCalled();\n    });\n\n    it('multiple close calls should not cause issues', async () => {\n      workerService.run();\n      await vi.advanceTimersByTimeAsync(100);\n\n      const p1 = workerService.close();\n      const p2 = workerService.close(); // Call close again while already closing\n\n      await Promise.all([p1, p2]);\n      expect(workerService.isClosed).toBe(true);\n    });\n  });\n\n  // TODO: Test for 'worker.error' event if the queue itself throws an error during operations.\n  // This might require making the mockQueue.fetchNextJobAndLock throw an error.\n\n  it('should emit worker.error if queue.fetchNextJobAndLock throws and continues polling', async () => {\n    const fetchError = new Error('Failed to fetch from queue');\n    mockQueue.fetchNextJobAndLock.mockRejectedValueOnce(fetchError);\n\n    // Spy on the poll method to ensure it's called again\n    const pollSpy = vi.spyOn(workerService as any, 'poll');\n\n    workerService.run();\n    // Advance timers enough for the poll to execute and the error to be processed\n    await vi.advanceTimersByTimeAsync(100);\n\n\n    expect(workerService.emit).toHaveBeenCalledWith('worker.error', fetchError);\n    expect(pollSpy).toHaveBeenCalledTimes(1); // Initial call that errored\n\n    // Ensure it continues polling for the next cycle\n    mockQueue.fetchNextJobAndLock.mockResolvedValueOnce(null); // Next attempt finds no job\n    await vi.advanceTimersByTimeAsync(1000 + 50); // Default poll interval + buffer\n\n    expect(mockQueue.fetchNextJobAndLock).toHaveBeenCalledTimes(2); // fetch called again\n    expect(pollSpy.mock.calls.length).toBeGreaterThanOrEqual(2); // poll() itself was called again\n    pollSpy.mockRestore();\n  });\n\n  it('should emit worker.job.interrupted if closed during processing and not call complete/fail on queue', async () => {\n    const job = createMockJob('interrupted', { data: 'interrupt me' });\n    mockQueue.fetchNextJobAndLock.mockResolvedValueOnce(job);\n\n    const processorPromiseCtrl = {\n      resolve: () => {},\n      reject: () => {},\n    };\n    const processorPromise = new Promise<TestResult>((resolve, reject) => {\n      processorPromiseCtrl.resolve = resolve;\n      processorPromiseCtrl.reject = reject;\n    });\n\n    mockProcessor.mockImplementationOnce(() => {\n      // Simulate work is about to start or in progress\n      // Then worker is closed externally before this promise resolves\n      return processorPromise;\n    });\n\n    workerService.run();\n    await vi.advanceTimersByTimeAsync(50); // Job picked up, processor called\n\n    expect(workerService.emit).toHaveBeenCalledWith('worker.job.active', job);\n    expect(mockProcessor).toHaveBeenCalledWith(job);\n\n    // Now, close the worker while the job is notionally \"processing\"\n    // (i.e., processorPromise has not resolved)\n    const closePromise = workerService.close();\n\n    // Since close is called, the worker should not wait for the processorPromise to complete.\n    // Instead, it should proceed with shutdown.\n    // We need to ensure that the internal logic of processJob correctly identifies this scenario.\n\n    // Resolve the processor's promise *after* close has been initiated to simulate job \"finishing\" work\n    // but the worker is already shutting down.\n    processorPromiseCtrl.resolve({ status: 'finished_but_worker_closed' });\n    \n    await vi.runAllTimersAsync(); // Allow all timers (polling, lock renewal, close loop) to run\n    await closePromise; // Ensure close completes\n\n    expect(workerService.isClosed).toBe(true);\n    expect(workerService.emit).toHaveBeenCalledWith('worker.job.interrupted', job);\n    expect(mockQueue.markJobAsCompleted).not.toHaveBeenCalled();\n    expect(mockQueue.markJobAsFailed).not.toHaveBeenCalled();\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/examples/queue-usage-example.final.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":58,"fix":{"range":[187,187],"text":"\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"// src_refactored/examples/queue-usage-example.final.ts\nimport { WorkerService } from '@/core/application/worker/worker.service';\nimport { JobEntity } from '@/core/domain/job/job.entity';\nimport { db } from '@/infrastructure/persistence/drizzle/drizzle.client';\nimport { DrizzleJobRepository } from '@/infrastructure/persistence/drizzle/job/drizzle-job.repository';\nimport { QueueService } from '@/infrastructure/queue/drizzle/queue.service';\n\nasync function main() {\n  const jobRepository = new DrizzleJobRepository(db);\n  const queue = new QueueService('default', jobRepository);\n\n  // Job processor function\n  const processor = async (job: JobEntity<{ email: string }, { status: string }>): Promise<{ status: string }> => {\n    process.stdout.write(`[Worker] Processing job ${job.id.value} (attempt ${job.attemptsMade}) for email: ${job.payload.email}\\n`);\n\n    // Simulate work with progress updates\n    for (let progressValue = 0; progressValue <= 100; progressValue += 25) { // Renamed i to progressValue\n      await new Promise(resolve => setTimeout(resolve, 500));\n      job.updateProgress(progressValue);\n      job.addLog(`Progress updated to ${progressValue}%`);\n      process.stdout.write(`[Worker] Job ${job.id.value} progress: ${progressValue}%\\n`);\n    }\n\n    // Simulate retry logic: fail twice, then succeed\n    if (job.attemptsMade < 3 && job.payload.email === 'retry@example.com') {\n      job.addLog('Simulating transient failure for retry job.', 'ERROR');\n      process.stdout.write(`[Worker] Job ${job.id.value} (retry job) failed. Attempts made: ${job.attemptsMade}\\n`);\n      throw new Error('Simulated transient error');\n    }\n\n    // Simulate permanent failure for a specific job\n    if (job.payload.email === 'fail@example.com') {\n      job.addLog('Simulating permanent failure.', 'ERROR');\n      process.stdout.write(`[Worker] Job ${job.id.value} (fail job) failed permanently.\\n`);\n      throw new Error('Simulated permanent error');\n    }\n\n    job.addLog('Job completed successfully.', 'INFO');\n    process.stdout.write(`[Worker] Job ${job.id.value} completed successfully.\\n`);\n    return { status: 'Email sent' };\n  };\n\n  const worker = new WorkerService(queue, processor, { concurrency: 2, lockDuration: 15000, lockRenewTimeBuffer: 5000 });\n\n  // Event listeners for queue and worker\n  queue.on('job.added', (job) => process.stdout.write(`[Queue] Job added: ${job.id.value} (Name: ${job.name}, Status: ${job.status})\\n`));\n  queue.on('job.completed', (job) => process.stdout.write(`[Queue] Job completed: ${job.id.value} (Result: ${JSON.stringify(job.returnValue)})\\n`));\n  queue.on('job.failed', (job) => process.stdout.write(`[Queue] Job failed: ${job.id.value} (Reason: ${job.failedReason}, Attempts: ${job.attemptsMade})\\n`));\n  queue.on('job.active', (job) => process.stdout.write(`[Queue] Job ${job.id.value} is now active.\\n`));\n  queue.on('job.stalled', (job) => process.stdout.write(`[Queue] Job ${job.id.value} stalled and re-queued.\\n`));\n  queue.on('job.progress', (job) => process.stdout.write(`[Queue] Job ${job.id.value} progress updated to ${job.progress}\\n`));\n  queue.on('job.log', (job) => process.stdout.write(`[Queue] Job ${job.id.value} log: ${job.logs[job.logs.length - 1].message}\\n`));\n\n  worker.on('worker.job.active', (job) => process.stdout.write(`[Worker] Worker started processing job: ${job.id.value}\\n`));\n  worker.on('worker.job.processed', (job) => process.stdout.write(`[Worker] Worker finished processing job: ${job.id.value}\\n`));\n  worker.on('worker.job.errored', (job, error) => process.stdout.write(`[Worker] Worker encountered error for job ${job.id.value}: ${error.message}\\n`));\n\n  // Add various job scenarios\n  await queue.add('send-email', { email: 'success@example.com' }); // Succeeds on first attempt\n  await queue.add('send-email', { email: 'delayed@example.com' }, { delay: 7000 }); // Delayed job\n  await queue.add('send-email', { email: 'retry@example.com' }, { attempts: 3, backoff: { type: 'exponential', delay: 1000 } }); // Fails then retries\n  await queue.add('send-email', { email: 'fail@example.com' }, { attempts: 1 }); // Fails permanently\n\n  worker.run();\n  queue.startMaintenance();\n\n  process.stdout.write('Queue and Worker started. Waiting for jobs to complete...\\n');\n\n  // Keep the process alive for a while to observe job processing\n  setTimeout(async () => {\n    process.stdout.write('Shutting down worker and queue...\\n');\n    await worker.close();\n    await queue.close();\n    process.stdout.write('Worker and queue closed. Exiting.\\n');\n    process.exit(0);\n  }, 60000); // Run for 60 seconds\n}\n\nmain().catch(console.error);","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/ioc/inversify.config.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":95,"fix":{"range":[325,325],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`@/infrastructure/persistence/drizzle/drizzle.client` import should occur before import of `@/infrastructure/persistence/drizzle/job/drizzle-job.repository`","line":10,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":74,"fix":{"range":[326,643],"text":"import { db } from '@/infrastructure/persistence/drizzle/drizzle.client'; // db after other infra\nimport { DrizzleJobRepository } from '@/infrastructure/persistence/drizzle/job/drizzle-job.repository'; // Corrected order\nimport { QueueService } from '@/infrastructure/queue/drizzle/queue.service'; // Corrected order\n"}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":22,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1270,1273],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1270,1273],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":22,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1275,1278],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1275,1278],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"// src_refactored/infrastructure/ioc/inversify.config.ts\nimport 'reflect-metadata';\n\nimport { Container } from 'inversify';\n\nimport { IJobRepository, JOB_REPOSITORY_TOKEN } from '@/core/application/ports/job-repository.interface';\nimport { AbstractQueue, getQueueServiceToken } from '@/core/application/queue/abstract-queue';\nimport { DrizzleJobRepository } from '@/infrastructure/persistence/drizzle/job/drizzle-job.repository'; // Corrected order\nimport { QueueService } from '@/infrastructure/queue/drizzle/queue.service'; // Corrected order\nimport { db } from '@/infrastructure/persistence/drizzle/drizzle.client'; // db after other infra\n\nexport const appContainer = new Container();\n\n// Database Client\n// The 'db' instance from drizzle.client is directly used in repository construction,\n// so explicit binding of 'drizzle' symbol might not be strictly necessary unless used elsewhere.\n// For now, we ensure db is available for DrizzleJobRepository.\n// appContainer.bind('drizzle').toConstantValue(db); // This line can be kept or removed if db is only used for repo instantiation.\n\n// Job Repository and Queue Service bindings\nappContainer.bind<IJobRepository>(JOB_REPOSITORY_TOKEN).toConstantValue(new DrizzleJobRepository(db));\nappContainer.bind<AbstractQueue<any, any>>(getQueueServiceToken('default')).toDynamicValue(() => { // Removed unused context\n  const jobRepository = appContainer.get<IJobRepository>(JOB_REPOSITORY_TOKEN);\n  return new QueueService('default', jobRepository);\n}).inSingletonScope();\n","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/persistence/drizzle/job/drizzle-job.repository.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":9,"column":1,"nodeType":"ImportDeclaration","endLine":9,"endColumn":55,"fix":{"range":[548,548],"text":"\n"}},{"ruleId":"import/order","severity":1,"message":"`../schema` import should occur before type import of `../drizzle.client`","line":10,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":37,"fix":{"range":[494,586],"text":"import * as schema from '../schema';\nimport type { db as DbType } from '../drizzle.client';\n"}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":55,"column":74,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":55,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2869,2872],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2869,2872],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":55,"column":142,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":55,"endColumn":145,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2937,2940],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2937,2940],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":61,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":61,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3207,3210],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3207,3210],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"// src_refactored/infrastructure/persistence/drizzle/job/drizzle-job.repository.ts\nimport { and, asc as ascDrizzle, desc, eq, inArray, isNull, lt, or } from 'drizzle-orm';\n\nimport { IJobRepository } from '@/core/application/ports/job-repository.interface';\nimport { JobEntity, JobStatus, JobPersistenceData } from '@/core/domain/job/job.entity';\nimport { JobIdVO } from '@/core/domain/job/value-objects/job-id.vo';\nimport { IJobOptions } from '@/core/domain/job/value-objects/job-options.vo';\n\nimport type { db as DbType } from '../drizzle.client';\nimport * as schema from '../schema';\n\nexport class DrizzleJobRepository implements IJobRepository {\n  constructor(private readonly drizzleDbInstance: typeof DbType) {}\n\n  // Helper to map Drizzle's JobSelect to domain's JobPersistenceData\n  private mapToPersistenceData<P, R>(jobData: schema.JobSelect): JobPersistenceData<P, R> {\n    // Ensure JSON fields are properly cast/parsed if necessary.\n    // Drizzle's db.query often auto-parses JSON, but db.select might not.\n    // For db.query results, direct assignment is usually fine.\n    const options = jobData.options as IJobOptions; // Drizzle query should parse this\n    const logs = (jobData.logs as Array<{ message: string; level: string; timestamp: number }>) || [];\n    const payload = jobData.payload as P;\n    const returnValue = jobData.returnValue as R | null;\n    const progress = jobData.progress as number | object;\n    const stacktrace = jobData.stacktrace as string[] | null;\n\n    return {\n      id: jobData.id,\n      queueName: jobData.queueName,\n      name: jobData.name,\n      payload: payload,\n      options: options,\n      status: jobData.status as JobStatus, // Schema status is string, cast to enum\n      attemptsMade: jobData.attemptsMade,\n      progress: progress,\n      logs: logs, // Logs in schema are already {ts: number} via JobEntity.toPersistence mapping\n      createdAt: jobData.createdAt.getTime(), // Convert Date to number\n      updatedAt: jobData.updatedAt.getTime(), // Convert Date to number\n      processedOn: jobData.processedOn ? jobData.processedOn.getTime() : null,\n      finishedOn: jobData.finishedOn ? jobData.finishedOn.getTime() : null,\n      delayUntil: jobData.delayUntil ? jobData.delayUntil.getTime() : null,\n      lockUntil: jobData.lockUntil ? jobData.lockUntil.getTime() : null,\n      workerId: jobData.workerId,\n      returnValue: returnValue,\n      failedReason: jobData.failedReason,\n      stacktrace: stacktrace,\n      // priority is part of options, not separate here\n      // repeatJobKey and parentId are not in JobPersistenceData yet\n    };\n  }\n\n  async save(job: JobEntity<unknown, unknown>): Promise<void> {\n    const data = job.toPersistence();\n    // Drizzle handles Date -> number for timestamp_ms fields during insert/update\n    await this.drizzleDbInstance.insert(schema.jobsTable).values(data as any).onConflictDoUpdate({ target: schema.jobsTable.id, set: data as any });\n  }\n\n  async update(job: JobEntity<unknown, unknown>): Promise<void> {\n    const data = job.toPersistence();\n    // Drizzle handles Date -> number for timestamp_ms fields during insert/update\n    await this.drizzleDbInstance.update(schema.jobsTable).set(data as any).where(eq(schema.jobsTable.id, data.id));\n  }\n\n  async findById(id: JobIdVO): Promise<JobEntity<unknown, unknown> | null> {\n    const result = await this.drizzleDbInstance.query.jobsTable.findFirst({ where: eq(schema.jobsTable.id, id.value) });\n    if (!result) return null;\n    return JobEntity.fromPersistence(this.mapToPersistenceData(result));\n  }\n\n  async findNextJobsToProcess(queueName: string, limit: number): Promise<Array<JobEntity<unknown, unknown>>> {\n    const now = new Date();\n    const results = await this.drizzleDbInstance.query.jobsTable.findMany({ // Corrected: use this.drizzleDbInstance\n      where: and(\n        eq(schema.jobsTable.queueName, queueName),\n        // Job is either WAITING or it was DELAYED and its time has come\n        or(\n          eq(schema.jobsTable.status, JobStatus.WAITING),\n          and(\n            eq(schema.jobsTable.status, JobStatus.DELAYED),\n            lt(schema.jobsTable.delayUntil, now)\n          )\n        )\n      ),\n      orderBy: [ascDrizzle(schema.jobsTable.priority), ascDrizzle(schema.jobsTable.createdAt)],\n      limit,\n    });\n    return results.map(jobData => JobEntity.fromPersistence(this.mapToPersistenceData(jobData)));\n  }\n\n  async acquireLock(jobId: JobIdVO, workerId: string, lockUntil: Date): Promise<boolean> {\n    const result = await this.drizzleDbInstance.update(schema.jobsTable)\n      .set({ workerId, lockUntil, status: JobStatus.ACTIVE })\n      .where(and(eq(schema.jobsTable.id, jobId.value), or(isNull(schema.jobsTable.workerId), lt(schema.jobsTable.lockUntil, new Date()))))\n    return result.changes > 0;\n  }\n\n  async extendLock(jobId: JobIdVO, workerId: string, lockUntil: Date): Promise<void> {\n    await this.drizzleDbInstance.update(schema.jobsTable)\n      .set({ lockUntil })\n      .where(and(eq(schema.jobsTable.id, jobId.value), eq(schema.jobsTable.workerId, workerId)));\n  }\n\n  async findStalledJobs(queueName: string, olderThan: Date, limit: number): Promise<Array<JobEntity<unknown, unknown>>> {\n    const results = await this.drizzleDbInstance.query.jobsTable.findMany({\n      where: and(\n        eq(schema.jobsTable.queueName, queueName),\n        eq(schema.jobsTable.status, JobStatus.ACTIVE),\n        lt(schema.jobsTable.lockUntil, olderThan)\n      ),\n      limit,\n    });\n    return results.map(jobData => JobEntity.fromPersistence(this.mapToPersistenceData(jobData)));\n  }\n\n  async remove(jobId: JobIdVO): Promise<void> {\n    await this.drizzleDbInstance.delete(schema.jobsTable).where(eq(schema.jobsTable.id, jobId.value));\n  }\n\n  async getJobsByStatus(\n    queueName: string,\n    statuses: JobStatus[],\n    start: number = 0,\n    end: number = 100,\n    asc: boolean = false,\n  ): Promise<Array<JobEntity<unknown, unknown>>> {\n    // Parameter 'end' is used as 'count' or 'limit' based on typical usage patterns and UI calls.\n    const results = await this.drizzleDbInstance.query.jobsTable.findMany({ // Corrected: use this.drizzleDbInstance\n      where: and(eq(schema.jobsTable.queueName, queueName), inArray(schema.jobsTable.status, statuses)),\n      orderBy: [asc ? ascDrizzle(schema.jobsTable.createdAt) : desc(schema.jobsTable.createdAt)],\n      offset: start,\n      limit: end, // 'end' here is the count/limit of items to fetch\n    });\n    return results.map(jobData => JobEntity.fromPersistence(this.mapToPersistenceData(jobData)));\n  }\n\n  async countJobsByStatus(queueName: string, statuses?: JobStatus[]): Promise<Partial<Record<JobStatus, number>>> {\n    const query = this.drizzleDbInstance.select({\n      status: schema.jobsTable.status,\n      count: schema.sql`count(*)`.mapWith(Number),\n    }).from(schema.jobsTable)\n      .where(\n        and(\n          eq(schema.jobsTable.queueName, queueName),\n          statuses ? inArray(schema.jobsTable.status, statuses) : undefined\n        )\n      )\n      .groupBy(schema.jobsTable.status);\n\n    const results = await query;\n    return results.reduce((acc, row) => {\n      acc[row.status as JobStatus] = row.count as number;\n      return acc;\n    }, {} as Partial<Record<JobStatus, number>>);\n  }\n\n  async clean(queueName: string, gracePeriodMs: number, limit: number, status?: JobStatus): Promise<number> {\n    const now = new Date();\n    const finishedOlderThan = new Date(now.getTime() - gracePeriodMs);\n\n    // Step 1: Select IDs of jobs to be deleted, respecting the limit\n    const jobsToDeleteIdsQuery = this.drizzleDbInstance.select({ id: schema.jobsTable.id })\n      .from(schema.jobsTable)\n      .where(and(\n        eq(schema.jobsTable.queueName, queueName),\n        status ? eq(schema.jobsTable.status, status) :\n                 or(eq(schema.jobsTable.status, JobStatus.COMPLETED), eq(schema.jobsTable.status, JobStatus.FAILED)), // Default to completed/failed\n        lt(schema.jobsTable.finishedOn, finishedOlderThan)\n      ))\n      .orderBy(ascDrizzle(schema.jobsTable.finishedOn)) // Delete oldest first\n      .limit(limit);\n\n    const jobsToDelete = await jobsToDeleteIdsQuery;\n\n    if (jobsToDelete.length === 0) {\n      return 0;\n    }\n\n    const ids = jobsToDelete.map(jobEntry => jobEntry.id); // Renamed 'j' to 'jobEntry'\n\n    // Step 2: Delete jobs with the selected IDs\n    const result = await this.drizzleDbInstance.delete(schema.jobsTable)\n      .where(inArray(schema.jobsTable.id, ids));\n\n    return result.changes; // Number of rows deleted\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/queue/drizzle/__tests__/queue.service.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/src_refactored/infrastructure/queue/drizzle/queue.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]