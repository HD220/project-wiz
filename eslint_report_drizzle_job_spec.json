[{"filePath":"/app/src_refactored/infrastructure/persistence/drizzle/job/__tests__/drizzle-job.repository.spec.ts","messages":[{"ruleId":"import/order","severity":1,"message":"There should be at least one empty line between import groups","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":69,"fix":{"range":[333,333],"text":"\n"}},{"ruleId":"no-undef","severity":2,"message":"'JobEntityProps' is not defined.","line":133,"column":57,"nodeType":"Identifier","messageId":"undef","endLine":133,"endColumn":71},{"ruleId":"max-lines","severity":2,"message":"File has too many lines (310). Maximum allowed is 200.","line":245,"column":1,"nodeType":null,"messageId":"exceed","endLine":375,"endColumn":1},{"ruleId":"no-undef","severity":2,"message":"'JobEntityProps' is not defined.","line":310,"column":29,"nodeType":"Identifier","messageId":"undef","endLine":310,"endColumn":43},{"ruleId":"no-undef","severity":2,"message":"'JobEntityProps' is not defined.","line":316,"column":32,"nodeType":"Identifier","messageId":"undef","endLine":316,"endColumn":46},{"ruleId":"no-undef","severity":2,"message":"'JobEntityProps' is not defined.","line":322,"column":35,"nodeType":"Identifier","messageId":"undef","endLine":322,"endColumn":49},{"ruleId":"no-undef","severity":2,"message":"'JobEntityProps' is not defined.","line":346,"column":38,"nodeType":"Identifier","messageId":"undef","endLine":346,"endColumn":52},{"ruleId":"no-undef","severity":2,"message":"'JobEntityProps' is not defined.","line":352,"column":35,"nodeType":"Identifier","messageId":"undef","endLine":352,"endColumn":49},{"ruleId":"no-undef","severity":2,"message":"'JobEntityProps' is not defined.","line":357,"column":60,"nodeType":"Identifier","messageId":"undef","endLine":357,"endColumn":74}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import BetterSqlite3 from \"better-sqlite3\";\nimport { drizzle, BetterSQLite3Database } from \"drizzle-orm/better-sqlite3\";\nimport { migrate } from \"drizzle-orm/better-sqlite3/migrator\";\nimport { describe, it, expect, beforeEach, beforeAll, afterAll } from \"vitest\";\n\nimport { JobEntity, JobStatus } from \"@/core/domain/job/job.entity\";\nimport * as schema from \"../../schema\"; // Adjusted path to be two levels up\nimport { DrizzleJobRepository } from \"../drizzle-job.repository\"; // Adjusted path to be one level up\n\n// Define more specific types for payload and result for these tests\ninterface TestJobPayload {\n  data?: string;\n  order?: number;\n  newData?: string;\n  [key: string]: unknown;\n}\ninterface TestJobResult {\n  [key: string]: unknown;\n}\n\n// Helper function to create a job entity for tests\nconst createTestJob = (\n  props: Partial<\n    Parameters<typeof JobEntity.create<TestJobPayload, TestJobResult>>[0]\n  > = {}\n): JobEntity<TestJobPayload, TestJobResult> => {\n  return JobEntity.create<TestJobPayload, TestJobResult>({\n    queueName: \"test-queue\",\n    name: \"test-job-name\",\n    payload: { data: \"sample\" },\n    options: { priority: 10, attempts: 1 },\n    ...props,\n  });\n};\n\n// Variables for shared test context\nlet testDb: BetterSQLite3Database<typeof schema>;\nlet sqliteInstance: BetterSqlite3.Database;\nlet repository: DrizzleJobRepository;\n\nbeforeAll(() => {\n  sqliteInstance = new BetterSqlite3(\":memory:\");\n  testDb = drizzle(sqliteInstance, { schema });\n  migrate(testDb, {\n    migrationsFolder:\n      \"./src_refactored/infrastructure/persistence/drizzle/migrations\",\n  });\n});\n\nafterAll(() => {\n  sqliteInstance.close();\n});\n\nbeforeEach(async () => {\n  // Ensure repository is new for each test, and tables are clean\n  repository = new DrizzleJobRepository(testDb);\n  await testDb.delete(schema.jobsTable);\n});\n\ndescribe(\"DrizzleJobRepository - save and findById\", () => {\n  it(\"should save a new job and find it by ID\", async () => {\n    const job = createTestJob();\n    await repository.save(job);\n\n    const foundJob = await repository.findById(job.getProps().id);\n    expect(foundJob).not.toBeNull();\n    const jobProps = job.getProps();\n    const foundJobProps = foundJob!.getProps();\n    expect(foundJobProps.id.equals(jobProps.id)).toBe(true);\n    expect(foundJobProps.name).toBe(jobProps.name);\n    expect(foundJobProps.payload).toEqual(jobProps.payload);\n  });\n\n  it(\"save should update an existing job (upsert behavior)\", async () => {\n    const job = createTestJob();\n    await repository.save(job);\n\n    job.updateProgress(50); // Method call, no change to getProps() here\n    // Accessing payload for modification requires care if props are deeply readonly.\n    // Assuming payload itself is mutable for this test.\n    (job.getProps().payload as TestJobPayload).newData = \"updated\";\n    await repository.save(job);\n\n    const foundJob = await repository.findById(job.getProps().id);\n    expect(foundJob).not.toBeNull();\n    const foundJobProps = foundJob!.getProps();\n    expect(foundJobProps.progress).toBe(50);\n    expect((foundJobProps.payload as TestJobPayload).newData).toBe(\"updated\");\n  });\n});\n\ndescribe(\"update\", () => {\n  it(\"should update an existing job properties\", async () => {\n    const job = createTestJob();\n    await repository.save(job);\n\n    job.updateProgress(75); // Method call\n    job.addLog(\"Update log\"); // Method call\n    await repository.update(job);\n\n    const updatedJob = await repository.findById(job.getProps().id);\n    expect(updatedJob).not.toBeNull();\n    const updatedJobProps = updatedJob!.getProps();\n    expect(updatedJobProps.progress).toBe(75);\n    expect(updatedJobProps.logs.length).toBe(1);\n    expect(updatedJobProps.logs[0].message).toBe(\"Update log\");\n  });\n});\n\ndescribe(\"findNextJobsToProcess\", () => {\n  it(\"should find WAITING jobs ordered by priority then createdAt\", async () => {\n    const job1 = createTestJob({ options: { priority: 5 } });\n    const job2 = createTestJob({ options: { priority: 10 } });\n      const job3Delayed = createTestJob({\n        options: { priority: 1, delay: 10000 },\n      });\n\n      await repository.save(job2);\n      await repository.save(job1);\n      await repository.save(job3Delayed);\n\n      const nextJobs = await repository.findNextJobsToProcess(\"test-queue\", 3);\n      expect(nextJobs.length).toBe(2);\n      expect(nextJobs[0].getProps().id.equals(job1.getProps().id)).toBe(true);\n      expect(nextJobs[1].getProps().id.equals(job2.getProps().id)).toBe(true);\n    });\n\n    it(\"should find DELAYED jobs whose delayUntil has passed\", async () => {\n      const pastDelay = new Date(Date.now() - 5000);\n      const jobDelayedPast = createTestJob({ options: { delay: 1 } });\n      \n      // Modifying props directly for test setup. In real code, use entity methods.\n      const mutableProps = jobDelayedPast.getProps() as JobEntityProps<TestJobPayload, TestJobResult>;\n      mutableProps.createdAt = new Date(Date.now() - 10000);\n      mutableProps.delayUntil = pastDelay;\n      mutableProps.status = JobStatus.DELAYED;\n      // Note: This direct props modification is for test setup expediency.\n      // In a real scenario, an entity method should handle such state changes if valid.\n      await repository.save(jobDelayedPast); // save will use the current state of jobDelayedPast.getProps()\n\n      const nextJobs = await repository.findNextJobsToProcess(\"test-queue\", 1);\n      expect(nextJobs.length).toBe(1);\n      expect(nextJobs[0].getProps().id.equals(jobDelayedPast.getProps().id)).toBe(true);\n    });\n  });\n\n  describe(\"acquireLock and extendLock\", () => {\n    it(\"should acquire a lock for an available job\", async () => {\n      const job = createTestJob();\n      await repository.save(job);\n\n      const workerId = \"worker-1\";\n      const lockUntil = new Date(Date.now() + 30000);\n      const locked = await repository.acquireLock(job.getProps().id, workerId, lockUntil);\n      expect(locked).toBe(true);\n\n      const lockedJob = await repository.findById(job.getProps().id);\n      expect(lockedJob).not.toBeNull();\n      const lockedJobProps = lockedJob!.getProps();\n      expect(lockedJobProps.status).toBe(JobStatus.ACTIVE);\n      expect(lockedJobProps.workerId).toBe(workerId);\n      expect(lockedJobProps.lockUntil!.getTime()).toBeCloseTo(lockUntil.getTime());\n    });\n\n    it(\"should not acquire a lock if job is already locked by another worker\", async () => {\n      const job = createTestJob();\n      await repository.save(job);\n      await repository.acquireLock(\n        job.getProps().id,\n        \"worker-1\",\n        new Date(Date.now() + 30000)\n      );\n\n      const lockedByOther = await repository.acquireLock(\n        job.getProps().id,\n        \"worker-2\",\n        new Date(Date.now() + 30000)\n      );\n      expect(lockedByOther).toBe(false);\n    });\n\n    it(\"should acquire a lock if existing lock has expired\", async () => {\n      const job = createTestJob();\n      await repository.save(job);\n      await repository.acquireLock(\n        job.getProps().id,\n        \"worker-1\",\n        new Date(Date.now() - 1000)\n      );\n\n      const acquired = await repository.acquireLock(\n        job.getProps().id,\n        \"worker-2\",\n        new Date(Date.now() + 30000)\n      );\n      expect(acquired).toBe(true);\n      const lockedJob = await repository.findById(job.getProps().id);\n      expect(lockedJob).not.toBeNull();\n      expect(lockedJob!.getProps().workerId).toBe(\"worker-2\");\n    });\n\n    it(\"should extend an existing lock\", async () => {\n      const job = createTestJob();\n      await repository.save(job);\n      const workerId = \"worker-1\";\n      await repository.acquireLock(\n        job.getProps().id,\n        workerId,\n        new Date(Date.now() + 10000)\n      );\n\n      const newLockUntil = new Date(Date.now() + 60000);\n      await repository.extendLock(job.getProps().id, workerId, newLockUntil);\n\n      const extendedLockJob = await repository.findById(job.getProps().id);\n      expect(extendedLockJob).not.toBeNull();\n      expect(extendedLockJob!.getProps().lockUntil!.getTime()).toBeCloseTo(\n        newLockUntil.getTime()\n      );\n    });\n  });\n\n  describe(\"findStalledJobs\", () => {\n    it(\"should find active jobs whose lock has expired\", async () => {\n      const job = createTestJob();\n      await repository.save(job);\n\n      const workerId = \"worker-stalled\";\n      const expiredLockUntil = new Date(Date.now() - 1000);\n      job.moveToActive(workerId, expiredLockUntil); // Method call\n      await repository.update(job);\n\n      const stalledJobs = await repository.findStalledJobs(\n        \"test-queue\",\n        new Date(),\n        1\n      );\n      expect(stalledJobs.length).toBe(1);\n      expect(stalledJobs[0].getProps().id.equals(job.getProps().id)).toBe(true);\n    });\n  });\n\n  describe(\"remove\", () => {\n    it(\"should remove a job from the repository\", async () => {\n      const job = createTestJob();\n      await repository.save(job);\n      await repository.remove(job.getProps().id);\n      const foundJob = await repository.findById(job.getProps().id);\n      expect(foundJob).toBeNull();\n    });\n  });\n\n  describe(\"getJobsByStatus\", () => {\n    it(\"should retrieve jobs by specified statuses with pagination and ordering\", async () => {\n      const jobW1 = createTestJob({ payload: { order: 1 } });\n      const jobW2 = createTestJob({ payload: { order: 2 } });\n      const jobA1 = createTestJob({ payload: { order: 3 } });\n      jobA1.moveToActive(\"w1\", new Date(Date.now() + 1000)); // Method call\n\n      await repository.save(jobW1);\n      await repository.save(jobA1);\n      await repository.save(jobW2);\n\n      const waitingJobs = await repository.getJobsByStatus(\n        \"test-queue\",\n        [JobStatus.WAITING],\n        0,\n        10,\n        true\n      ); // asc\n      expect(waitingJobs.length).toBe(2);\n      expect(waitingJobs[0].getProps().id.equals(jobW1.getProps().id)).toBe(true);\n      expect(waitingJobs[1].getProps().id.equals(jobW2.getProps().id)).toBe(true);\n\n      const activeJobs = await repository.getJobsByStatus(\n        \"test-queue\",\n        [JobStatus.ACTIVE],\n        0,\n        1\n      );\n      expect(activeJobs.length).toBe(1);\n      expect(activeJobs[0].getProps().id.equals(jobA1.getProps().id)).toBe(true);\n    });\n  });\n\n  describe(\"countJobsByStatus\", () => {\n    it(\"should count jobs by their status\", async () => {\n      await repository.save(createTestJob()); // job 1: waiting\n      const activeJob = createTestJob();      // job 2: initially waiting\n      await repository.save(activeJob);       // save job 2 as waiting\n      activeJob.moveToActive(\"w1\", new Date(Date.now() + 1000)); // job 2: active\n      await repository.update(activeJob);     // update job 2 to active in DB\n\n      const counts = await repository.countJobsByStatus(\"test-queue\");\n      // Expect one waiting (job 1) and one active (job 2)\n      expect(counts[JobStatus.WAITING]).toBe(1); \n      expect(counts[JobStatus.ACTIVE]).toBe(1);\n      expect(counts[JobStatus.COMPLETED]).toBeUndefined();\n    });\n  });\n\n  describe(\"clean\", () => {\n    it(\"should clean old completed jobs respecting limit and grace period\", async () => {\n      const veryOldDate = new Date(Date.now() - 2 * 24 * 60 * 60 * 1000);\n      const recentDate = new Date(Date.now() - 10 * 60 * 1000);\n\n      const jobOld = createTestJob({ name: \"old\" });\n      jobOld.moveToActive(\"w\", new Date()); // Method call\n      jobOld.markAsCompleted({}); // Method call\n      (jobOld.getProps() as JobEntityProps<TestJobPayload, TestJobResult>).finishedOn = veryOldDate;\n      await repository.save(jobOld);\n\n      const jobRecent = createTestJob({ name: \"recent\" });\n      jobRecent.moveToActive(\"w\", new Date()); // Method call\n      jobRecent.markAsCompleted({}); // Method call\n      (jobRecent.getProps() as JobEntityProps<TestJobPayload, TestJobResult>).finishedOn = recentDate;\n      await repository.save(jobRecent);\n\n      const jobFailedOld = createTestJob({ name: \"failedOld\" });\n      jobFailedOld.moveToActive(\"w\", new Date()); // Method call\n      jobFailedOld.markAsFailed(\"err\"); // Method call\n      (jobFailedOld.getProps() as JobEntityProps<TestJobPayload, TestJobResult>).finishedOn = veryOldDate;\n      await repository.save(jobFailedOld);\n\n      const cleanedCount = await repository.clean(\n        \"test-queue\",\n        24 * 60 * 60 * 1000,\n        1,\n        JobStatus.COMPLETED\n      );\n      expect(cleanedCount).toBe(1);\n\n      const foundOld = await repository.findById(jobOld.getProps().id);\n      expect(foundOld).toBeNull();\n      const foundRecent = await repository.findById(jobRecent.getProps().id);\n      expect(foundRecent).not.toBeNull();\n      const foundFailedOld = await repository.findById(jobFailedOld.getProps().id);\n      expect(foundFailedOld).not.toBeNull();\n    });\n\n    it(\"should clean old completed or failed jobs if status is not specified\", async () => {\n      const oldDate = new Date(Date.now() - 2 * 24 * 60 * 60 * 1000);\n      const jobCompletedOld = createTestJob({ name: \"c-old\" });\n      jobCompletedOld.moveToActive(\"w\", new Date()); // Method call\n      jobCompletedOld.markAsCompleted({}); // Method call\n      (jobCompletedOld.getProps() as JobEntityProps<TestJobPayload, TestJobResult>).finishedOn = oldDate;\n      await repository.save(jobCompletedOld);\n\n      const jobFailedOld = createTestJob({ name: \"f-old\" });\n      jobFailedOld.moveToActive(\"w\", new Date()); // Method call\n      jobFailedOld.markAsFailed(\"err\"); // Method call\n      (jobFailedOld.getProps() as JobEntityProps<TestJobPayload, TestJobResult>).finishedOn = oldDate;\n      await repository.save(jobFailedOld);\n\n      const jobWaiting = createTestJob({ name: \"w-old\" });\n      // Modifying props directly for test setup\n      const mutableWaitingProps = jobWaiting.getProps() as JobEntityProps<TestJobPayload, TestJobResult>;\n      mutableWaitingProps.createdAt = oldDate;\n      mutableWaitingProps.finishedOn = undefined;\n      await repository.save(jobWaiting);\n\n      const cleanedCount = await repository.clean(\n        \"test-queue\",\n        24 * 60 * 60 * 1000,\n        5\n      );\n      expect(cleanedCount).toBe(2);\n\n      expect(await repository.findById(jobCompletedOld.getProps().id)).toBeNull();\n      expect(await repository.findById(jobFailedOld.getProps().id)).toBeNull();\n      expect(await repository.findById(jobWaiting.getProps().id)).not.toBeNull();\n    });\n  });\n// Removed the all-encompassing describe block, tests are now top-level describes\n","usedDeprecatedRules":[]}]
